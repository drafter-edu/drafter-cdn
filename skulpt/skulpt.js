(() => {
  var __defProp = Object.defineProperty;
  var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
  var __getOwnPropNames = Object.getOwnPropertyNames;
  var __hasOwnProp = Object.prototype.hasOwnProperty;
  var __pow = Math.pow;
  var __esm = (fn, res) => function __init() {
    return fn && (res = (0, fn[__getOwnPropNames(fn)[0]])(fn = 0)), res;
  };
  var __commonJS = (cb, mod) => function __require() {
    return mod || (0, cb[__getOwnPropNames(cb)[0]])((mod = { exports: {} }).exports, mod), mod.exports;
  };
  var __copyProps = (to, from, except, desc) => {
    if (from && typeof from === "object" || typeof from === "function") {
      for (let key of __getOwnPropNames(from))
        if (!__hasOwnProp.call(to, key) && key !== except)
          __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
    }
    return to;
  };
  var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

  // src/util.js
  var require_util = __commonJS({
    "src/util.js"() {
      var Sk2 = {};
      Sk2.build = {
        githash: "2c0cb427",
        date: "2025-10-30T16:14:24.120Z"
      };
      Sk2.global = typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {};
      Sk2.exportSymbol = function(name, object) {
        var parts = name.split(".");
        var curobj = Sk2.global;
        var part, idx;
        for (idx = 0; idx < parts.length - 1; idx++) {
          part = parts[idx];
          if (curobj.hasOwnProperty(part)) {
            curobj = curobj[part];
          } else {
            curobj = curobj[part] = {};
          }
        }
        if (typeof object !== "undefined") {
          part = parts[idx];
          curobj[part] = object;
        }
      };
      Sk2.isArrayLike = function(object) {
        if (object instanceof Array || object && object.length && typeof object.length == "number") {
          return true;
        }
        return false;
      };
      Sk2.js_beautify = function(x) {
        return x;
      };
      Sk2.exportSymbol("Sk", Sk2);
      Sk2.exportSymbol("Sk.global", Sk2.global);
      Sk2.exportSymbol("Sk.build", Sk2.build);
      Sk2.exportSymbol("Sk.exportSymbol", Sk2.exportSymbol);
      Sk2.exportSymbol("Sk.isArrayLike", Sk2.isArrayLike);
      Sk2.exportSymbol("Sk.js_beautify", Sk2.js_beautify);
    }
  });

  // node_modules/strftime/strftime.js
  var require_strftime = __commonJS({
    "node_modules/strftime/strftime.js"(exports, module) {
      (function() {
        var Locales = {
          de_DE: {
            days: ["Sonntag", "Montag", "Dienstag", "Mittwoch", "Donnerstag", "Freitag", "Samstag"],
            shortDays: ["So", "Mo", "Di", "Mi", "Do", "Fr", "Sa"],
            months: ["Januar", "Februar", "M\xE4rz", "April", "Mai", "Juni", "Juli", "August", "September", "Oktober", "November", "Dezember"],
            shortMonths: ["Jan", "Feb", "M\xE4r", "Apr", "Mai", "Jun", "Jul", "Aug", "Sep", "Okt", "Nov", "Dez"],
            AM: "AM",
            PM: "PM",
            am: "am",
            pm: "pm",
            formats: {
              c: "%a %d %b %Y %X %Z",
              D: "%d.%m.%Y",
              F: "%Y-%m-%d",
              R: "%H:%M",
              r: "%I:%M:%S %p",
              T: "%H:%M:%S",
              v: "%e-%b-%Y",
              X: "%T",
              x: "%D"
            }
          },
          en_CA: {
            days: ["Sunday", "Monday", "Tuesday", "Wednesday", "Thursday", "Friday", "Saturday"],
            shortDays: ["Sun", "Mon", "Tue", "Wed", "Thu", "Fri", "Sat"],
            months: ["January", "February", "March", "April", "May", "June", "July", "August", "September", "October", "November", "December"],
            shortMonths: ["Jan", "Feb", "Mar", "Apr", "May", "Jun", "Jul", "Aug", "Sep", "Oct", "Nov", "Dec"],
            ordinalSuffixes: [
              "st",
              "nd",
              "rd",
              "th",
              "th",
              "th",
              "th",
              "th",
              "th",
              "th",
              "th",
              "th",
              "th",
              "th",
              "th",
              "th",
              "th",
              "th",
              "th",
              "th",
              "st",
              "nd",
              "rd",
              "th",
              "th",
              "th",
              "th",
              "th",
              "th",
              "th",
              "st"
            ],
            AM: "AM",
            PM: "PM",
            am: "am",
            pm: "pm",
            formats: {
              c: "%a %d %b %Y %X %Z",
              D: "%d/%m/%y",
              F: "%Y-%m-%d",
              R: "%H:%M",
              r: "%I:%M:%S %p",
              T: "%H:%M:%S",
              v: "%e-%b-%Y",
              X: "%r",
              x: "%D"
            }
          },
          en_US: {
            days: ["Sunday", "Monday", "Tuesday", "Wednesday", "Thursday", "Friday", "Saturday"],
            shortDays: ["Sun", "Mon", "Tue", "Wed", "Thu", "Fri", "Sat"],
            months: ["January", "February", "March", "April", "May", "June", "July", "August", "September", "October", "November", "December"],
            shortMonths: ["Jan", "Feb", "Mar", "Apr", "May", "Jun", "Jul", "Aug", "Sep", "Oct", "Nov", "Dec"],
            ordinalSuffixes: [
              "st",
              "nd",
              "rd",
              "th",
              "th",
              "th",
              "th",
              "th",
              "th",
              "th",
              "th",
              "th",
              "th",
              "th",
              "th",
              "th",
              "th",
              "th",
              "th",
              "th",
              "st",
              "nd",
              "rd",
              "th",
              "th",
              "th",
              "th",
              "th",
              "th",
              "th",
              "st"
            ],
            AM: "AM",
            PM: "PM",
            am: "am",
            pm: "pm",
            formats: {
              c: "%a %d %b %Y %X %Z",
              D: "%m/%d/%y",
              F: "%Y-%m-%d",
              R: "%H:%M",
              r: "%I:%M:%S %p",
              T: "%H:%M:%S",
              v: "%e-%b-%Y",
              X: "%r",
              x: "%D"
            }
          },
          es_MX: {
            days: ["domingo", "lunes", "martes", "mi\xE9rcoles", "jueves", "viernes", "s\xE1bado"],
            shortDays: ["dom", "lun", "mar", "mi\xE9", "jue", "vie", "s\xE1b"],
            months: ["enero", "febrero", "marzo", "abril", "mayo", "junio", "julio", "agosto", "septiembre", "octubre", "noviembre", " diciembre"],
            shortMonths: ["ene", "feb", "mar", "abr", "may", "jun", "jul", "ago", "sep", "oct", "nov", "dic"],
            AM: "AM",
            PM: "PM",
            am: "am",
            pm: "pm",
            formats: {
              c: "%a %d %b %Y %X %Z",
              D: "%d/%m/%Y",
              F: "%Y-%m-%d",
              R: "%H:%M",
              r: "%I:%M:%S %p",
              T: "%H:%M:%S",
              v: "%e-%b-%Y",
              X: "%T",
              x: "%D"
            }
          },
          fr_FR: {
            days: ["dimanche", "lundi", "mardi", "mercredi", "jeudi", "vendredi", "samedi"],
            shortDays: ["dim.", "lun.", "mar.", "mer.", "jeu.", "ven.", "sam."],
            months: ["janvier", "f\xE9vrier", "mars", "avril", "mai", "juin", "juillet", "ao\xFBt", "septembre", "octobre", "novembre", "d\xE9cembre"],
            shortMonths: ["janv.", "f\xE9vr.", "mars", "avril", "mai", "juin", "juil.", "ao\xFBt", "sept.", "oct.", "nov.", "d\xE9c."],
            AM: "AM",
            PM: "PM",
            am: "am",
            pm: "pm",
            formats: {
              c: "%a %d %b %Y %X %Z",
              D: "%d/%m/%Y",
              F: "%Y-%m-%d",
              R: "%H:%M",
              r: "%I:%M:%S %p",
              T: "%H:%M:%S",
              v: "%e-%b-%Y",
              X: "%T",
              x: "%D"
            }
          },
          it_IT: {
            days: ["domenica", "luned\xEC", "marted\xEC", "mercoled\xEC", "gioved\xEC", "venerd\xEC", "sabato"],
            shortDays: ["dom", "lun", "mar", "mer", "gio", "ven", "sab"],
            months: ["gennaio", "febbraio", "marzo", "aprile", "maggio", "giugno", "luglio", "agosto", "settembre", "ottobre", "novembre", "dicembre"],
            shortMonths: ["pr", "mag", "giu", "lug", "ago", "set", "ott", "nov", "dic"],
            AM: "AM",
            PM: "PM",
            am: "am",
            pm: "pm",
            formats: {
              c: "%a %d %b %Y %X %Z",
              D: "%d/%m/%Y",
              F: "%Y-%m-%d",
              R: "%H:%M",
              r: "%I:%M:%S %p",
              T: "%H:%M:%S",
              v: "%e-%b-%Y",
              X: "%T",
              x: "%D"
            }
          },
          nl_NL: {
            days: ["zondag", "maandag", "dinsdag", "woensdag", "donderdag", "vrijdag", "zaterdag"],
            shortDays: ["zo", "ma", "di", "wo", "do", "vr", "za"],
            months: ["januari", "februari", "maart", "april", "mei", "juni", "juli", "augustus", "september", "oktober", "november", "december"],
            shortMonths: ["jan", "feb", "mrt", "apr", "mei", "jun", "jul", "aug", "sep", "okt", "nov", "dec"],
            AM: "AM",
            PM: "PM",
            am: "am",
            pm: "pm",
            formats: {
              c: "%a %d %b %Y %X %Z",
              D: "%d-%m-%y",
              F: "%Y-%m-%d",
              R: "%H:%M",
              r: "%I:%M:%S %p",
              T: "%H:%M:%S",
              v: "%e-%b-%Y",
              X: "%T",
              x: "%D"
            }
          },
          pt_BR: {
            days: ["domingo", "segunda", "ter\xE7a", "quarta", "quinta", "sexta", "s\xE1bado"],
            shortDays: ["Dom", "Seg", "Ter", "Qua", "Qui", "Sex", "S\xE1b"],
            months: ["janeiro", "fevereiro", "mar\xE7o", "abril", "maio", "junho", "julho", "agosto", "setembro", "outubro", "novembro", "dezembro"],
            shortMonths: ["Jan", "Fev", "Mar", "Abr", "Mai", "Jun", "Jul", "Ago", "Set", "Out", "Nov", "Dez"],
            AM: "AM",
            PM: "PM",
            am: "am",
            pm: "pm",
            formats: {
              c: "%a %d %b %Y %X %Z",
              D: "%d-%m-%Y",
              F: "%Y-%m-%d",
              R: "%H:%M",
              r: "%I:%M:%S %p",
              T: "%H:%M:%S",
              v: "%e-%b-%Y",
              X: "%T",
              x: "%D"
            }
          },
          ru_RU: {
            days: ["\u0412\u043E\u0441\u043A\u0440\u0435\u0441\u0435\u043D\u044C\u0435", "\u041F\u043E\u043D\u0435\u0434\u0435\u043B\u044C\u043D\u0438\u043A", "\u0412\u0442\u043E\u0440\u043D\u0438\u043A", "\u0421\u0440\u0435\u0434\u0430", "\u0427\u0435\u0442\u0432\u0435\u0440\u0433", "\u041F\u044F\u0442\u043D\u0438\u0446\u0430", "\u0421\u0443\u0431\u0431\u043E\u0442\u0430"],
            shortDays: ["\u0412\u0441", "\u041F\u043D", "\u0412\u0442", "\u0421\u0440", "\u0427\u0442", "\u041F\u0442", "\u0421\u0431"],
            months: ["\u042F\u043D\u0432\u0430\u0440\u044C", "\u0424\u0435\u0432\u0440\u0430\u043B\u044C", "\u041C\u0430\u0440\u0442", "\u0410\u043F\u0440\u0435\u043B\u044C", "\u041C\u0430\u0439", "\u0418\u044E\u043D\u044C", "\u0418\u044E\u043B\u044C", "\u0410\u0432\u0433\u0443\u0441\u0442", "\u0421\u0435\u043D\u0442\u044F\u0431\u0440\u044C", "\u041E\u043A\u0442\u044F\u0431\u0440\u044C", "\u041D\u043E\u044F\u0431\u0440\u044C", "\u0414\u0435\u043A\u0430\u0431\u0440\u044C"],
            shortMonths: ["\u044F\u043D\u0432", "\u0444\u0435\u0432", "\u043C\u0430\u0440", "\u0430\u043F\u0440", "\u043C\u0430\u0439", "\u0438\u044E\u043D", "\u0438\u044E\u043B", "\u0430\u0432\u0433", "\u0441\u0435\u043D", "\u043E\u043A\u0442", "\u043D\u043E\u044F", "\u0434\u0435\u043A"],
            AM: "AM",
            PM: "PM",
            am: "am",
            pm: "pm",
            formats: {
              c: "%a %d %b %Y %X",
              D: "%d.%m.%y",
              F: "%Y-%m-%d",
              R: "%H:%M",
              r: "%I:%M:%S %p",
              T: "%H:%M:%S",
              v: "%e-%b-%Y",
              X: "%T",
              x: "%D"
            }
          },
          tr_TR: {
            days: ["Pazar", "Pazartesi", "Sal\u0131", "\xC7ar\u015Famba", "Per\u015Fembe", "Cuma", "Cumartesi"],
            shortDays: ["Paz", "Pzt", "Sal", "\xC7r\u015F", "Pr\u015F", "Cum", "Cts"],
            months: ["Ocak", "\u015Eubat", "Mart", "Nisan", "May\u0131s", "Haziran", "Temmuz", "A\u011Fustos", "Eyl\xFCl", "Ekim", "Kas\u0131m", "Aral\u0131k"],
            shortMonths: ["Oca", "\u015Eub", "Mar", "Nis", "May", "Haz", "Tem", "A\u011Fu", "Eyl", "Eki", "Kas", "Ara"],
            AM: "\xD6\xD6",
            PM: "\xD6S",
            am: "\xD6\xD6",
            pm: "\xD6S",
            formats: {
              c: "%a %d %b %Y %X %Z",
              D: "%d-%m-%Y",
              F: "%Y-%m-%d",
              R: "%H:%M",
              r: "%I:%M:%S %p",
              T: "%H:%M:%S",
              v: "%e-%b-%Y",
              X: "%T",
              x: "%D"
            }
          },
          // By michaeljayt<michaeljayt@gmail.com>
          // https://github.com/michaeljayt/strftime/commit/bcb4c12743811d51e568175aa7bff3fd2a77cef3
          zh_CN: {
            days: ["\u661F\u671F\u65E5", "\u661F\u671F\u4E00", "\u661F\u671F\u4E8C", "\u661F\u671F\u4E09", "\u661F\u671F\u56DB", "\u661F\u671F\u4E94", "\u661F\u671F\u516D"],
            shortDays: ["\u65E5", "\u4E00", "\u4E8C", "\u4E09", "\u56DB", "\u4E94", "\u516D"],
            months: ["\u4E00\u6708\u4EFD", "\u4E8C\u6708\u4EFD", "\u4E09\u6708\u4EFD", "\u56DB\u6708\u4EFD", "\u4E94\u6708\u4EFD", "\u516D\u6708\u4EFD", "\u4E03\u6708\u4EFD", "\u516B\u6708\u4EFD", "\u4E5D\u6708\u4EFD", "\u5341\u6708\u4EFD", "\u5341\u4E00\u6708\u4EFD", "\u5341\u4E8C\u6708\u4EFD"],
            shortMonths: ["\u4E00\u6708", "\u4E8C\u6708", "\u4E09\u6708", "\u56DB\u6708", "\u4E94\u6708", "\u516D\u6708", "\u4E03\u6708", "\u516B\u6708", "\u4E5D\u6708", "\u5341\u6708", "\u5341\u4E00\u6708", "\u5341\u4E8C\u6708"],
            AM: "\u4E0A\u5348",
            PM: "\u4E0B\u5348",
            am: "\u4E0A\u5348",
            pm: "\u4E0B\u5348",
            formats: {
              c: "%a %d %b %Y %X %Z",
              D: "%d/%m/%y",
              F: "%Y-%m-%d",
              R: "%H:%M",
              r: "%I:%M:%S %p",
              T: "%H:%M:%S",
              v: "%e-%b-%Y",
              X: "%r",
              x: "%D"
            }
          }
        };
        var DefaultLocale = Locales["en_US"], defaultStrftime = new Strftime(DefaultLocale, 0, false), isCommonJS = typeof module !== "undefined", namespace;
        if (isCommonJS) {
          namespace = module.exports = defaultStrftime;
        } else {
          namespace = (function() {
            return this || (1, eval)("this");
          })();
          namespace.strftime = defaultStrftime;
        }
        if (typeof Date.now !== "function") {
          Date.now = function() {
            return +/* @__PURE__ */ new Date();
          };
        }
        function Strftime(locale, customTimezoneOffset, useUtcTimezone) {
          var _locale = locale || DefaultLocale, _customTimezoneOffset = customTimezoneOffset || 0, _useUtcBasedDate = useUtcTimezone || false, _cachedDateTimestamp = 0, _cachedDate;
          function _strftime(format, date) {
            var timestamp;
            if (!date) {
              var currentTimestamp = Date.now();
              if (currentTimestamp > _cachedDateTimestamp) {
                _cachedDateTimestamp = currentTimestamp;
                _cachedDate = new Date(_cachedDateTimestamp);
                timestamp = _cachedDateTimestamp;
                if (_useUtcBasedDate) {
                  _cachedDate = new Date(_cachedDateTimestamp + getTimestampToUtcOffsetFor(_cachedDate) + _customTimezoneOffset);
                }
              } else {
                timestamp = _cachedDateTimestamp;
              }
              date = _cachedDate;
            } else {
              timestamp = date.getTime();
              if (_useUtcBasedDate) {
                var utcOffset = getTimestampToUtcOffsetFor(date);
                date = new Date(timestamp + utcOffset + _customTimezoneOffset);
                if (getTimestampToUtcOffsetFor(date) !== utcOffset) {
                  var newUTCOffset = getTimestampToUtcOffsetFor(date);
                  date = new Date(timestamp + newUTCOffset + _customTimezoneOffset);
                }
              }
            }
            return _processFormat(format, date, _locale, timestamp);
          }
          function _processFormat(format, date, locale2, timestamp) {
            var resultString = "", padding = null, isInScope = false, length = format.length, extendedTZ = false;
            for (var i = 0; i < length; i++) {
              var currentCharCode = format.charCodeAt(i);
              if (isInScope === true) {
                if (currentCharCode === 45) {
                  padding = "";
                  continue;
                } else if (currentCharCode === 95) {
                  padding = " ";
                  continue;
                } else if (currentCharCode === 48) {
                  padding = "0";
                  continue;
                } else if (currentCharCode === 58) {
                  if (extendedTZ) {
                    warn("[WARNING] detected use of unsupported %:: or %::: modifiers to strftime");
                  }
                  extendedTZ = true;
                  continue;
                }
                switch (currentCharCode) {
                  // Examples for new Date(0) in GMT
                  // '%'
                  // case '%':
                  case 37:
                    resultString += "%";
                    break;
                  // 'Thursday'
                  // case 'A':
                  case 65:
                    resultString += locale2.days[date.getDay()];
                    break;
                  // 'January'
                  // case 'B':
                  case 66:
                    resultString += locale2.months[date.getMonth()];
                    break;
                  // '19'
                  // case 'C':
                  case 67:
                    resultString += padTill2(Math.floor(date.getFullYear() / 100), padding);
                    break;
                  // '01/01/70'
                  // case 'D':
                  case 68:
                    resultString += _processFormat(locale2.formats.D, date, locale2, timestamp);
                    break;
                  // '1970-01-01'
                  // case 'F':
                  case 70:
                    resultString += _processFormat(locale2.formats.F, date, locale2, timestamp);
                    break;
                  // '00'
                  // case 'H':
                  case 72:
                    resultString += padTill2(date.getHours(), padding);
                    break;
                  // '12'
                  // case 'I':
                  case 73:
                    resultString += padTill2(hours12(date.getHours()), padding);
                    break;
                  // '000'
                  // case 'L':
                  case 76:
                    resultString += padTill3(Math.floor(timestamp % 1e3));
                    break;
                  // '00'
                  // case 'M':
                  case 77:
                    resultString += padTill2(date.getMinutes(), padding);
                    break;
                  // 'am'
                  // case 'P':
                  case 80:
                    resultString += date.getHours() < 12 ? locale2.am : locale2.pm;
                    break;
                  // '00:00'
                  // case 'R':
                  case 82:
                    resultString += _processFormat(locale2.formats.R, date, locale2, timestamp);
                    break;
                  // '00'
                  // case 'S':
                  case 83:
                    resultString += padTill2(date.getSeconds(), padding);
                    break;
                  // '00:00:00'
                  // case 'T':
                  case 84:
                    resultString += _processFormat(locale2.formats.T, date, locale2, timestamp);
                    break;
                  // '00'
                  // case 'U':
                  case 85:
                    resultString += padTill2(weekNumber(date, "sunday"), padding);
                    break;
                  // '00'
                  // case 'W':
                  case 87:
                    resultString += padTill2(weekNumber(date, "monday"), padding);
                    break;
                  // '16:00:00'
                  // case 'X':
                  case 88:
                    resultString += _processFormat(locale2.formats.X, date, locale2, timestamp);
                    break;
                  // '1970'
                  // case 'Y':
                  case 89:
                    resultString += date.getFullYear();
                    break;
                  // 'GMT'
                  // case 'Z':
                  case 90:
                    if (_useUtcBasedDate && _customTimezoneOffset === 0) {
                      resultString += "GMT";
                    } else {
                      var tzString = date.toString().match(/\(([\w\s]+)\)/);
                      resultString += tzString && tzString[1] || "";
                    }
                    break;
                  // 'Thu'
                  // case 'a':
                  case 97:
                    resultString += locale2.shortDays[date.getDay()];
                    break;
                  // 'Jan'
                  // case 'b':
                  case 98:
                    resultString += locale2.shortMonths[date.getMonth()];
                    break;
                  // ''
                  // case 'c':
                  case 99:
                    resultString += _processFormat(locale2.formats.c, date, locale2, timestamp);
                    break;
                  // '01'
                  // case 'd':
                  case 100:
                    resultString += padTill2(date.getDate(), padding);
                    break;
                  // ' 1'
                  // case 'e':
                  case 101:
                    resultString += padTill2(date.getDate(), padding == null ? " " : padding);
                    break;
                  // 'Jan'
                  // case 'h':
                  case 104:
                    resultString += locale2.shortMonths[date.getMonth()];
                    break;
                  // '000'
                  // case 'j':
                  case 106:
                    var y = new Date(date.getFullYear(), 0, 1);
                    var day = Math.ceil((date.getTime() - y.getTime()) / (1e3 * 60 * 60 * 24));
                    resultString += padTill3(day);
                    break;
                  // ' 0'
                  // case 'k':
                  case 107:
                    resultString += padTill2(date.getHours(), padding == null ? " " : padding);
                    break;
                  // '12'
                  // case 'l':
                  case 108:
                    resultString += padTill2(hours12(date.getHours()), padding == null ? " " : padding);
                    break;
                  // '01'
                  // case 'm':
                  case 109:
                    resultString += padTill2(date.getMonth() + 1, padding);
                    break;
                  // '\n'
                  // case 'n':
                  case 110:
                    resultString += "\n";
                    break;
                  // '1st'
                  // case 'o':
                  case 111:
                    var day = date.getDate();
                    if (locale2.ordinalSuffixes) {
                      resultString += String(day) + (locale2.ordinalSuffixes[day - 1] || ordinal(day));
                    } else {
                      resultString += String(day) + ordinal(day);
                    }
                    break;
                  // 'AM'
                  // case 'p':
                  case 112:
                    resultString += date.getHours() < 12 ? locale2.AM : locale2.PM;
                    break;
                  // '12:00:00 AM'
                  // case 'r':
                  case 114:
                    resultString += _processFormat(locale2.formats.r, date, locale2, timestamp);
                    break;
                  // '0'
                  // case 's':
                  case 115:
                    resultString += Math.floor(timestamp / 1e3);
                    break;
                  // '\t'
                  // case 't':
                  case 116:
                    resultString += "	";
                    break;
                  // '4'
                  // case 'u':
                  case 117:
                    var day = date.getDay();
                    resultString += day === 0 ? 7 : day;
                    break;
                  // 1 - 7, Monday is first day of the week
                  // ' 1-Jan-1970'
                  // case 'v':
                  case 118:
                    resultString += _processFormat(locale2.formats.v, date, locale2, timestamp);
                    break;
                  // '4'
                  // case 'w':
                  case 119:
                    resultString += date.getDay();
                    break;
                  // 0 - 6, Sunday is first day of the week
                  // '12/31/69'
                  // case 'x':
                  case 120:
                    resultString += _processFormat(locale2.formats.x, date, locale2, timestamp);
                    break;
                  // '70'
                  // case 'y':
                  case 121:
                    resultString += ("" + date.getFullYear()).slice(2);
                    break;
                  // '+0000'
                  // case 'z':
                  case 122:
                    if (_useUtcBasedDate && _customTimezoneOffset === 0) {
                      resultString += extendedTZ ? "+00:00" : "+0000";
                    } else {
                      var off;
                      if (_customTimezoneOffset !== 0) {
                        off = _customTimezoneOffset / (60 * 1e3);
                      } else {
                        off = -date.getTimezoneOffset();
                      }
                      var sign = off < 0 ? "-" : "+";
                      var sep = extendedTZ ? ":" : "";
                      var hours = Math.floor(Math.abs(off / 60));
                      var mins = Math.abs(off % 60);
                      resultString += sign + padTill2(hours) + sep + padTill2(mins);
                    }
                    break;
                  default:
                    if (isInScope) {
                      resultString += "%";
                    }
                    resultString += format[i];
                    break;
                }
                padding = null;
                isInScope = false;
                continue;
              }
              if (currentCharCode === 37) {
                isInScope = true;
                continue;
              }
              resultString += format[i];
            }
            return resultString;
          }
          var strftime = _strftime;
          strftime.localize = function(locale2) {
            return new Strftime(locale2 || _locale, _customTimezoneOffset, _useUtcBasedDate);
          };
          strftime.localizeByIdentifier = function(localeIdentifier) {
            var locale2 = Locales[localeIdentifier];
            if (!locale2) {
              warn('[WARNING] No locale found with identifier "' + localeIdentifier + '".');
              return strftime;
            }
            return strftime.localize(locale2);
          };
          strftime.timezone = function(timezone) {
            var customTimezoneOffset2 = _customTimezoneOffset;
            var useUtcBasedDate = _useUtcBasedDate;
            var timezoneType = typeof timezone;
            if (timezoneType === "number" || timezoneType === "string") {
              useUtcBasedDate = true;
              if (timezoneType === "string") {
                var sign = timezone[0] === "-" ? -1 : 1, hours = parseInt(timezone.slice(1, 3), 10), minutes = parseInt(timezone.slice(3, 5), 10);
                customTimezoneOffset2 = sign * (60 * hours + minutes) * 60 * 1e3;
              } else if (timezoneType === "number") {
                customTimezoneOffset2 = timezone * 60 * 1e3;
              }
            }
            return new Strftime(_locale, customTimezoneOffset2, useUtcBasedDate);
          };
          strftime.utc = function() {
            return new Strftime(_locale, _customTimezoneOffset, true);
          };
          return strftime;
        }
        function padTill2(numberToPad, paddingChar) {
          if (paddingChar === "" || numberToPad > 9) {
            return numberToPad;
          }
          if (paddingChar == null) {
            paddingChar = "0";
          }
          return paddingChar + numberToPad;
        }
        function padTill3(numberToPad) {
          if (numberToPad > 99) {
            return numberToPad;
          }
          if (numberToPad > 9) {
            return "0" + numberToPad;
          }
          return "00" + numberToPad;
        }
        function hours12(hour) {
          if (hour === 0) {
            return 12;
          } else if (hour > 12) {
            return hour - 12;
          }
          return hour;
        }
        function weekNumber(date, firstWeekday) {
          firstWeekday = firstWeekday || "sunday";
          var weekday = date.getDay();
          if (firstWeekday === "monday") {
            if (weekday === 0)
              weekday = 6;
            else
              weekday--;
          }
          var firstDayOfYearUtc = Date.UTC(date.getFullYear(), 0, 1), dateUtc = Date.UTC(date.getFullYear(), date.getMonth(), date.getDate()), yday = Math.floor((dateUtc - firstDayOfYearUtc) / 864e5), weekNum = (yday + 7 - weekday) / 7;
          return Math.floor(weekNum);
        }
        function ordinal(number) {
          var i = number % 10;
          var ii = number % 100;
          if (ii >= 11 && ii <= 13 || i === 0 || i >= 4) {
            return "th";
          }
          switch (i) {
            case 1:
              return "st";
            case 2:
              return "nd";
            case 3:
              return "rd";
          }
        }
        function getTimestampToUtcOffsetFor(date) {
          return (date.getTimezoneOffset() || 0) * 6e4;
        }
        function warn(message) {
          if (typeof console !== "undefined" && typeof console.warn == "function") {
            console.warn(message);
          }
        }
      })();
    }
  });

  // node_modules/jsbi/dist/jsbi-umd.js
  var require_jsbi_umd = __commonJS({
    "node_modules/jsbi/dist/jsbi-umd.js"(exports, module) {
      (function(e, t) {
        "object" == typeof exports && "undefined" != typeof module ? module.exports = t() : "function" == typeof define && define.amd ? define(t) : (e = e || self, e.JSBI = t());
      })(exports, function() {
        "use strict";
        function e(t2) {
          "@babel/helpers - typeof";
          return e = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(e2) {
            return typeof e2;
          } : function(e2) {
            return e2 && "function" == typeof Symbol && e2.constructor === Symbol && e2 !== Symbol.prototype ? "symbol" : typeof e2;
          }, e(t2);
        }
        function t(e2, t2) {
          if (!(e2 instanceof t2)) throw new TypeError("Cannot call a class as a function");
        }
        function i(e2, t2) {
          for (var _2, n2 = 0; n2 < t2.length; n2++) _2 = t2[n2], _2.enumerable = _2.enumerable || false, _2.configurable = true, "value" in _2 && (_2.writable = true), Object.defineProperty(e2, _2.key, _2);
        }
        function _(e2, t2, _2) {
          return t2 && i(e2.prototype, t2), _2 && i(e2, _2), e2;
        }
        function n(e2, t2) {
          if ("function" != typeof t2 && null !== t2) throw new TypeError("Super expression must either be null or a function");
          e2.prototype = Object.create(t2 && t2.prototype, { constructor: { value: e2, writable: true, configurable: true } }), t2 && l(e2, t2);
        }
        function g(e2) {
          return g = Object.setPrototypeOf ? Object.getPrototypeOf : function(e3) {
            return e3.__proto__ || Object.getPrototypeOf(e3);
          }, g(e2);
        }
        function l(e2, t2) {
          return l = Object.setPrototypeOf || function(e3, t3) {
            return e3.__proto__ = t3, e3;
          }, l(e2, t2);
        }
        function a() {
          if ("undefined" == typeof Reflect || !Reflect.construct) return false;
          if (Reflect.construct.sham) return false;
          if ("function" == typeof Proxy) return true;
          try {
            return Date.prototype.toString.call(Reflect.construct(Date, [], function() {
            })), true;
          } catch (t2) {
            return false;
          }
        }
        function s() {
          return s = a() ? Reflect.construct : function(e2, t2, i2) {
            var _2 = [null];
            _2.push.apply(_2, t2);
            var n2 = Function.bind.apply(e2, _2), g2 = new n2();
            return i2 && l(g2, i2.prototype), g2;
          }, s.apply(null, arguments);
        }
        function u(e2) {
          return -1 !== Function.toString.call(e2).indexOf("[native code]");
        }
        function r(e2) {
          var t2 = "function" == typeof Map ? /* @__PURE__ */ new Map() : void 0;
          return r = function(e3) {
            function i2() {
              return s(e3, arguments, g(this).constructor);
            }
            if (null === e3 || !u(e3)) return e3;
            if ("function" != typeof e3) throw new TypeError("Super expression must either be null or a function");
            if ("undefined" != typeof t2) {
              if (t2.has(e3)) return t2.get(e3);
              t2.set(e3, i2);
            }
            return i2.prototype = Object.create(e3.prototype, { constructor: { value: i2, enumerable: false, writable: true, configurable: true } }), l(i2, e3);
          }, r(e2);
        }
        function d(e2) {
          if (void 0 === e2) throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
          return e2;
        }
        function h(e2, t2) {
          return t2 && ("object" == typeof t2 || "function" == typeof t2) ? t2 : d(e2);
        }
        function b(e2) {
          var t2 = a();
          return function() {
            var i2, _2 = g(e2);
            if (t2) {
              var n2 = g(this).constructor;
              i2 = Reflect.construct(_2, arguments, n2);
            } else i2 = _2.apply(this, arguments);
            return h(this, i2);
          };
        }
        function m(e2, t2) {
          if (e2) {
            if ("string" == typeof e2) return c(e2, t2);
            var i2 = Object.prototype.toString.call(e2).slice(8, -1);
            return "Object" === i2 && e2.constructor && (i2 = e2.constructor.name), "Map" === i2 || "Set" === i2 ? Array.from(e2) : "Arguments" === i2 || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(i2) ? c(e2, t2) : void 0;
          }
        }
        function c(e2, t2) {
          (null == t2 || t2 > e2.length) && (t2 = e2.length);
          for (var _2 = 0, n2 = Array(t2); _2 < t2; _2++) n2[_2] = e2[_2];
          return n2;
        }
        function v(e2, t2) {
          var _2;
          if ("undefined" == typeof Symbol || null == e2[Symbol.iterator]) {
            if (Array.isArray(e2) || (_2 = m(e2)) || t2 && e2 && "number" == typeof e2.length) {
              _2 && (e2 = _2);
              var n2 = 0, g2 = function() {
              };
              return { s: g2, n: function() {
                return n2 >= e2.length ? { done: true } : { done: false, value: e2[n2++] };
              }, e: function(t3) {
                throw t3;
              }, f: g2 };
            }
            throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
          }
          var l2, a2 = true, s2 = false;
          return { s: function() {
            _2 = e2[Symbol.iterator]();
          }, n: function() {
            var e3 = _2.next();
            return a2 = e3.done, e3;
          }, e: function(t3) {
            s2 = true, l2 = t3;
          }, f: function() {
            try {
              a2 || null == _2.return || _2.return();
            } finally {
              if (s2) throw l2;
            }
          } };
        }
        var f = (function(i2) {
          var o = Math.abs, l2 = Math.max, a2 = Math.imul, s2 = Math.clz32;
          function g2(e2, i3) {
            var _2;
            if (t(this, g2), e2 > g2.__kMaxLength) throw new RangeError("Maximum BigInt size exceeded");
            return _2 = u2.call(this, e2), _2.sign = i3, _2;
          }
          n(g2, i2);
          var u2 = b(g2);
          return _(g2, [{ key: "toDebugString", value: function() {
            var e2, t2 = ["BigInt["], i3 = v(this);
            try {
              for (i3.s(); !(e2 = i3.n()).done; ) {
                var _2 = e2.value;
                t2.push((_2 ? (_2 >>> 0).toString(16) : _2) + ", ");
              }
            } catch (e3) {
              i3.e(e3);
            } finally {
              i3.f();
            }
            return t2.push("]"), t2.join("");
          } }, { key: "toString", value: function() {
            var e2 = 0 < arguments.length && void 0 !== arguments[0] ? arguments[0] : 10;
            if (2 > e2 || 36 < e2) throw new RangeError("toString() radix argument must be between 2 and 36");
            return 0 === this.length ? "0" : 0 == (e2 & e2 - 1) ? g2.__toStringBasePowerOfTwo(this, e2) : g2.__toStringGeneric(this, e2, false);
          } }, { key: "__copy", value: function() {
            for (var e2 = new g2(this.length, this.sign), t2 = 0; t2 < this.length; t2++) e2[t2] = this[t2];
            return e2;
          } }, { key: "__trim", value: function() {
            for (var e2 = this.length, t2 = this[e2 - 1]; 0 === t2; ) e2--, t2 = this[e2 - 1], this.pop();
            return 0 === e2 && (this.sign = false), this;
          } }, { key: "__initializeDigits", value: function() {
            for (var e2 = 0; e2 < this.length; e2++) this[e2] = 0;
          } }, { key: "__clzmsd", value: function() {
            return s2(this[this.length - 1]);
          } }, { key: "__inplaceMultiplyAdd", value: function(e2, t2, _2) {
            _2 > this.length && (_2 = this.length);
            for (var n2 = 65535 & e2, g3 = e2 >>> 16, o2 = 0, l3 = 65535 & t2, s3 = t2 >>> 16, u3 = 0; u3 < _2; u3++) {
              var r2 = this.__digit(u3), d2 = 65535 & r2, h2 = r2 >>> 16, b2 = a2(d2, n2), m2 = a2(d2, g3), c2 = a2(h2, n2), v2 = a2(h2, g3), f2 = l3 + (65535 & b2), y = s3 + o2 + (f2 >>> 16) + (b2 >>> 16) + (65535 & m2) + (65535 & c2);
              l3 = (m2 >>> 16) + (c2 >>> 16) + (65535 & v2) + (y >>> 16), o2 = l3 >>> 16, l3 &= 65535, s3 = v2 >>> 16;
              this.__setDigit(u3, 65535 & f2 | y << 16);
            }
            if (0 !== o2 || 0 !== l3 || 0 !== s3) throw new Error("implementation bug");
          } }, { key: "__inplaceAdd", value: function(e2, t2, _2) {
            for (var n2, g3 = 0, o2 = 0; o2 < _2; o2++) n2 = this.__halfDigit(t2 + o2) + e2.__halfDigit(o2) + g3, g3 = n2 >>> 16, this.__setHalfDigit(t2 + o2, n2);
            return g3;
          } }, { key: "__inplaceSub", value: function(e2, t2, _2) {
            var n2 = 0;
            if (1 & t2) {
              t2 >>= 1;
              for (var g3 = this.__digit(t2), o2 = 65535 & g3, l3 = 0; l3 < _2 - 1 >>> 1; l3++) {
                var a3 = e2.__digit(l3), s3 = (g3 >>> 16) - (65535 & a3) - n2;
                n2 = 1 & s3 >>> 16, this.__setDigit(t2 + l3, s3 << 16 | 65535 & o2), g3 = this.__digit(t2 + l3 + 1), o2 = (65535 & g3) - (a3 >>> 16) - n2, n2 = 1 & o2 >>> 16;
              }
              var u3 = e2.__digit(l3), r2 = (g3 >>> 16) - (65535 & u3) - n2;
              n2 = 1 & r2 >>> 16, this.__setDigit(t2 + l3, r2 << 16 | 65535 & o2);
              if (t2 + l3 + 1 >= this.length) throw new RangeError("out of bounds");
              0 == (1 & _2) && (g3 = this.__digit(t2 + l3 + 1), o2 = (65535 & g3) - (u3 >>> 16) - n2, n2 = 1 & o2 >>> 16, this.__setDigit(t2 + e2.length, 4294901760 & g3 | 65535 & o2));
            } else {
              t2 >>= 1;
              for (var d2 = 0; d2 < e2.length - 1; d2++) {
                var h2 = this.__digit(t2 + d2), b2 = e2.__digit(d2), m2 = (65535 & h2) - (65535 & b2) - n2;
                n2 = 1 & m2 >>> 16;
                var c2 = (h2 >>> 16) - (b2 >>> 16) - n2;
                n2 = 1 & c2 >>> 16, this.__setDigit(t2 + d2, c2 << 16 | 65535 & m2);
              }
              var v2 = this.__digit(t2 + d2), f2 = e2.__digit(d2), y = (65535 & v2) - (65535 & f2) - n2;
              n2 = 1 & y >>> 16;
              var k = 0;
              0 == (1 & _2) && (k = (v2 >>> 16) - (f2 >>> 16) - n2, n2 = 1 & k >>> 16), this.__setDigit(t2 + d2, k << 16 | 65535 & y);
            }
            return n2;
          } }, { key: "__inplaceRightShift", value: function(e2) {
            if (0 !== e2) {
              for (var t2, _2 = this.__digit(0) >>> e2, n2 = this.length - 1, g3 = 0; g3 < n2; g3++) t2 = this.__digit(g3 + 1), this.__setDigit(g3, t2 << 32 - e2 | _2), _2 = t2 >>> e2;
              this.__setDigit(n2, _2);
            }
          } }, { key: "__digit", value: function(e2) {
            return this[e2];
          } }, { key: "__unsignedDigit", value: function(e2) {
            return this[e2] >>> 0;
          } }, { key: "__setDigit", value: function(e2, t2) {
            this[e2] = 0 | t2;
          } }, { key: "__setDigitGrow", value: function(e2, t2) {
            this[e2] = 0 | t2;
          } }, { key: "__halfDigitLength", value: function() {
            var e2 = this.length;
            return 65535 >= this.__unsignedDigit(e2 - 1) ? 2 * e2 - 1 : 2 * e2;
          } }, { key: "__halfDigit", value: function(e2) {
            return 65535 & this[e2 >>> 1] >>> ((1 & e2) << 4);
          } }, { key: "__setHalfDigit", value: function(e2, t2) {
            var i3 = e2 >>> 1, _2 = this.__digit(i3), n2 = 1 & e2 ? 65535 & _2 | t2 << 16 : 4294901760 & _2 | 65535 & t2;
            this.__setDigit(i3, n2);
          } }], [{ key: "BigInt", value: function(t2) {
            var i3 = Math.floor, _2 = Number.isFinite;
            if ("number" == typeof t2) {
              if (0 === t2) return g2.__zero();
              if ((0 | t2) === t2) return 0 > t2 ? g2.__oneDigit(-t2, true) : g2.__oneDigit(t2, false);
              if (!_2(t2) || i3(t2) !== t2) throw new RangeError("The number " + t2 + " cannot be converted to BigInt because it is not an integer");
              return g2.__fromDouble(t2);
            }
            if ("string" == typeof t2) {
              var n2 = g2.__fromString(t2);
              if (null === n2) throw new SyntaxError("Cannot convert " + t2 + " to a BigInt");
              return n2;
            }
            if ("boolean" == typeof t2) return true === t2 ? g2.__oneDigit(1, false) : g2.__zero();
            if ("object" === e(t2)) {
              if (t2.constructor === g2) return t2;
              var o2 = g2.__toPrimitive(t2);
              return g2.BigInt(o2);
            }
            throw new TypeError("Cannot convert " + t2 + " to a BigInt");
          } }, { key: "toNumber", value: function(e2) {
            var t2 = e2.length;
            if (0 === t2) return 0;
            if (1 === t2) {
              var i3 = e2.__unsignedDigit(0);
              return e2.sign ? -i3 : i3;
            }
            var _2 = e2.__digit(t2 - 1), n2 = s2(_2), o2 = 32 * t2 - n2;
            if (1024 < o2) return e2.sign ? -Infinity : 1 / 0;
            var l3 = o2 - 1, a3 = _2, u3 = t2 - 1, r2 = n2 + 1, d2 = 32 === r2 ? 0 : a3 << r2;
            d2 >>>= 12;
            var h2 = r2 - 12, b2 = 12 <= r2 ? 0 : a3 << 20 + r2, m2 = 20 + r2;
            0 < h2 && 0 < u3 && (u3--, a3 = e2.__digit(u3), d2 |= a3 >>> 32 - h2, b2 = a3 << h2, m2 = h2), 0 < m2 && 0 < u3 && (u3--, a3 = e2.__digit(u3), b2 |= a3 >>> 32 - m2, m2 -= 32);
            var c2 = g2.__decideRounding(e2, m2, u3, a3);
            if ((1 === c2 || 0 === c2 && 1 == (1 & b2)) && (b2 = b2 + 1 >>> 0, 0 === b2 && (d2++, 0 != d2 >>> 20 && (d2 = 0, l3++, 1023 < l3)))) return e2.sign ? -Infinity : 1 / 0;
            var v2 = e2.sign ? -2147483648 : 0;
            return l3 = l3 + 1023 << 20, g2.__kBitConversionInts[1] = v2 | l3 | d2, g2.__kBitConversionInts[0] = b2, g2.__kBitConversionDouble[0];
          } }, { key: "unaryMinus", value: function(e2) {
            if (0 === e2.length) return e2;
            var t2 = e2.__copy();
            return t2.sign = !e2.sign, t2;
          } }, { key: "bitwiseNot", value: function(e2) {
            return e2.sign ? g2.__absoluteSubOne(e2).__trim() : g2.__absoluteAddOne(e2, true);
          } }, { key: "exponentiate", value: function(e2, t2) {
            if (t2.sign) throw new RangeError("Exponent must be positive");
            if (0 === t2.length) return g2.__oneDigit(1, false);
            if (0 === e2.length) return e2;
            if (1 === e2.length && 1 === e2.__digit(0)) return e2.sign && 0 == (1 & t2.__digit(0)) ? g2.unaryMinus(e2) : e2;
            if (1 < t2.length) throw new RangeError("BigInt too big");
            var i3 = t2.__unsignedDigit(0);
            if (1 === i3) return e2;
            if (i3 >= g2.__kMaxLengthBits) throw new RangeError("BigInt too big");
            if (1 === e2.length && 2 === e2.__digit(0)) {
              var _2 = 1 + (i3 >>> 5), n2 = e2.sign && 0 != (1 & i3), o2 = new g2(_2, n2);
              o2.__initializeDigits();
              var l3 = 1 << (31 & i3);
              return o2.__setDigit(_2 - 1, l3), o2;
            }
            var a3 = null, s3 = e2;
            for (0 != (1 & i3) && (a3 = e2), i3 >>= 1; 0 !== i3; i3 >>= 1) s3 = g2.multiply(s3, s3), 0 != (1 & i3) && (null === a3 ? a3 = s3 : a3 = g2.multiply(a3, s3));
            return a3;
          } }, { key: "multiply", value: function(e2, t2) {
            if (0 === e2.length) return e2;
            if (0 === t2.length) return t2;
            var _2 = e2.length + t2.length;
            32 <= e2.__clzmsd() + t2.__clzmsd() && _2--;
            var n2 = new g2(_2, e2.sign !== t2.sign);
            n2.__initializeDigits();
            for (var o2 = 0; o2 < e2.length; o2++) g2.__multiplyAccumulate(t2, e2.__digit(o2), n2, o2);
            return n2.__trim();
          } }, { key: "divide", value: function(e2, t2) {
            if (0 === t2.length) throw new RangeError("Division by zero");
            if (0 > g2.__absoluteCompare(e2, t2)) return g2.__zero();
            var i3, _2 = e2.sign !== t2.sign, n2 = t2.__unsignedDigit(0);
            if (1 === t2.length && 65535 >= n2) {
              if (1 === n2) return _2 === e2.sign ? e2 : g2.unaryMinus(e2);
              i3 = g2.__absoluteDivSmall(e2, n2, null);
            } else i3 = g2.__absoluteDivLarge(e2, t2, true, false);
            return i3.sign = _2, i3.__trim();
          } }, { key: "remainder", value: function e2(t2, i3) {
            if (0 === i3.length) throw new RangeError("Division by zero");
            if (0 > g2.__absoluteCompare(t2, i3)) return t2;
            var _2 = i3.__unsignedDigit(0);
            if (1 === i3.length && 65535 >= _2) {
              if (1 === _2) return g2.__zero();
              var n2 = g2.__absoluteModSmall(t2, _2);
              return 0 === n2 ? g2.__zero() : g2.__oneDigit(n2, t2.sign);
            }
            var e3 = g2.__absoluteDivLarge(t2, i3, false, true);
            return e3.sign = t2.sign, e3.__trim();
          } }, { key: "add", value: function(e2, t2) {
            var i3 = e2.sign;
            return i3 === t2.sign ? g2.__absoluteAdd(e2, t2, i3) : 0 <= g2.__absoluteCompare(e2, t2) ? g2.__absoluteSub(e2, t2, i3) : g2.__absoluteSub(t2, e2, !i3);
          } }, { key: "subtract", value: function(e2, t2) {
            var i3 = e2.sign;
            return i3 === t2.sign ? 0 <= g2.__absoluteCompare(e2, t2) ? g2.__absoluteSub(e2, t2, i3) : g2.__absoluteSub(t2, e2, !i3) : g2.__absoluteAdd(e2, t2, i3);
          } }, { key: "leftShift", value: function(e2, t2) {
            return 0 === t2.length || 0 === e2.length ? e2 : t2.sign ? g2.__rightShiftByAbsolute(e2, t2) : g2.__leftShiftByAbsolute(e2, t2);
          } }, { key: "signedRightShift", value: function(e2, t2) {
            return 0 === t2.length || 0 === e2.length ? e2 : t2.sign ? g2.__leftShiftByAbsolute(e2, t2) : g2.__rightShiftByAbsolute(e2, t2);
          } }, { key: "unsignedRightShift", value: function() {
            throw new TypeError("BigInts have no unsigned right shift; use >> instead");
          } }, { key: "lessThan", value: function(e2, t2) {
            return 0 > g2.__compareToBigInt(e2, t2);
          } }, { key: "lessThanOrEqual", value: function(e2, t2) {
            return 0 >= g2.__compareToBigInt(e2, t2);
          } }, { key: "greaterThan", value: function(e2, t2) {
            return 0 < g2.__compareToBigInt(e2, t2);
          } }, { key: "greaterThanOrEqual", value: function(e2, t2) {
            return 0 <= g2.__compareToBigInt(e2, t2);
          } }, { key: "equal", value: function(e2, t2) {
            if (e2.sign !== t2.sign) return false;
            if (e2.length !== t2.length) return false;
            for (var _2 = 0; _2 < e2.length; _2++) if (e2.__digit(_2) !== t2.__digit(_2)) return false;
            return true;
          } }, { key: "notEqual", value: function(e2, t2) {
            return !g2.equal(e2, t2);
          } }, { key: "bitwiseAnd", value: function(e2, t2) {
            if (!e2.sign && !t2.sign) return g2.__absoluteAnd(e2, t2).__trim();
            if (e2.sign && t2.sign) {
              var i3 = l2(e2.length, t2.length) + 1, _2 = g2.__absoluteSubOne(e2, i3), n2 = g2.__absoluteSubOne(t2);
              return _2 = g2.__absoluteOr(_2, n2, _2), g2.__absoluteAddOne(_2, true, _2).__trim();
            }
            if (e2.sign) {
              var o2 = [t2, e2];
              e2 = o2[0], t2 = o2[1];
            }
            return g2.__absoluteAndNot(e2, g2.__absoluteSubOne(t2)).__trim();
          } }, { key: "bitwiseXor", value: function(e2, t2) {
            if (!e2.sign && !t2.sign) return g2.__absoluteXor(e2, t2).__trim();
            if (e2.sign && t2.sign) {
              var i3 = l2(e2.length, t2.length), _2 = g2.__absoluteSubOne(e2, i3), n2 = g2.__absoluteSubOne(t2);
              return g2.__absoluteXor(_2, n2, _2).__trim();
            }
            var o2 = l2(e2.length, t2.length) + 1;
            if (e2.sign) {
              var a3 = [t2, e2];
              e2 = a3[0], t2 = a3[1];
            }
            var s3 = g2.__absoluteSubOne(t2, o2);
            return s3 = g2.__absoluteXor(s3, e2, s3), g2.__absoluteAddOne(s3, true, s3).__trim();
          } }, { key: "bitwiseOr", value: function(e2, t2) {
            var i3 = l2(e2.length, t2.length);
            if (!e2.sign && !t2.sign) return g2.__absoluteOr(e2, t2).__trim();
            if (e2.sign && t2.sign) {
              var _2 = g2.__absoluteSubOne(e2, i3), n2 = g2.__absoluteSubOne(t2);
              return _2 = g2.__absoluteAnd(_2, n2, _2), g2.__absoluteAddOne(_2, true, _2).__trim();
            }
            if (e2.sign) {
              var o2 = [t2, e2];
              e2 = o2[0], t2 = o2[1];
            }
            var a3 = g2.__absoluteSubOne(t2, i3);
            return a3 = g2.__absoluteAndNot(a3, e2, a3), g2.__absoluteAddOne(a3, true, a3).__trim();
          } }, { key: "asIntN", value: function(e2, t2) {
            if (0 === t2.length) return t2;
            if (0 === e2) return g2.__zero();
            if (e2 >= g2.__kMaxLengthBits) return t2;
            var _2 = e2 + 31 >>> 5;
            if (t2.length < _2) return t2;
            var n2 = t2.__unsignedDigit(_2 - 1), o2 = 1 << (31 & e2 - 1);
            if (t2.length === _2 && n2 < o2) return t2;
            if (!((n2 & o2) === o2)) return g2.__truncateToNBits(e2, t2);
            if (!t2.sign) return g2.__truncateAndSubFromPowerOfTwo(e2, t2, true);
            if (0 == (n2 & o2 - 1)) {
              for (var l3 = _2 - 2; 0 <= l3; l3--) if (0 !== t2.__digit(l3)) return g2.__truncateAndSubFromPowerOfTwo(e2, t2, false);
              return t2.length === _2 && n2 === o2 ? t2 : g2.__truncateToNBits(e2, t2);
            }
            return g2.__truncateAndSubFromPowerOfTwo(e2, t2, false);
          } }, { key: "asUintN", value: function(e2, t2) {
            if (0 === t2.length) return t2;
            if (0 === e2) return g2.__zero();
            if (t2.sign) {
              if (e2 > g2.__kMaxLengthBits) throw new RangeError("BigInt too big");
              return g2.__truncateAndSubFromPowerOfTwo(e2, t2, false);
            }
            if (e2 >= g2.__kMaxLengthBits) return t2;
            var i3 = e2 + 31 >>> 5;
            if (t2.length < i3) return t2;
            var _2 = 31 & e2;
            if (t2.length == i3) {
              if (0 === _2) return t2;
              var n2 = t2.__digit(i3 - 1);
              if (0 == n2 >>> _2) return t2;
            }
            return g2.__truncateToNBits(e2, t2);
          } }, { key: "ADD", value: function(e2, t2) {
            if (e2 = g2.__toPrimitive(e2), t2 = g2.__toPrimitive(t2), "string" == typeof e2) return "string" != typeof t2 && (t2 = t2.toString()), e2 + t2;
            if ("string" == typeof t2) return e2.toString() + t2;
            if (e2 = g2.__toNumeric(e2), t2 = g2.__toNumeric(t2), g2.__isBigInt(e2) && g2.__isBigInt(t2)) return g2.add(e2, t2);
            if ("number" == typeof e2 && "number" == typeof t2) return e2 + t2;
            throw new TypeError("Cannot mix BigInt and other types, use explicit conversions");
          } }, { key: "LT", value: function(e2, t2) {
            return g2.__compare(e2, t2, 0);
          } }, { key: "LE", value: function(e2, t2) {
            return g2.__compare(e2, t2, 1);
          } }, { key: "GT", value: function(e2, t2) {
            return g2.__compare(e2, t2, 2);
          } }, { key: "GE", value: function(e2, t2) {
            return g2.__compare(e2, t2, 3);
          } }, { key: "EQ", value: function(t2, i3) {
            for (; ; ) {
              if (g2.__isBigInt(t2)) return g2.__isBigInt(i3) ? g2.equal(t2, i3) : g2.EQ(i3, t2);
              if ("number" == typeof t2) {
                if (g2.__isBigInt(i3)) return g2.__equalToNumber(i3, t2);
                if ("object" !== e(i3)) return t2 == i3;
                i3 = g2.__toPrimitive(i3);
              } else if ("string" == typeof t2) {
                if (g2.__isBigInt(i3)) return t2 = g2.__fromString(t2), null !== t2 && g2.equal(t2, i3);
                if ("object" !== e(i3)) return t2 == i3;
                i3 = g2.__toPrimitive(i3);
              } else if ("boolean" == typeof t2) {
                if (g2.__isBigInt(i3)) return g2.__equalToNumber(i3, +t2);
                if ("object" !== e(i3)) return t2 == i3;
                i3 = g2.__toPrimitive(i3);
              } else if ("symbol" === e(t2)) {
                if (g2.__isBigInt(i3)) return false;
                if ("object" !== e(i3)) return t2 == i3;
                i3 = g2.__toPrimitive(i3);
              } else if ("object" === e(t2)) {
                if ("object" === e(i3) && i3.constructor !== g2) return t2 == i3;
                t2 = g2.__toPrimitive(t2);
              } else return t2 == i3;
            }
          } }, { key: "NE", value: function(e2, t2) {
            return !g2.EQ(e2, t2);
          } }, { key: "__zero", value: function() {
            return new g2(0, false);
          } }, { key: "__oneDigit", value: function(e2, t2) {
            var i3 = new g2(1, t2);
            return i3.__setDigit(0, e2), i3;
          } }, { key: "__decideRounding", value: function(e2, t2, i3, _2) {
            if (0 < t2) return -1;
            var n2;
            if (0 > t2) n2 = -t2 - 1;
            else {
              if (0 === i3) return -1;
              i3--, _2 = e2.__digit(i3), n2 = 31;
            }
            var g3 = 1 << n2;
            if (0 == (_2 & g3)) return -1;
            if (g3 -= 1, 0 != (_2 & g3)) return 1;
            for (; 0 < i3; ) if (i3--, 0 !== e2.__digit(i3)) return 1;
            return 0;
          } }, { key: "__fromDouble", value: function(e2) {
            g2.__kBitConversionDouble[0] = e2;
            var t2, i3 = 2047 & g2.__kBitConversionInts[1] >>> 20, _2 = i3 - 1023, n2 = (_2 >>> 5) + 1, o2 = new g2(n2, 0 > e2), l3 = 1048575 & g2.__kBitConversionInts[1] | 1048576, a3 = g2.__kBitConversionInts[0], s3 = 20, u3 = 31 & _2, r2 = 0;
            if (u3 < s3) {
              var d2 = s3 - u3;
              r2 = d2 + 32, t2 = l3 >>> d2, l3 = l3 << 32 - d2 | a3 >>> d2, a3 <<= 32 - d2;
            } else if (u3 === s3) r2 = 32, t2 = l3, l3 = a3;
            else {
              var h2 = u3 - s3;
              r2 = 32 - h2, t2 = l3 << h2 | a3 >>> 32 - h2, l3 = a3 << h2;
            }
            o2.__setDigit(n2 - 1, t2);
            for (var b2 = n2 - 2; 0 <= b2; b2--) 0 < r2 ? (r2 -= 32, t2 = l3, l3 = a3) : t2 = 0, o2.__setDigit(b2, t2);
            return o2.__trim();
          } }, { key: "__isWhitespace", value: function(e2) {
            return !!(13 >= e2 && 9 <= e2) || (159 >= e2 ? 32 == e2 : 131071 >= e2 ? 160 == e2 || 5760 == e2 : 196607 >= e2 ? (e2 &= 131071, 10 >= e2 || 40 == e2 || 41 == e2 || 47 == e2 || 95 == e2 || 4096 == e2) : 65279 == e2);
          } }, { key: "__fromString", value: function(e2) {
            var t2 = 1 < arguments.length && void 0 !== arguments[1] ? arguments[1] : 0, i3 = 0, _2 = e2.length, n2 = 0;
            if (n2 === _2) return g2.__zero();
            for (var o2 = e2.charCodeAt(n2); g2.__isWhitespace(o2); ) {
              if (++n2 === _2) return g2.__zero();
              o2 = e2.charCodeAt(n2);
            }
            if (43 === o2) {
              if (++n2 === _2) return null;
              o2 = e2.charCodeAt(n2), i3 = 1;
            } else if (45 === o2) {
              if (++n2 === _2) return null;
              o2 = e2.charCodeAt(n2), i3 = -1;
            }
            if (0 === t2) {
              if (t2 = 10, 48 === o2) {
                if (++n2 === _2) return g2.__zero();
                if (o2 = e2.charCodeAt(n2), 88 === o2 || 120 === o2) {
                  if (t2 = 16, ++n2 === _2) return null;
                  o2 = e2.charCodeAt(n2);
                } else if (79 === o2 || 111 === o2) {
                  if (t2 = 8, ++n2 === _2) return null;
                  o2 = e2.charCodeAt(n2);
                } else if (66 === o2 || 98 === o2) {
                  if (t2 = 2, ++n2 === _2) return null;
                  o2 = e2.charCodeAt(n2);
                }
              }
            } else if (16 === t2 && 48 === o2) {
              if (++n2 === _2) return g2.__zero();
              if (o2 = e2.charCodeAt(n2), 88 === o2 || 120 === o2) {
                if (++n2 === _2) return null;
                o2 = e2.charCodeAt(n2);
              }
            }
            for (; 48 === o2; ) {
              if (++n2 === _2) return g2.__zero();
              o2 = e2.charCodeAt(n2);
            }
            var l3 = _2 - n2, a3 = g2.__kMaxBitsPerChar[t2], s3 = g2.__kBitsPerCharTableMultiplier - 1;
            if (l3 > 1073741824 / a3) return null;
            var u3 = a3 * l3 + s3 >>> g2.__kBitsPerCharTableShift, r2 = new g2(u3 + 31 >>> 5, false), h2 = 10 > t2 ? t2 : 10, b2 = 10 < t2 ? t2 - 10 : 0;
            if (0 == (t2 & t2 - 1)) {
              a3 >>= g2.__kBitsPerCharTableShift;
              var c2 = [], v2 = [], f2 = false;
              do {
                for (var y, k = 0, D = 0; ; ) {
                  if (y = void 0, o2 - 48 >>> 0 < h2) y = o2 - 48;
                  else if ((32 | o2) - 97 >>> 0 < b2) y = (32 | o2) - 87;
                  else {
                    f2 = true;
                    break;
                  }
                  if (D += a3, k = k << a3 | y, ++n2 === _2) {
                    f2 = true;
                    break;
                  }
                  if (o2 = e2.charCodeAt(n2), 32 < D + a3) break;
                }
                c2.push(k), v2.push(D);
              } while (!f2);
              g2.__fillFromParts(r2, c2, v2);
            } else {
              r2.__initializeDigits();
              var p = false, B = 0;
              do {
                for (var S, C = 0, A = 1; ; ) {
                  if (S = void 0, o2 - 48 >>> 0 < h2) S = o2 - 48;
                  else if ((32 | o2) - 97 >>> 0 < b2) S = (32 | o2) - 87;
                  else {
                    p = true;
                    break;
                  }
                  var T = A * t2;
                  if (4294967295 < T) break;
                  if (A = T, C = C * t2 + S, B++, ++n2 === _2) {
                    p = true;
                    break;
                  }
                  o2 = e2.charCodeAt(n2);
                }
                s3 = 32 * g2.__kBitsPerCharTableMultiplier - 1;
                var m2 = a3 * B + s3 >>> g2.__kBitsPerCharTableShift + 5;
                r2.__inplaceMultiplyAdd(A, C, m2);
              } while (!p);
            }
            if (n2 !== _2) {
              if (!g2.__isWhitespace(o2)) return null;
              for (n2++; n2 < _2; n2++) if (o2 = e2.charCodeAt(n2), !g2.__isWhitespace(o2)) return null;
            }
            return 0 !== i3 && 10 !== t2 ? null : (r2.sign = -1 === i3, r2.__trim());
          } }, { key: "__fillFromParts", value: function(e2, t2, _2) {
            for (var n2 = 0, g3 = 0, o2 = 0, l3 = t2.length - 1; 0 <= l3; l3--) {
              var a3 = t2[l3], s3 = _2[l3];
              g3 |= a3 << o2, o2 += s3, 32 === o2 ? (e2.__setDigit(n2++, g3), o2 = 0, g3 = 0) : 32 < o2 && (e2.__setDigit(n2++, g3), o2 -= 32, g3 = a3 >>> s3 - o2);
            }
            if (0 !== g3) {
              if (n2 >= e2.length) throw new Error("implementation bug");
              e2.__setDigit(n2++, g3);
            }
            for (; n2 < e2.length; n2++) e2.__setDigit(n2, 0);
          } }, { key: "__toStringBasePowerOfTwo", value: function(e2, t2) {
            var _2 = e2.length, n2 = t2 - 1;
            n2 = (85 & n2 >>> 1) + (85 & n2), n2 = (51 & n2 >>> 2) + (51 & n2), n2 = (15 & n2 >>> 4) + (15 & n2);
            var o2 = n2, l3 = t2 - 1, a3 = e2.__digit(_2 - 1), u3 = s2(a3), r2 = 0 | (32 * _2 - u3 + o2 - 1) / o2;
            if (e2.sign && r2++, 268435456 < r2) throw new Error("string too long");
            for (var d2 = Array(r2), h2 = r2 - 1, b2 = 0, m2 = 0, c2 = 0; c2 < _2 - 1; c2++) {
              var v2 = e2.__digit(c2), f2 = (b2 | v2 << m2) & l3;
              d2[h2--] = g2.__kConversionChars[f2];
              var y = o2 - m2;
              for (b2 = v2 >>> y, m2 = 32 - y; m2 >= o2; ) d2[h2--] = g2.__kConversionChars[b2 & l3], b2 >>>= o2, m2 -= o2;
            }
            var k = (b2 | a3 << m2) & l3;
            for (d2[h2--] = g2.__kConversionChars[k], b2 = a3 >>> o2 - m2; 0 !== b2; ) d2[h2--] = g2.__kConversionChars[b2 & l3], b2 >>>= o2;
            if (e2.sign && (d2[h2--] = "-"), -1 !== h2) throw new Error("implementation bug");
            return d2.join("");
          } }, { key: "__toStringGeneric", value: function(e2, t2, _2) {
            var n2 = e2.length;
            if (0 === n2) return "";
            if (1 === n2) {
              var o2 = e2.__unsignedDigit(0).toString(t2);
              return false === _2 && e2.sign && (o2 = "-" + o2), o2;
            }
            var l3 = 32 * n2 - s2(e2.__digit(n2 - 1)), a3 = g2.__kMaxBitsPerChar[t2], u3 = a3 - 1, r2 = l3 * g2.__kBitsPerCharTableMultiplier;
            r2 += u3 - 1, r2 = 0 | r2 / u3;
            var d2, h2, b2 = r2 + 1 >> 1, m2 = g2.exponentiate(g2.__oneDigit(t2, false), g2.__oneDigit(b2, false)), c2 = m2.__unsignedDigit(0);
            if (1 === m2.length && 65535 >= c2) {
              d2 = new g2(e2.length, false), d2.__initializeDigits();
              for (var v2, f2 = 0, y = 2 * e2.length - 1; 0 <= y; y--) v2 = f2 << 16 | e2.__halfDigit(y), d2.__setHalfDigit(y, 0 | v2 / c2), f2 = 0 | v2 % c2;
              h2 = f2.toString(t2);
            } else {
              var k = g2.__absoluteDivLarge(e2, m2, true, true);
              d2 = k.quotient;
              var D = k.remainder.__trim();
              h2 = g2.__toStringGeneric(D, t2, true);
            }
            d2.__trim();
            for (var p = g2.__toStringGeneric(d2, t2, true); h2.length < b2; ) h2 = "0" + h2;
            return false === _2 && e2.sign && (p = "-" + p), p + h2;
          } }, { key: "__unequalSign", value: function(e2) {
            return e2 ? -1 : 1;
          } }, { key: "__absoluteGreater", value: function(e2) {
            return e2 ? -1 : 1;
          } }, { key: "__absoluteLess", value: function(e2) {
            return e2 ? 1 : -1;
          } }, { key: "__compareToBigInt", value: function(e2, t2) {
            var i3 = e2.sign;
            if (i3 !== t2.sign) return g2.__unequalSign(i3);
            var _2 = g2.__absoluteCompare(e2, t2);
            return 0 < _2 ? g2.__absoluteGreater(i3) : 0 > _2 ? g2.__absoluteLess(i3) : 0;
          } }, { key: "__compareToNumber", value: function(e2, t2) {
            if (true | t2) {
              var i3 = e2.sign, _2 = 0 > t2;
              if (i3 !== _2) return g2.__unequalSign(i3);
              if (0 === e2.length) {
                if (_2) throw new Error("implementation bug");
                return 0 === t2 ? 0 : -1;
              }
              if (1 < e2.length) return g2.__absoluteGreater(i3);
              var n2 = o(t2), l3 = e2.__unsignedDigit(0);
              return l3 > n2 ? g2.__absoluteGreater(i3) : l3 < n2 ? g2.__absoluteLess(i3) : 0;
            }
            return g2.__compareToDouble(e2, t2);
          } }, { key: "__compareToDouble", value: function(e2, t2) {
            if (t2 !== t2) return t2;
            if (t2 === 1 / 0) return -1;
            if (t2 === -Infinity) return 1;
            var i3 = e2.sign;
            if (i3 !== 0 > t2) return g2.__unequalSign(i3);
            if (0 === t2) throw new Error("implementation bug: should be handled elsewhere");
            if (0 === e2.length) return -1;
            g2.__kBitConversionDouble[0] = t2;
            var _2 = 2047 & g2.__kBitConversionInts[1] >>> 20;
            if (2047 == _2) throw new Error("implementation bug: handled elsewhere");
            var n2 = _2 - 1023;
            if (0 > n2) return g2.__absoluteGreater(i3);
            var o2 = e2.length, l3 = e2.__digit(o2 - 1), a3 = s2(l3), u3 = 32 * o2 - a3, r2 = n2 + 1;
            if (u3 < r2) return g2.__absoluteLess(i3);
            if (u3 > r2) return g2.__absoluteGreater(i3);
            var d2 = 1048576 | 1048575 & g2.__kBitConversionInts[1], h2 = g2.__kBitConversionInts[0], b2 = 20, m2 = 31 - a3;
            if (m2 !== (u3 - 1) % 31) throw new Error("implementation bug");
            var c2, v2 = 0;
            if (m2 < b2) {
              var f2 = b2 - m2;
              v2 = f2 + 32, c2 = d2 >>> f2, d2 = d2 << 32 - f2 | h2 >>> f2, h2 <<= 32 - f2;
            } else if (m2 === b2) v2 = 32, c2 = d2, d2 = h2;
            else {
              var y = m2 - b2;
              v2 = 32 - y, c2 = d2 << y | h2 >>> 32 - y, d2 = h2 << y;
            }
            if (l3 >>>= 0, c2 >>>= 0, l3 > c2) return g2.__absoluteGreater(i3);
            if (l3 < c2) return g2.__absoluteLess(i3);
            for (var k = o2 - 2; 0 <= k; k--) {
              0 < v2 ? (v2 -= 32, c2 = d2 >>> 0, d2 = h2, h2 = 0) : c2 = 0;
              var D = e2.__unsignedDigit(k);
              if (D > c2) return g2.__absoluteGreater(i3);
              if (D < c2) return g2.__absoluteLess(i3);
            }
            if (0 !== d2 || 0 !== h2) {
              if (0 === v2) throw new Error("implementation bug");
              return g2.__absoluteLess(i3);
            }
            return 0;
          } }, { key: "__equalToNumber", value: function(e2, t2) {
            return t2 | 0 === t2 ? 0 === t2 ? 0 === e2.length : 1 === e2.length && e2.sign === 0 > t2 && e2.__unsignedDigit(0) === o(t2) : 0 === g2.__compareToDouble(e2, t2);
          } }, { key: "__comparisonResultToBool", value: function(e2, t2) {
            switch (t2) {
              case 0:
                return 0 > e2;
              case 1:
                return 0 >= e2;
              case 2:
                return 0 < e2;
              case 3:
                return 0 <= e2;
            }
            throw new Error("unreachable");
          } }, { key: "__compare", value: function(e2, t2, i3) {
            if (e2 = g2.__toPrimitive(e2), t2 = g2.__toPrimitive(t2), "string" == typeof e2 && "string" == typeof t2) switch (i3) {
              case 0:
                return e2 < t2;
              case 1:
                return e2 <= t2;
              case 2:
                return e2 > t2;
              case 3:
                return e2 >= t2;
            }
            if (g2.__isBigInt(e2) && "string" == typeof t2) return t2 = g2.__fromString(t2), null !== t2 && g2.__comparisonResultToBool(g2.__compareToBigInt(e2, t2), i3);
            if ("string" == typeof e2 && g2.__isBigInt(t2)) return e2 = g2.__fromString(e2), null !== e2 && g2.__comparisonResultToBool(g2.__compareToBigInt(e2, t2), i3);
            if (e2 = g2.__toNumeric(e2), t2 = g2.__toNumeric(t2), g2.__isBigInt(e2)) {
              if (g2.__isBigInt(t2)) return g2.__comparisonResultToBool(g2.__compareToBigInt(e2, t2), i3);
              if ("number" != typeof t2) throw new Error("implementation bug");
              return g2.__comparisonResultToBool(g2.__compareToNumber(e2, t2), i3);
            }
            if ("number" != typeof e2) throw new Error("implementation bug");
            if (g2.__isBigInt(t2)) return g2.__comparisonResultToBool(g2.__compareToNumber(t2, e2), 2 ^ i3);
            if ("number" != typeof t2) throw new Error("implementation bug");
            return 0 === i3 ? e2 < t2 : 1 === i3 ? e2 <= t2 : 2 === i3 ? e2 > t2 : 3 === i3 ? e2 >= t2 : void 0;
          } }, { key: "__absoluteAdd", value: function(e2, t2, _2) {
            if (e2.length < t2.length) return g2.__absoluteAdd(t2, e2, _2);
            if (0 === e2.length) return e2;
            if (0 === t2.length) return e2.sign === _2 ? e2 : g2.unaryMinus(e2);
            var n2 = e2.length;
            (0 === e2.__clzmsd() || t2.length === e2.length && 0 === t2.__clzmsd()) && n2++;
            for (var o2 = new g2(n2, _2), l3 = 0, a3 = 0; a3 < t2.length; a3++) {
              var s3 = t2.__digit(a3), u3 = e2.__digit(a3), r2 = (65535 & u3) + (65535 & s3) + l3, d2 = (u3 >>> 16) + (s3 >>> 16) + (r2 >>> 16);
              l3 = d2 >>> 16, o2.__setDigit(a3, 65535 & r2 | d2 << 16);
            }
            for (; a3 < e2.length; a3++) {
              var h2 = e2.__digit(a3), b2 = (65535 & h2) + l3, m2 = (h2 >>> 16) + (b2 >>> 16);
              l3 = m2 >>> 16, o2.__setDigit(a3, 65535 & b2 | m2 << 16);
            }
            return a3 < o2.length && o2.__setDigit(a3, l3), o2.__trim();
          } }, { key: "__absoluteSub", value: function(e2, t2, _2) {
            if (0 === e2.length) return e2;
            if (0 === t2.length) return e2.sign === _2 ? e2 : g2.unaryMinus(e2);
            for (var n2 = new g2(e2.length, _2), o2 = 0, l3 = 0; l3 < t2.length; l3++) {
              var a3 = e2.__digit(l3), s3 = t2.__digit(l3), u3 = (65535 & a3) - (65535 & s3) - o2;
              o2 = 1 & u3 >>> 16;
              var r2 = (a3 >>> 16) - (s3 >>> 16) - o2;
              o2 = 1 & r2 >>> 16, n2.__setDigit(l3, 65535 & u3 | r2 << 16);
            }
            for (; l3 < e2.length; l3++) {
              var d2 = e2.__digit(l3), h2 = (65535 & d2) - o2;
              o2 = 1 & h2 >>> 16;
              var b2 = (d2 >>> 16) - o2;
              o2 = 1 & b2 >>> 16, n2.__setDigit(l3, 65535 & h2 | b2 << 16);
            }
            return n2.__trim();
          } }, { key: "__absoluteAddOne", value: function(e2, t2) {
            var _2 = 2 < arguments.length && void 0 !== arguments[2] ? arguments[2] : null, n2 = e2.length;
            null === _2 ? _2 = new g2(n2, t2) : _2.sign = t2;
            for (var o2, l3 = true, a3 = 0; a3 < n2; a3++) {
              if (o2 = e2.__digit(a3), l3) {
                var s3 = -1 === o2;
                o2 = 0 | o2 + 1, l3 = s3;
              }
              _2.__setDigit(a3, o2);
            }
            return l3 && _2.__setDigitGrow(n2, 1), _2;
          } }, { key: "__absoluteSubOne", value: function(e2, t2) {
            var _2 = e2.length;
            t2 = t2 || _2;
            for (var n2, o2 = new g2(t2, false), l3 = true, a3 = 0; a3 < _2; a3++) {
              if (n2 = e2.__digit(a3), l3) {
                var s3 = 0 === n2;
                n2 = 0 | n2 - 1, l3 = s3;
              }
              o2.__setDigit(a3, n2);
            }
            if (l3) throw new Error("implementation bug");
            for (var u3 = _2; u3 < t2; u3++) o2.__setDigit(u3, 0);
            return o2;
          } }, { key: "__absoluteAnd", value: function(e2, t2) {
            var _2 = 2 < arguments.length && void 0 !== arguments[2] ? arguments[2] : null, n2 = e2.length, o2 = t2.length, l3 = o2;
            if (n2 < o2) {
              l3 = n2;
              var a3 = e2, s3 = n2;
              e2 = t2, n2 = o2, t2 = a3, o2 = s3;
            }
            var u3 = l3;
            null === _2 ? _2 = new g2(u3, false) : u3 = _2.length;
            for (var r2 = 0; r2 < l3; r2++) _2.__setDigit(r2, e2.__digit(r2) & t2.__digit(r2));
            for (; r2 < u3; r2++) _2.__setDigit(r2, 0);
            return _2;
          } }, { key: "__absoluteAndNot", value: function(e2, t2) {
            var _2 = 2 < arguments.length && void 0 !== arguments[2] ? arguments[2] : null, n2 = e2.length, o2 = t2.length, l3 = o2;
            n2 < o2 && (l3 = n2);
            var a3 = n2;
            null === _2 ? _2 = new g2(a3, false) : a3 = _2.length;
            for (var s3 = 0; s3 < l3; s3++) _2.__setDigit(s3, e2.__digit(s3) & ~t2.__digit(s3));
            for (; s3 < n2; s3++) _2.__setDigit(s3, e2.__digit(s3));
            for (; s3 < a3; s3++) _2.__setDigit(s3, 0);
            return _2;
          } }, { key: "__absoluteOr", value: function(e2, t2) {
            var _2 = 2 < arguments.length && void 0 !== arguments[2] ? arguments[2] : null, n2 = e2.length, o2 = t2.length, l3 = o2;
            if (n2 < o2) {
              l3 = n2;
              var a3 = e2, s3 = n2;
              e2 = t2, n2 = o2, t2 = a3, o2 = s3;
            }
            var u3 = n2;
            null === _2 ? _2 = new g2(u3, false) : u3 = _2.length;
            for (var r2 = 0; r2 < l3; r2++) _2.__setDigit(r2, e2.__digit(r2) | t2.__digit(r2));
            for (; r2 < n2; r2++) _2.__setDigit(r2, e2.__digit(r2));
            for (; r2 < u3; r2++) _2.__setDigit(r2, 0);
            return _2;
          } }, { key: "__absoluteXor", value: function(e2, t2) {
            var _2 = 2 < arguments.length && void 0 !== arguments[2] ? arguments[2] : null, n2 = e2.length, o2 = t2.length, l3 = o2;
            if (n2 < o2) {
              l3 = n2;
              var a3 = e2, s3 = n2;
              e2 = t2, n2 = o2, t2 = a3, o2 = s3;
            }
            var u3 = n2;
            null === _2 ? _2 = new g2(u3, false) : u3 = _2.length;
            for (var r2 = 0; r2 < l3; r2++) _2.__setDigit(r2, e2.__digit(r2) ^ t2.__digit(r2));
            for (; r2 < n2; r2++) _2.__setDigit(r2, e2.__digit(r2));
            for (; r2 < u3; r2++) _2.__setDigit(r2, 0);
            return _2;
          } }, { key: "__absoluteCompare", value: function(e2, t2) {
            var _2 = e2.length - t2.length;
            if (0 != _2) return _2;
            for (var n2 = e2.length - 1; 0 <= n2 && e2.__digit(n2) === t2.__digit(n2); ) n2--;
            return 0 > n2 ? 0 : e2.__unsignedDigit(n2) > t2.__unsignedDigit(n2) ? 1 : -1;
          } }, { key: "__multiplyAccumulate", value: function(e2, t2, _2, n2) {
            if (0 !== t2) {
              for (var g3 = 65535 & t2, o2 = t2 >>> 16, l3 = 0, s3 = 0, u3 = 0, r2 = 0; r2 < e2.length; r2++, n2++) {
                var d2 = _2.__digit(n2), h2 = 65535 & d2, b2 = d2 >>> 16, m2 = e2.__digit(r2), c2 = 65535 & m2, v2 = m2 >>> 16, f2 = a2(c2, g3), y = a2(c2, o2), k = a2(v2, g3), D = a2(v2, o2);
                h2 += s3 + (65535 & f2), b2 += u3 + l3 + (h2 >>> 16) + (f2 >>> 16) + (65535 & y) + (65535 & k), l3 = b2 >>> 16, s3 = (y >>> 16) + (k >>> 16) + (65535 & D) + l3, l3 = s3 >>> 16, s3 &= 65535, u3 = D >>> 16, d2 = 65535 & h2 | b2 << 16, _2.__setDigit(n2, d2);
              }
              for (; 0 !== l3 || 0 !== s3 || 0 !== u3; n2++) {
                var p = _2.__digit(n2), B = (65535 & p) + s3, S = (p >>> 16) + (B >>> 16) + u3 + l3;
                s3 = 0, u3 = 0, l3 = S >>> 16, p = 65535 & B | S << 16, _2.__setDigit(n2, p);
              }
            }
          } }, { key: "__internalMultiplyAdd", value: function(e2, t2, _2, g3, o2) {
            for (var l3 = _2, s3 = 0, u3 = 0; u3 < g3; u3++) {
              var r2 = e2.__digit(u3), d2 = a2(65535 & r2, t2), h2 = (65535 & d2) + s3 + l3;
              l3 = h2 >>> 16;
              var b2 = a2(r2 >>> 16, t2), m2 = (65535 & b2) + (d2 >>> 16) + l3;
              l3 = m2 >>> 16, s3 = b2 >>> 16, o2.__setDigit(u3, m2 << 16 | 65535 & h2);
            }
            if (o2.length > g3) for (o2.__setDigit(g3++, l3 + s3); g3 < o2.length; ) o2.__setDigit(g3++, 0);
            else if (0 !== l3 + s3) throw new Error("implementation bug");
          } }, { key: "__absoluteDivSmall", value: function(e2, t2, _2) {
            null === _2 && (_2 = new g2(e2.length, false));
            for (var n2 = 0, o2 = 2 * e2.length - 1; 0 <= o2; o2 -= 2) {
              var l3 = (n2 << 16 | e2.__halfDigit(o2)) >>> 0, a3 = 0 | l3 / t2;
              n2 = 0 | l3 % t2, l3 = (n2 << 16 | e2.__halfDigit(o2 - 1)) >>> 0;
              var s3 = 0 | l3 / t2;
              n2 = 0 | l3 % t2, _2.__setDigit(o2 >>> 1, a3 << 16 | s3);
            }
            return _2;
          } }, { key: "__absoluteModSmall", value: function(e2, t2) {
            for (var _2, n2 = 0, g3 = 2 * e2.length - 1; 0 <= g3; g3--) _2 = (n2 << 16 | e2.__halfDigit(g3)) >>> 0, n2 = 0 | _2 % t2;
            return n2;
          } }, { key: "__absoluteDivLarge", value: function(e2, t2, i3, _2) {
            var o2 = t2.__halfDigitLength(), n2 = t2.length, l3 = e2.__halfDigitLength() - o2, s3 = null;
            i3 && (s3 = new g2(l3 + 2 >>> 1, false), s3.__initializeDigits());
            var r2 = new g2(o2 + 2 >>> 1, false);
            r2.__initializeDigits();
            var d2 = g2.__clz16(t2.__halfDigit(o2 - 1));
            0 < d2 && (t2 = g2.__specialLeftShift(t2, d2, 0));
            for (var h2 = g2.__specialLeftShift(e2, d2, 1), u3 = t2.__halfDigit(o2 - 1), b2 = 0, m2 = l3; 0 <= m2; m2--) {
              var v2 = 65535, f2 = h2.__halfDigit(m2 + o2);
              if (f2 !== u3) {
                var y = (f2 << 16 | h2.__halfDigit(m2 + o2 - 1)) >>> 0;
                v2 = 0 | y / u3;
                for (var k = 0 | y % u3, D = t2.__halfDigit(o2 - 2), p = h2.__halfDigit(m2 + o2 - 2); a2(v2, D) >>> 0 > (k << 16 | p) >>> 0 && (v2--, k += u3, !(65535 < k)); ) ;
              }
              g2.__internalMultiplyAdd(t2, v2, 0, n2, r2);
              var B = h2.__inplaceSub(r2, m2, o2 + 1);
              0 !== B && (B = h2.__inplaceAdd(t2, m2, o2), h2.__setHalfDigit(m2 + o2, h2.__halfDigit(m2 + o2) + B), v2--), i3 && (1 & m2 ? b2 = v2 << 16 : s3.__setDigit(m2 >>> 1, b2 | v2));
            }
            return _2 ? (h2.__inplaceRightShift(d2), i3 ? { quotient: s3, remainder: h2 } : h2) : i3 ? s3 : void 0;
          } }, { key: "__clz16", value: function(e2) {
            return s2(e2) - 16;
          } }, { key: "__specialLeftShift", value: function(e2, t2, _2) {
            var o2 = e2.length, n2 = new g2(o2 + _2, false);
            if (0 === t2) {
              for (var l3 = 0; l3 < o2; l3++) n2.__setDigit(l3, e2.__digit(l3));
              return 0 < _2 && n2.__setDigit(o2, 0), n2;
            }
            for (var a3, s3 = 0, u3 = 0; u3 < o2; u3++) a3 = e2.__digit(u3), n2.__setDigit(u3, a3 << t2 | s3), s3 = a3 >>> 32 - t2;
            return 0 < _2 && n2.__setDigit(o2, s3), n2;
          } }, { key: "__leftShiftByAbsolute", value: function(e2, t2) {
            var _2 = g2.__toShiftAmount(t2);
            if (0 > _2) throw new RangeError("BigInt too big");
            var n2 = _2 >>> 5, o2 = 31 & _2, l3 = e2.length, a3 = 0 !== o2 && 0 != e2.__digit(l3 - 1) >>> 32 - o2, s3 = l3 + n2 + (a3 ? 1 : 0), u3 = new g2(s3, e2.sign);
            if (0 === o2) {
              for (var r2 = 0; r2 < n2; r2++) u3.__setDigit(r2, 0);
              for (; r2 < s3; r2++) u3.__setDigit(r2, e2.__digit(r2 - n2));
            } else {
              for (var h2 = 0, b2 = 0; b2 < n2; b2++) u3.__setDigit(b2, 0);
              for (var m2, c2 = 0; c2 < l3; c2++) m2 = e2.__digit(c2), u3.__setDigit(c2 + n2, m2 << o2 | h2), h2 = m2 >>> 32 - o2;
              if (a3) u3.__setDigit(l3 + n2, h2);
              else if (0 !== h2) throw new Error("implementation bug");
            }
            return u3.__trim();
          } }, { key: "__rightShiftByAbsolute", value: function(e2, t2) {
            var _2 = e2.length, n2 = e2.sign, o2 = g2.__toShiftAmount(t2);
            if (0 > o2) return g2.__rightShiftByMaximum(n2);
            var l3 = o2 >>> 5, a3 = 31 & o2, s3 = _2 - l3;
            if (0 >= s3) return g2.__rightShiftByMaximum(n2);
            var u3 = false;
            if (n2) {
              if (0 != (e2.__digit(l3) & (1 << a3) - 1)) u3 = true;
              else for (var r2 = 0; r2 < l3; r2++) if (0 !== e2.__digit(r2)) {
                u3 = true;
                break;
              }
            }
            if (u3 && 0 === a3) {
              var h2 = e2.__digit(_2 - 1);
              0 == ~h2 && s3++;
            }
            var b2 = new g2(s3, n2);
            if (0 === a3) for (var m2 = l3; m2 < _2; m2++) b2.__setDigit(m2 - l3, e2.__digit(m2));
            else {
              for (var c2, v2 = e2.__digit(l3) >>> a3, f2 = _2 - l3 - 1, y = 0; y < f2; y++) c2 = e2.__digit(y + l3 + 1), b2.__setDigit(y, c2 << 32 - a3 | v2), v2 = c2 >>> a3;
              b2.__setDigit(f2, v2);
            }
            return u3 && (b2 = g2.__absoluteAddOne(b2, true, b2)), b2.__trim();
          } }, { key: "__rightShiftByMaximum", value: function(e2) {
            return e2 ? g2.__oneDigit(1, true) : g2.__zero();
          } }, { key: "__toShiftAmount", value: function(e2) {
            if (1 < e2.length) return -1;
            var t2 = e2.__unsignedDigit(0);
            return t2 > g2.__kMaxLengthBits ? -1 : t2;
          } }, { key: "__toPrimitive", value: function(t2) {
            var i3 = 1 < arguments.length && void 0 !== arguments[1] ? arguments[1] : "default";
            if ("object" !== e(t2)) return t2;
            if (t2.constructor === g2) return t2;
            var _2 = t2[Symbol.toPrimitive];
            if (_2) {
              var n2 = _2(i3);
              if ("object" !== e(n2)) return n2;
              throw new TypeError("Cannot convert object to primitive value");
            }
            var o2 = t2.valueOf;
            if (o2) {
              var l3 = o2.call(t2);
              if ("object" !== e(l3)) return l3;
            }
            var a3 = t2.toString;
            if (a3) {
              var s3 = a3.call(t2);
              if ("object" !== e(s3)) return s3;
            }
            throw new TypeError("Cannot convert object to primitive value");
          } }, { key: "__toNumeric", value: function(e2) {
            return g2.__isBigInt(e2) ? e2 : +e2;
          } }, { key: "__isBigInt", value: function(t2) {
            return "object" === e(t2) && t2.constructor === g2;
          } }, { key: "__truncateToNBits", value: function(e2, t2) {
            for (var _2 = e2 + 31 >>> 5, n2 = new g2(_2, t2.sign), o2 = _2 - 1, l3 = 0; l3 < o2; l3++) n2.__setDigit(l3, t2.__digit(l3));
            var a3 = t2.__digit(o2);
            if (0 != (31 & e2)) {
              var s3 = 32 - (31 & e2);
              a3 = a3 << s3 >>> s3;
            }
            return n2.__setDigit(o2, a3), n2.__trim();
          } }, { key: "__truncateAndSubFromPowerOfTwo", value: function(e2, t2, _2) {
            for (var n2 = Math.min, o2 = e2 + 31 >>> 5, l3 = new g2(o2, _2), a3 = 0, s3 = o2 - 1, u3 = 0, r2 = n2(s3, t2.length); a3 < r2; a3++) {
              var d2 = t2.__digit(a3), h2 = 0 - (65535 & d2) - u3;
              u3 = 1 & h2 >>> 16;
              var b2 = 0 - (d2 >>> 16) - u3;
              u3 = 1 & b2 >>> 16, l3.__setDigit(a3, 65535 & h2 | b2 << 16);
            }
            for (; a3 < s3; a3++) l3.__setDigit(a3, 0 | -u3);
            var m2, c2 = s3 < t2.length ? t2.__digit(s3) : 0, v2 = 31 & e2;
            if (0 === v2) {
              var f2 = 0 - (65535 & c2) - u3;
              u3 = 1 & f2 >>> 16;
              var y = 0 - (c2 >>> 16) - u3;
              m2 = 65535 & f2 | y << 16;
            } else {
              var k = 32 - v2;
              c2 = c2 << k >>> k;
              var D = 1 << 32 - k, p = (65535 & D) - (65535 & c2) - u3;
              u3 = 1 & p >>> 16;
              var B = (D >>> 16) - (c2 >>> 16) - u3;
              m2 = 65535 & p | B << 16, m2 &= D - 1;
            }
            return l3.__setDigit(s3, m2), l3.__trim();
          } }, { key: "__digitPow", value: function(e2, t2) {
            for (var i3 = 1; 0 < t2; ) 1 & t2 && (i3 *= e2), t2 >>>= 1, e2 *= e2;
            return i3;
          } }]), g2;
        })(r(Array));
        return f.__kMaxLength = 33554432, f.__kMaxLengthBits = f.__kMaxLength << 5, f.__kMaxBitsPerChar = [0, 0, 32, 51, 64, 75, 83, 90, 96, 102, 107, 111, 115, 119, 122, 126, 128, 131, 134, 136, 139, 141, 143, 145, 147, 149, 151, 153, 154, 156, 158, 159, 160, 162, 163, 165, 166], f.__kBitsPerCharTableShift = 5, f.__kBitsPerCharTableMultiplier = 1 << f.__kBitsPerCharTableShift, f.__kConversionChars = ["0", "1", "2", "3", "4", "5", "6", "7", "8", "9", "a", "b", "c", "d", "e", "f", "g", "h", "i", "j", "k", "l", "m", "n", "o", "p", "q", "r", "s", "t", "u", "v", "w", "x", "y", "z"], f.__kBitConversionBuffer = new ArrayBuffer(8), f.__kBitConversionDouble = new Float64Array(f.__kBitConversionBuffer), f.__kBitConversionInts = new Int32Array(f.__kBitConversionBuffer), f;
      });
    }
  });

  // support/polyfills/JSBI.js
  var require_JSBI = __commonJS({
    "support/polyfills/JSBI.js"() {
      var __JSBI = require_jsbi_umd();
      var JSBI2 = Sk.global.JSBI = Sk.global.BigInt !== void 0 ? {} : __JSBI;
      if (Sk.global.BigInt === void 0) {
        JSBI2.__isBigInt || (JSBI2.__isBigInt = (x) => x instanceof JSBI2);
        JSBI2.powermod = (x, y, z) => {
          const One = JSBI2.BigInt(1);
          let number = One;
          y = JSBI2.greaterThan(y, JSBI2.__ZERO) ? y : JSBI2.unaryMinus(y);
          while (JSBI2.greaterThan(y, JSBI2.__ZERO)) {
            if (JSBI2.bitwiseAnd(y, One)) {
              number = JSBI2.remainder(JSBI2.multiply(number, x), z);
            }
            y = JSBI2.signedRightShift(y, One);
            x = JSBI2.remainder(JSBI2.multiply(x, x), z);
          }
          return number;
        };
      } else {
        Object.assign(JSBI2, {
          BigInt: Sk.global.BigInt,
          toNumber: (x) => Number(x),
          toString: (x) => x.toString(),
          __isBigInt: (x) => typeof x === "bigint",
          unaryMinus: (x) => -x,
          bitwiseNot: (x) => ~x,
          bitwiseAnd: (x, y) => x & y,
          bitwiseOr: (x, y) => x | y,
          bitwiseXor: (x, y) => x ^ y,
          /**
           * x**y would be better but closure compilere changes that to Math.pow
           * https://github.com/google/closure-compiler/issues/3684 */
          exponentiate: (x, y) => {
            const One = JSBI2.BigInt(1);
            let number = One;
            y = y > JSBI2.__ZERO ? y : -y;
            while (y > JSBI2.__ZERO) {
              if (y & One) {
                number = number * x;
              }
              y = y >> One;
              x = x * x;
            }
            return number;
          },
          powermod: (x, y, z) => {
            const One = JSBI2.BigInt(1);
            let number = One;
            y = y > JSBI2.__ZERO ? y : -y;
            while (y > JSBI2.__ZERO) {
              if (y & One) {
                number = number * x % z;
              }
              y = y >> One;
              x = x * x % z;
            }
            return number;
          },
          multiply: (x, y) => x * y,
          divide: (x, y) => x / y,
          remainder: (x, y) => x % y,
          add: (x, y) => x + y,
          subtract: (x, y) => x - y,
          leftShift: (x, y) => x << y,
          signedRightShift: (x, y) => x >> y,
          unsignedRightShift: (x, y) => x >>> y,
          // will raise TypeError
          lessThan: (x, y) => x < y,
          lessThanOrEqual: (x, y) => x <= y,
          greaterThan: (x, y) => x > y,
          greaterThanOrEqual: (x, y) => x >= y,
          equal: (x, y) => x === y,
          notEqual: (x, y) => x !== y
        });
      }
      JSBI2.__ZERO = JSBI2.BigInt(0);
      JSBI2.__MAX_SAFE = JSBI2.BigInt(Number.MAX_SAFE_INTEGER);
      JSBI2.__MIN_SAFE = JSBI2.BigInt(-Number.MAX_SAFE_INTEGER);
      JSBI2.numberIfSafe = (val) => JSBI2.lessThan(val, JSBI2.__MAX_SAFE) && JSBI2.greaterThan(val, JSBI2.__MIN_SAFE) ? JSBI2.toNumber(val) : val;
    }
  });

  // support/polyfills/es6.js
  var require_es6 = __commonJS({
    "support/polyfills/es6.js"() {
      [..."abc"].flat();
    }
  });

  // node_modules/setimmediate/setImmediate.js
  var require_setImmediate = __commonJS({
    "node_modules/setimmediate/setImmediate.js"(exports) {
      (function(global2, undefined2) {
        "use strict";
        if (global2.setImmediate) {
          return;
        }
        var nextHandle = 1;
        var tasksByHandle = {};
        var currentlyRunningATask = false;
        var doc = global2.document;
        var registerImmediate;
        function setImmediate(callback) {
          if (typeof callback !== "function") {
            callback = new Function("" + callback);
          }
          var args = new Array(arguments.length - 1);
          for (var i = 0; i < args.length; i++) {
            args[i] = arguments[i + 1];
          }
          var task = { callback, args };
          tasksByHandle[nextHandle] = task;
          registerImmediate(nextHandle);
          return nextHandle++;
        }
        function clearImmediate(handle) {
          delete tasksByHandle[handle];
        }
        function run(task) {
          var callback = task.callback;
          var args = task.args;
          switch (args.length) {
            case 0:
              callback();
              break;
            case 1:
              callback(args[0]);
              break;
            case 2:
              callback(args[0], args[1]);
              break;
            case 3:
              callback(args[0], args[1], args[2]);
              break;
            default:
              callback.apply(undefined2, args);
              break;
          }
        }
        function runIfPresent(handle) {
          if (currentlyRunningATask) {
            setTimeout(runIfPresent, 0, handle);
          } else {
            var task = tasksByHandle[handle];
            if (task) {
              currentlyRunningATask = true;
              try {
                run(task);
              } finally {
                clearImmediate(handle);
                currentlyRunningATask = false;
              }
            }
          }
        }
        function installNextTickImplementation() {
          registerImmediate = function(handle) {
            process.nextTick(function() {
              runIfPresent(handle);
            });
          };
        }
        function canUsePostMessage() {
          if (global2.postMessage && !global2.importScripts) {
            var postMessageIsAsynchronous = true;
            var oldOnMessage = global2.onmessage;
            global2.onmessage = function() {
              postMessageIsAsynchronous = false;
            };
            global2.postMessage("", "*");
            global2.onmessage = oldOnMessage;
            return postMessageIsAsynchronous;
          }
        }
        function installPostMessageImplementation() {
          var messagePrefix = "setImmediate$" + Math.random() + "$";
          var onGlobalMessage = function(event) {
            if (event.source === global2 && typeof event.data === "string" && event.data.indexOf(messagePrefix) === 0) {
              runIfPresent(+event.data.slice(messagePrefix.length));
            }
          };
          if (global2.addEventListener) {
            global2.addEventListener("message", onGlobalMessage, false);
          } else {
            global2.attachEvent("onmessage", onGlobalMessage);
          }
          registerImmediate = function(handle) {
            global2.postMessage(messagePrefix + handle, "*");
          };
        }
        function installMessageChannelImplementation() {
          var channel = new MessageChannel();
          channel.port1.onmessage = function(event) {
            var handle = event.data;
            runIfPresent(handle);
          };
          registerImmediate = function(handle) {
            channel.port2.postMessage(handle);
          };
        }
        function installReadyStateChangeImplementation() {
          var html = doc.documentElement;
          registerImmediate = function(handle) {
            var script = doc.createElement("script");
            script.onreadystatechange = function() {
              runIfPresent(handle);
              script.onreadystatechange = null;
              html.removeChild(script);
              script = null;
            };
            html.appendChild(script);
          };
        }
        function installSetTimeoutImplementation() {
          registerImmediate = function(handle) {
            setTimeout(runIfPresent, 0, handle);
          };
        }
        var attachTo = Object.getPrototypeOf && Object.getPrototypeOf(global2);
        attachTo = attachTo && attachTo.setTimeout ? attachTo : global2;
        if ({}.toString.call(global2.process) === "[object process]") {
          installNextTickImplementation();
        } else if (canUsePostMessage()) {
          installPostMessageImplementation();
        } else if (global2.MessageChannel) {
          installMessageChannelImplementation();
        } else if (doc && "onreadystatechange" in doc.createElement("script")) {
          installReadyStateChangeImplementation();
        } else {
          installSetTimeoutImplementation();
        }
        attachTo.setImmediate = setImmediate;
        attachTo.clearImmediate = clearImmediate;
      })(typeof self === "undefined" ? typeof global === "undefined" ? exports : global : self);
    }
  });

  // src/assert-dev.js
  var require_assert_dev = __commonJS({
    "src/assert-dev.js"() {
      Sk.asserts = { ENABLE_ASSERTS: true };
      Sk.asserts.assert = function(condition, message) {
        if (Sk.asserts.ENABLE_ASSERTS && !condition) {
          var msg = "Assertion failure";
          if (message) {
            msg = msg + ": " + message;
          }
          throw new Error(msg);
        }
        return condition;
      };
      Sk.exportSymbol("Sk.asserts.assert", Sk.asserts.assert);
      Sk.asserts.fail = function(message) {
        if (Sk.asserts.ENABLE_ASSERTS) {
          var msg = "Assertion failure";
          if (message) {
            msg = msg + ": " + message;
          }
          throw new Error(msg);
        }
      };
      Sk.exportSymbol("Sk.asserts.fail", Sk.asserts.fail);
    }
  });

  // src/env.js
  var require_env = __commonJS({
    "src/env.js"() {
      Sk.bool_check = function(variable, name) {
        if (variable === void 0 || variable === null || typeof variable !== "boolean") {
          throw new Error("must specify " + name + " and it must be a boolean");
        }
      };
      Sk.python2 = {
        print_function: false,
        division: false,
        absolute_import: null,
        unicode_literals: false,
        // skulpt specific
        python3: false,
        class_repr: false,
        inherit_from_object: false,
        super_args: false,
        octal_number_literal: false,
        bankers_rounding: false,
        python_version: false,
        dunder_next: false,
        dunder_round: false,
        exceptions: false,
        no_long_type: false,
        ceil_floor_int: false,
        silent_octal_literal: true
      };
      Sk.python3 = {
        print_function: true,
        division: true,
        absolute_import: null,
        unicode_literals: true,
        // skulpt specific
        python3: true,
        class_repr: true,
        inherit_from_object: true,
        super_args: true,
        octal_number_literal: true,
        bankers_rounding: true,
        python_version: true,
        dunder_next: true,
        dunder_round: true,
        exceptions: true,
        no_long_type: true,
        ceil_floor_int: true,
        silent_octal_literal: false
      };
      Sk.configure = function(options) {
        "use strict";
        Sk.output = options["output"] || Sk.output;
        Sk.asserts.assert(typeof Sk.output === "function");
        Sk.debugout = options["debugout"] || Sk.debugout;
        Sk.asserts.assert(typeof Sk.debugout === "function");
        Sk.uncaughtException = options["uncaughtException"] || Sk.uncaughtException;
        Sk.asserts.assert(typeof Sk.uncaughtException === "function");
        Sk.read = options["read"] || Sk.read;
        Sk.asserts.assert(typeof Sk.read === "function");
        Sk.nonreadopen = options["nonreadopen"] || false;
        Sk.asserts.assert(typeof Sk.nonreadopen === "boolean");
        Sk.fileopen = options["fileopen"] || void 0;
        Sk.asserts.assert(typeof Sk.fileopen === "function" || typeof Sk.fileopen === "undefined");
        Sk.filewrite = options["filewrite"] || void 0;
        Sk.asserts.assert(typeof Sk.filewrite === "function" || typeof Sk.filewrite === "undefined");
        Sk.timeoutMsg = options["timeoutMsg"] || Sk.timeoutMsg;
        Sk.asserts.assert(typeof Sk.timeoutMsg === "function");
        Sk.exportSymbol("Sk.timeoutMsg", Sk.timeoutMsg);
        Sk.sysargv = options["sysargv"] || Sk.sysargv;
        Sk.asserts.assert(Sk.isArrayLike(Sk.sysargv));
        Sk.__future__ = options["__future__"] || Sk.python3;
        Sk.bool_check(Sk.__future__.print_function, "Sk.__future__.print_function");
        Sk.bool_check(Sk.__future__.division, "Sk.__future__.division");
        Sk.bool_check(Sk.__future__.unicode_literals, "Sk.__future__.unicode_literals");
        Sk.bool_check(Sk.__future__.class_repr, "Sk.__future__.class_repr");
        Sk.bool_check(Sk.__future__.inherit_from_object, "Sk.__future__.inherit_from_object");
        Sk.bool_check(Sk.__future__.super_args, "Sk.__future__.super_args");
        Sk.bool_check(Sk.__future__.octal_number_literal, "Sk.__future__.octal_number_literal");
        Sk.bool_check(Sk.__future__.bankers_rounding, "Sk.__future__.bankers_rounding");
        Sk.bool_check(Sk.__future__.python_version, "Sk.__future__.python_version");
        Sk.bool_check(Sk.__future__.dunder_next, "Sk.__future__.dunder_next");
        Sk.bool_check(Sk.__future__.dunder_round, "Sk.__future__.dunder_round");
        Sk.bool_check(Sk.__future__.exceptions, "Sk.__future__.exceptions");
        Sk.bool_check(Sk.__future__.no_long_type, "Sk.__future__.no_long_type");
        Sk.bool_check(Sk.__future__.ceil_floor_int, "Sk.__future__.ceil_floor_int");
        Sk.bool_check(Sk.__future__.silent_octal_literal, "Sk.__future__.silent_octal_literal");
        Sk.imageProxy = options["imageProxy"] || "http://localhost:8080/320x";
        Sk.asserts.assert(typeof Sk.imageProxy === "string" || typeof Sk.imageProxy === "function");
        Sk.BottleSiteTarget = options["BottleSiteTarget"] || "#website";
        Sk.asserts.assert(
          typeof Sk.BottleSiteTarget === "string" || typeof Sk.BottleSiteTarget === "function"
        );
        Sk.inputfun = options["inputfun"] || Sk.inputfun;
        Sk.asserts.assert(typeof Sk.inputfun === "function");
        Sk.inputfunTakesPrompt = options["inputfunTakesPrompt"] || false;
        Sk.asserts.assert(typeof Sk.inputfunTakesPrompt === "boolean");
        Sk.retainGlobals = options["retainglobals"] || options["retainGlobals"] || false;
        Sk.asserts.assert(typeof Sk.retainGlobals === "boolean");
        Sk.debugging = options["debugging"] || false;
        Sk.asserts.assert(typeof Sk.debugging === "boolean");
        Sk.killableWhile = options["killableWhile"] || false;
        Sk.asserts.assert(typeof Sk.killableWhile === "boolean");
        Sk.killableFor = options["killableFor"] || false;
        Sk.asserts.assert(typeof Sk.killableFor === "boolean");
        Sk.signals = typeof options["signals"] !== "undefined" ? options["signals"] : null;
        if (Sk.signals === true) {
          Sk.signals = {
            listeners: [],
            addEventListener(handler) {
              Sk.signals.listeners.push(handler);
            },
            removeEventListener(handler) {
              var index = Sk.signals.listeners.indexOf(handler);
              if (index >= 0) {
                Sk.signals.listeners.splice(index, 1);
              }
            },
            signal(signal, data) {
              for (var i = 0; i < Sk.signals.listeners.length; i++) {
                Sk.signals.listeners[i].call(null, signal, data);
              }
            }
          };
        } else {
          Sk.signals = null;
        }
        Sk.asserts.assert(typeof Sk.signals === "object");
        Sk.breakpoints = options["breakpoints"] || function() {
          return true;
        };
        Sk.asserts.assert(typeof Sk.breakpoints === "function");
        Sk.setTimeout = options["setTimeout"];
        if (Sk.setTimeout === void 0) {
          if (typeof setTimeout === "function") {
            Sk.setTimeout = function(func, delay) {
              setTimeout(func, delay);
            };
          } else {
            Sk.setTimeout = function(func, delay) {
              func();
            };
          }
        }
        Sk.asserts.assert(typeof Sk.setTimeout === "function");
        if ("execLimit" in options) {
          Sk.execLimit = options["execLimit"];
        }
        if ("yieldLimit" in options) {
          Sk.yieldLimit = options["yieldLimit"];
        }
        if (options["syspath"]) {
          Sk.syspath = options["syspath"];
          Sk.asserts.assert(Sk.isArrayLike(Sk.syspath));
          Sk.realsyspath = void 0;
          Sk.sysmodules = new Sk.builtin.dict([]);
        }
        Sk.misceval.softspace_ = false;
        Sk.switch_version(Sk.__future__.python3);
        Sk.builtin.str.$next = Sk.__future__.python3 ? new Sk.builtin.str("__next__") : new Sk.builtin.str("next");
        Sk.setupOperators(Sk.__future__.python3);
        Sk.setupDunderMethods(Sk.__future__.python3);
        Sk.setupObjects(Sk.__future__.python3);
      };
      Sk.exportSymbol("Sk.configure", Sk.configure);
      Sk.uncaughtException = function(err) {
        throw err;
      };
      Sk.uncaughtException = function(err) {
        throw err;
      };
      Sk.exportSymbol("Sk.uncaughtException", Sk.uncaughtException);
      Sk.timeoutMsg = function() {
        return "Program exceeded run time limit.";
      };
      Sk.exportSymbol("Sk.timeoutMsg", Sk.timeoutMsg);
      Sk.execPaused = 0;
      Sk.execPausedAmount = 0;
      Sk.execLimit = Number.POSITIVE_INFINITY;
      Sk.yieldLimit = Number.POSITIVE_INFINITY;
      Sk.execStack = [];
      Sk.output = function(x) {
      };
      Sk.read = function(x) {
        if (Sk.builtinFiles === void 0 || Sk.builtinFiles["files"][x] === void 0) {
          throw "File not found: '" + x + "'";
        }
        return Sk.builtinFiles["files"][x];
      };
      Sk.sysargv = [];
      Sk.getSysArgv = function() {
        return Sk.sysargv;
      };
      Sk.exportSymbol("Sk.getSysArgv", Sk.getSysArgv);
      Sk.syspath = [];
      Sk.inBrowser = Sk.global["document"] !== void 0;
      Sk.afterSingleExecution = function(args) {
      };
      Sk.exportSymbol("Sk.afterSingleExecution", Sk.afterSingleExecution);
      Sk.debugout = function(args) {
      };
      (function() {
        if (Sk.global["write"] !== void 0) {
          Sk.output = Sk.global["write"];
        } else if (Sk.global["console"] !== void 0 && Sk.global["console"]["log"] !== void 0) {
          Sk.output = function(x) {
            Sk.global["console"]["log"](x);
          };
        } else if (Sk.global["print"] !== void 0) {
          Sk.output = Sk.global["print"];
        }
        if (Sk.global["console"] !== void 0 && Sk.global["console"]["log"] !== void 0) {
          Sk.debugout = function(x) {
            Sk.global["console"]["log"](x);
          };
        } else if (Sk.global["print"] !== void 0) {
          Sk.debugout = Sk.global["print"];
        }
      })();
      Sk.inputfun = function(args) {
        return window.prompt(args);
      };
      Sk.setup_method_mappings = function() {
      };
      Sk.setupDictIterators = function(python3) {
      };
      Sk.switch_version = function(py3) {
        const methods_to_map = {
          float_: {
            method_names: ["__round__"],
            2: [false],
            3: [true]
          },
          int_: {
            method_names: ["__round__"],
            2: [false],
            3: [true]
          },
          list: {
            method_names: ["clear", "copy", "sort"],
            2: [false, false, true],
            3: [true, true, true]
          },
          dict: {
            method_names: ["has_key", "keys", "items", "values"],
            2: [true, true, true, true],
            3: [false, true, true, true]
          }
        };
        for (let klass_name in methods_to_map) {
          const klass = Sk.builtin[klass_name];
          const method_names = methods_to_map[klass_name].method_names;
          const in_py3 = methods_to_map[klass_name][3];
          if (py3 && klass.py3$methods === void 0) {
            return;
          } else if (klass.py3$methods === void 0) {
            klass.py3$methods = {};
            for (let i = 0; i < method_names.length; i++) {
              const method_name = method_names[i];
              if (!in_py3[i]) {
                continue;
              }
              klass.py3$methods[method_name] = klass.prototype[method_name].d$def;
            }
          }
          let in_version, new_methods;
          if (py3) {
            in_version = in_py3;
            new_methods = klass.py3$methods;
          } else {
            in_version = methods_to_map[klass_name][2];
            new_methods = klass.py2$methods;
          }
          for (let i = 0; i < method_names.length; i++) {
            const method_name = method_names[i];
            delete klass.prototype[method_name];
            if (in_version[i]) {
              klass.prototype[method_name] = new Sk.builtin.method_descriptor(
                klass,
                new_methods[method_name]
              );
            }
          }
        }
      };
      Sk.exportSymbol("Sk.__future__", Sk.__future__);
      Sk.exportSymbol("Sk.inputfun", Sk.inputfun);
    }
  });

  // src/type.js
  var require_type = __commonJS({
    "src/type.js"() {
      if (Sk.builtin === void 0) {
        Sk.builtin = {};
      }
      Sk.builtin.type = function type(obj) {
        if (this instanceof Sk.builtin.type) {
          Sk.asserts.fail("calling new Sk.builtin.type is not safe");
        }
        return obj.ob$type;
      };
      Object.defineProperties(
        Sk.builtin.type.prototype,
        /**@lends {Sk.builtin.type.prototype}*/
        {
          call: { value: Function.prototype.call },
          apply: { value: Function.prototype.apply },
          tp$slots: {
            value: {
              tp$doc: "type(object_or_name, bases, dict)\ntype(object) -> the object's type\ntype(name, bases, dict) -> a new type",
              tp$call,
              tp$new,
              tp$getattr,
              tp$setattr,
              $r
            },
            writable: true
          },
          tp$methods: { value: null, writable: true },
          // define these later
          tp$getsets: { value: null, writable: true },
          sk$type: { value: true },
          $isSubType: { value: $isSubType },
          $allocateSlot: { value: $allocateSlot },
          $allocateSlots: { value: $allocateSlots },
          $allocateGetterSlot: { value: $allocateGetterSlot },
          $typeLookup: { value: $typeLookup, writable: true },
          $mroMerge: { value: $mroMerge },
          $buildMRO: { value: $buildMRO },
          sk$attrError: {
            value() {
              return "type object '" + this.prototype.tp$name + "'";
            },
            writable: true
          }
        }
      );
      function tp$call(args, kwargs) {
        if (this === Sk.builtin.type) {
          if (args.length === 1 && (kwargs === void 0 || !kwargs.length)) {
            return args[0].ob$type;
          } else if (args.length !== 3) {
            throw new Sk.builtin.TypeError("type() takes 1 or 3 arguments");
          }
        }
        let obj = this.prototype.tp$new(args, kwargs);
        if (obj.$isSuspension) {
          return Sk.misceval.chain(
            obj,
            (o) => {
              obj = o;
              if (!obj.ob$type.$isSubType(this)) {
                return;
              }
              return obj.tp$init(args, kwargs);
            },
            () => obj
          );
        } else if (!obj.ob$type.$isSubType(this)) {
          return obj;
        } else {
          const res = obj.tp$init(args, kwargs);
          if (res !== void 0 && res.$isSuspension) {
            return Sk.misceval.chain(res, () => obj);
          }
          return obj;
        }
      }
      function tp$new(args, kwargs) {
        if (args.length !== 3) {
          if (args.length === 1 && (kwargs === void 0 || !kwargs.length)) {
            return args[0].ob$type;
          }
          throw new Sk.builtin.TypeError("type() takes 1 or 3 arguments");
        }
        let $name, bases, dict;
        $name = args[0];
        bases = args[1];
        dict = args[2];
        if (dict.tp$name !== "dict") {
          throw new Sk.builtin.TypeError(
            "type() argument 3 must be dict, not " + Sk.abstr.typeName(dict)
          );
        }
        if (!Sk.builtin.checkString($name)) {
          throw new Sk.builtin.TypeError(
            "type() argument 1 must be str, not " + Sk.abstr.typeName($name)
          );
        }
        $name = $name.$jsstr();
        if (bases.tp$name !== "tuple") {
          throw new Sk.builtin.TypeError(
            "type() argument 2 must be tuple, not " + Sk.abstr.typeName(bases)
          );
        }
        bases = bases.sk$asarray();
        const klass = function() {
          this.$d = new Sk.builtin.dict();
        };
        setUpKlass($name, klass, bases, this.constructor);
        if (Sk.globals) {
          klass.prototype.__module__ = Sk.globals["__name__"];
        }
        klass.prototype.__doc__ = Sk.builtin.none.none$;
        if (klass.$typeLookup(Sk.builtin.str.$dict) === void 0) {
          klass.prototype.__dict__ = new Sk.builtin.getset_descriptor(
            klass,
            subtype_dict_getset_description
          );
        }
        dict.$items().forEach(([key, val]) => {
          klass.prototype[key.$mangled] = val;
        });
        if (klass.prototype.hasOwnProperty("__qualname__")) {
          const qualname = klass.prototype.__qualname__;
          if (!Sk.builtin.checkString(qualname)) {
            throw new Sk.builtin.TypeError(
              "type __qualname__ must be a str, not '" + Sk.abstr.typeName(qualname) + "'"
            );
          }
          klass.prototype.ht$qualname = qualname;
        }
        const proto = klass.prototype;
        overrideImplied(proto, "__new__", "staticmethod");
        overrideImplied(proto, "__class_getitem__", "classmethod");
        klass.$allocateSlots();
        return klass;
      }
      function overrideImplied(proto, dunder, implied) {
        if (proto.hasOwnProperty(dunder)) {
          const fn = proto[dunder];
          if (fn instanceof Sk.builtin.func) {
            proto[dunder] = new Sk.builtin[implied](fn);
          }
        }
      }
      function $r() {
        let mod = this.prototype.__module__;
        let cname = "";
        let ctype = "class";
        if (mod && Sk.builtin.checkString(mod)) {
          cname = mod.v + ".";
        } else {
          mod = null;
        }
        if (!mod && !this.sk$klass && !Sk.__future__.class_repr) {
          ctype = "type";
        }
        return new Sk.builtin.str("<" + ctype + " '" + cname + this.prototype.tp$name + "'>");
      }
      function tp$getattr(pyName, canSuspend) {
        let res;
        const metatype = this.ob$type;
        const meta_attribute = metatype.$typeLookup(pyName);
        let meta_get;
        if (meta_attribute !== void 0) {
          meta_get = meta_attribute.tp$descr_get;
          if (meta_get !== void 0 && meta_attribute.tp$descr_set !== void 0) {
            res = meta_get.call(meta_attribute, this, metatype, canSuspend);
            return res;
          }
        }
        const attribute = this.$typeLookup(pyName);
        if (attribute !== void 0) {
          const local_get = attribute.tp$descr_get;
          if (local_get !== void 0) {
            res = local_get.call(attribute, null, this, canSuspend);
            return res;
          }
          return attribute;
        }
        if (meta_get !== void 0) {
          res = meta_get.call(meta_attribute, this, metatype, canSuspend);
          return res;
        }
        if (meta_attribute !== void 0) {
          return meta_attribute;
        }
        return;
      }
      function tp$setattr(pyName, value, canSuspend) {
        if (!this.sk$klass) {
          if (value !== void 0) {
            throw new Sk.builtin.TypeError(
              "can't set attributes of built-in/extension type '" + this.prototype.tp$name + "'"
            );
          } else {
            throw new Sk.builtin.TypeError(
              "can't delete attributes on type object '" + this.prototype.tp$name + "'"
            );
          }
        }
        const descr = this.ob$type.$typeLookup(pyName);
        if (descr !== void 0) {
          const f = descr.tp$descr_set;
          if (f) {
            return f.call(descr, this, value, canSuspend);
          }
        }
        const jsName = pyName.$mangled;
        if (value === void 0) {
          const proto = this.prototype;
          if (!proto.hasOwnProperty(jsName)) {
            throw new Sk.builtin.AttributeError(
              "type object '" + this.prototype.tp$name + "' has no attribute '" + pyName.$jsstr() + "'"
            );
          } else {
            delete proto[jsName];
            const slot_name = Sk.dunderToSkulpt[jsName];
            if (slot_name !== void 0) {
              delete this.prototype[slot_name];
              if (!proto.sk$prototypical) {
                this.$allocateGetterSlot(jsName);
              }
            }
          }
        } else {
          this.prototype[jsName] = value;
          if (jsName in Sk.dunderToSkulpt) {
            this.$allocateSlot(jsName, value);
          }
        }
      }
      function fastLookup(pyName) {
        var jsName = pyName.$mangled;
        return this.prototype[jsName];
      }
      function slowLookup(pyName) {
        var jsName = pyName.$mangled;
        const mro = this.prototype.tp$mro;
        for (let i = 0; i < mro.length; ++i) {
          const base_proto = mro[i].prototype;
          if (base_proto.hasOwnProperty(jsName)) {
            return base_proto[jsName];
          }
        }
        return void 0;
      }
      function $typeLookup(pyName) {
        if (this.prototype.sk$prototypical) {
          return fastLookup.call(this, pyName);
        }
        return slowLookup.call(this, pyName);
      }
      function $isSubType(other) {
        return this === other || this.prototype instanceof other || !this.prototype.sk$prototypical && this.prototype.tp$mro.includes(other);
      }
      function setUpKlass($name, klass, bases, meta) {
        const best_base = best_base_(bases);
        const klass_proto = klass.prototype;
        Sk.abstr.setUpInheritance($name, klass, best_base, meta);
        const pyName = new Sk.builtin.str($name);
        Object.defineProperties(klass_proto, {
          sk$prototypical: { value: true, writable: true },
          tp$bases: { value: bases, writable: true },
          tp$mro: { value: null, writable: true },
          ht$type: { value: true, writable: true },
          ht$name: { value: pyName, writable: true },
          ht$qualname: { value: pyName, writable: true }
        });
        klass_proto.tp$mro = klass.$buildMRO();
        Object.defineProperties(klass, {
          $typeLookup: {
            value: klass_proto.sk$prototypical ? fastLookup : slowLookup,
            writable: true
          },
          sk$klass: { value: true, writable: true }
        });
      }
      function best_base_(bases) {
        if (bases.length === 0) {
          bases.push(Sk.builtin.object);
        }
        function solid_base(type) {
          if (type.sk$solidBase) {
            return type;
          }
          return solid_base(type.prototype.tp$base);
        }
        let base, winner, candidate, base_i;
        for (let i = 0; i < bases.length; i++) {
          base_i = bases[i];
          if (!Sk.builtin.checkClass(base_i)) {
            throw new Sk.builtin.TypeError("bases must be 'type' objects");
          } else if (base_i.sk$unacceptableBase) {
            throw new Sk.builtin.TypeError(
              "type '" + base_i.prototype.tp$name + "' is not an acceptable base type"
            );
          }
          candidate = solid_base(base_i);
          if (winner === void 0) {
            winner = candidate;
            base = base_i;
          } else if (winner.$isSubType(candidate)) {
          } else if (candidate.$isSubType(winner)) {
            winner = candidate;
            base = base_i;
          } else {
            throw new Sk.builtin.TypeError("multiple bases have instance layout conflicts");
          }
        }
        return base;
      }
      function $mroMerge(seqs) {
        this.prototype.sk$prototypical = true;
        let seq, i, j;
        const res = [];
        for (; ; ) {
          for (i = 0; i < seqs.length; ++i) {
            seq = seqs[i];
            if (seq.length !== 0) {
              break;
            }
          }
          if (i === seqs.length) {
            return res;
          }
          const cands = [];
          for (i = 0; i < seqs.length; ++i) {
            seq = seqs[i];
            if (seq.length !== 0) {
              const cand = seq[0];
              OUTER: for (j = 0; j < seqs.length; ++j) {
                const sseq = seqs[j];
                for (let k = 1; k < sseq.length; ++k) {
                  if (sseq[k] === cand) {
                    break OUTER;
                  }
                }
              }
              if (j === seqs.length) {
                cands.push(cand);
              }
            }
          }
          if (cands.length === 0) {
            throw new Sk.builtin.TypeError("Inconsistent precedences in type hierarchy");
          }
          const next = cands[0];
          if (res.length && this.prototype.sk$prototypical) {
            let prevs_prototype = Object.getPrototypeOf(res[res.length - 1].prototype);
            if (prevs_prototype !== next.prototype) {
              this.prototype.sk$prototypical = false;
            }
          }
          res.push(next);
          for (i = 0; i < seqs.length; ++i) {
            seq = seqs[i];
            if (seq.length > 0 && seq[0] === next) {
              seq.splice(0, 1);
            }
          }
        }
      }
      function $buildMRO() {
        const all = [[this]];
        const kbases = this.prototype.tp$bases;
        for (let i = 0; i < kbases.length; ++i) {
          all.push([...kbases[i].prototype.tp$mro]);
        }
        const bases = [];
        for (let i = 0; i < kbases.length; ++i) {
          bases.push(kbases[i]);
        }
        all.push(bases);
        return this.$mroMerge(all);
      }
      function $allocateSlots() {
        const proto = this.prototype;
        if (this.prototype.sk$prototypical) {
          Object.keys(proto).forEach((dunder) => {
            if (dunder in Sk.slots) {
              this.$allocateSlot(dunder, proto[dunder]);
            }
          });
        } else {
          Object.keys(Sk.slots).forEach((dunder) => {
            if (proto.hasOwnProperty(dunder)) {
              this.$allocateSlot(dunder, proto[dunder]);
            } else {
              this.$allocateGetterSlot(dunder);
            }
          });
        }
      }
      function $allocateSlot(dunder, dunderFunc) {
        const slot_def = Sk.slots[dunder];
        const slot_name = slot_def.$slot_name;
        const proto = this.prototype;
        if (proto.hasOwnProperty(slot_name)) {
          delete proto[slot_name];
        }
        proto[slot_name] = slot_def.$slot_func(dunderFunc);
      }
      function $allocateGetterSlot(dunder) {
        const slot_name = Sk.slots[dunder].$slot_name;
        const proto = this.prototype;
        if (proto.hasOwnProperty(slot_name)) {
          return;
        }
        Object.defineProperty(proto, slot_name, {
          configurable: true,
          get() {
            const mro = proto.tp$mro;
            for (let i = 1; i < mro.length; i++) {
              const base_proto = mro[i].prototype;
              const property = Object.getOwnPropertyDescriptor(base_proto, slot_name);
              if (property !== void 0 && property.value) {
                return property.value;
              }
            }
          }
        });
      }
      Sk.builtin.type.prototype.tp$getsets = {
        __base__: {
          $get() {
            return this.prototype.tp$base || Sk.builtin.none.none$;
          }
        },
        __bases__: {
          $get() {
            if (this.sk$tuple_bases === void 0) {
              this.sk$tuple_bases = new Sk.builtin.tuple(this.prototype.tp$bases);
            }
            return this.sk$tuple_bases;
          }
        },
        __mro__: {
          $get() {
            if (this.sk$tuple_mro === void 0) {
              this.sk$tuple_mro = new Sk.builtin.tuple(this.prototype.tp$mro);
            }
            return this.sk$tuple_mro;
          }
        },
        __dict__: {
          $get() {
            return new Sk.builtin.mappingproxy(this.prototype);
          }
        },
        __doc__: {
          $get() {
            const doc = this.$typeLookup(Sk.builtin.str.$doc);
            if (doc) {
              if (doc.tp$descr_get !== void 0) {
                if (this === Sk.builtin.type) {
                  return new Sk.builtin.str(this.prototype.tp$doc);
                }
                return doc.tp$descr_get(null, this);
              }
              return this.prototype.__doc__;
            }
            return Sk.builtin.none.none$;
          },
          $set(value) {
            check_special_type_attr(this, value, Sk.builtin.str.$doc);
            this.prototype.__doc__ = value;
          }
        },
        __name__: {
          $get() {
            let name = this.prototype.ht$name;
            if (name !== void 0) {
              return new Sk.builtin.str(name);
            }
            name = this.prototype.tp$name;
            if (name.includes(".")) {
              name = name.slice(name.lastIndexOf(".") + 1);
            }
            return new Sk.builtin.str(name);
          },
          $set(value) {
            check_special_type_attr(this, value, Sk.builtin.str.$name);
            if (!Sk.builtin.checkString(value)) {
              throw new Sk.builtin.TypeError(
                "can only assign string to " + this.prototype.tp$name + ".__name__, not '" + Sk.abstr.typeName(value) + "'"
              );
            }
            this.prototype.ht$name = value;
            this.prototype.tp$name = value.$jsstr();
          }
        },
        __qualname__: {
          $get() {
            return this.prototype.ht$qualname || Sk.abstr.lookupSpecial(this, Sk.builtin.str.$name);
          },
          $set(value) {
            check_special_type_attr(this, value, Sk.builtin.str.$name);
            if (!Sk.builtin.checkString(value)) {
              throw new Sk.builtin.TypeError(
                "can only assign string to " + this.prototype.tp$name + ".__qualname__, not '" + Sk.abstr.typeName(value) + "'"
              );
            }
            this.prototype.ht$qualname = value;
          }
        },
        __module__: {
          $get() {
            const typeproto = this.prototype;
            const mod = typeproto.__module__;
            if (mod && !(mod.ob$type === Sk.builtin.getset_descriptor)) {
              return mod;
            }
            if (typeproto.tp$name.includes(".")) {
              return new Sk.builtin.str(
                typeproto.tp$name.slice(0, typeproto.tp$name.lastIndexOf("."))
              );
            }
            return new Sk.builtin.str("builtins");
          },
          $set(value) {
            check_special_type_attr(this, value, Sk.builtin.str.$module);
            this.prototype.__module__ = value;
          }
        }
      };
      Sk.builtin.type.prototype.tp$methods = /**@lends {Sk.builtin.type.prototype}*/
      {
        mro: {
          $meth() {
            return new Sk.builtin.list(this.$buildMRO());
          },
          $flags: { NoArgs: true }
        },
        __dir__: {
          $meth: function __dir__() {
            const seen = /* @__PURE__ */ new Set();
            const dir = [];
            function push_or_continue(attr) {
              if (attr in Sk.reservedWords_) {
                return;
              }
              attr = Sk.unfixReserved(attr);
              if (attr.indexOf("$") !== -1) {
                return;
              }
              if (!seen.has(attr)) {
                seen.add(attr);
                dir.push(new Sk.builtin.str(attr));
              }
            }
            if (this.prototype.sk$prototypical) {
              for (let attr in this.prototype) {
                push_or_continue(attr);
              }
            } else {
              const mro = this.prototype.tp$mro;
              for (let i = 0; i < mro.length; i++) {
                const attrs = Object.getOwnPropertyNames(mro[i].prototype);
                for (let j = 0; j < attrs.length; j++) {
                  push_or_continue(attrs[j]);
                }
              }
            }
            return new Sk.builtin.list(dir);
          },
          $flags: { NoArgs: true },
          $doc: "Specialized __dir__ implementation for types."
        }
      };
      var subtype_dict_getset_description = {
        $get() {
          const dict_descr = get_dict_descr_of_builtn_base(this.ob$type);
          if (dict_descr !== void 0) {
            return dict_descr.tp$descr_get(this, this.ob$type);
          }
          return Sk.generic.getSetDict.$get.call(this);
        },
        $set(value) {
          const dict_descr = get_dict_descr_of_builtn_base(this.ob$type);
          if (dict_descr !== void 0) {
            return dict_descr.tp$descr_set(this, value);
          }
          if (value === void 0) {
            this.$d = new Sk.builtin.dict([]);
          } else {
            return Sk.generic.getSetDict.$set.call(this, value);
          }
        },
        $doc: "dictionary for instance variables (if defined)",
        $name: "__dict__"
      };
      function get_dict_descr_of_builtn_base(type) {
        while (type.prototype.tp$base !== null) {
          if (type.sk$klass === void 0) {
            if (type.prototype.hasOwnProperty("__dict__")) {
              const descr = type.prototype.__dict__;
              return Sk.builtin.checkDataDescr(descr) ? descr : void 0;
            }
          }
          type = type.prototype.tp$base;
        }
      }
      function check_special_type_attr(type, value, pyName) {
        if (type.sk$klass === void 0) {
          throw new Sk.builtin.TypeError(
            "can't set " + type.prototype.tp$name + "." + pyName.$jsstr()
          );
        }
        if (value === void 0) {
          throw new Sk.builtin.TypeError(
            "can't delete " + type.prototype.tp$name + "." + pyName.$jsstr()
          );
        }
      }
    }
  });

  // src/generic.js
  var require_generic = __commonJS({
    "src/generic.js"() {
      Sk.generic = {};
      Sk.generic.getAttr = function __getattribute__(pyName, canSuspend) {
        let f;
        const type = this.ob$type;
        const descr = type.$typeLookup(pyName);
        if (descr !== void 0) {
          f = descr.tp$descr_get;
          if (f !== void 0 && descr.tp$descr_set !== void 0) {
            return f.call(descr, this, type, canSuspend);
          }
        }
        const dict = this.$d;
        if (dict !== void 0) {
          const res = dict.quick$lookup(pyName);
          if (res !== void 0) {
            return res;
          }
        }
        if (f !== void 0) {
          return f.call(descr, this, type, canSuspend);
        }
        if (descr !== void 0) {
          return descr;
        }
        return;
      };
      Sk.exportSymbol("Sk.generic.getAttr", Sk.generic.getAttr);
      Sk.generic.setAttr = function __setattr__(pyName, value, canSuspend) {
        const descr = this.ob$type.$typeLookup(pyName);
        if (descr !== void 0 && descr !== null) {
          const f = descr.tp$descr_set;
          if (f) {
            return f.call(descr, this, value, canSuspend);
          }
        }
        const dict = this.$d;
        if (dict !== void 0) {
          if (dict.mp$ass_subscript) {
            if (value !== void 0) {
              return dict.mp$ass_subscript(pyName, value);
            } else {
              try {
                return dict.mp$ass_subscript(pyName);
              } catch (e) {
                if (e instanceof Sk.builtin.KeyError) {
                  throw new Sk.builtin.AttributeError(
                    "'" + Sk.abstr.typeName(this) + "' object has no attribute '" + pyName.$jsstr() + "'"
                  );
                }
                throw e;
              }
            }
          } else if (typeof dict === "object") {
            const jsMangled = pyName.$mangled;
            if (value !== void 0) {
              dict[jsMangled] = value;
              return;
            } else if (dict[jsMangled] !== void 0) {
              delete dict[jsMangled];
              return;
            }
          }
        }
        throw new Sk.builtin.AttributeError(
          this.sk$attrError() + " has no attribute '" + pyName.$jsstr() + "'"
        );
      };
      Sk.exportSymbol("Sk.generic.setAttr", Sk.generic.setAttr);
      Sk.generic.new = function(builtin) {
        const genericNew = function __new__(args, kwargs) {
          if (this.constructor === builtin) {
            return new this.constructor();
          } else {
            const instance = new this.constructor();
            builtin.call(instance);
            return instance;
          }
        };
        return genericNew;
      };
      Sk.generic.newMethodDef = {
        $meth(args, kwargs) {
          let this_name, subs_name;
          const native_type_proto = this.prototype;
          if (args.length < 1) {
            this_name = native_type_proto.tp$name;
            throw new Sk.builtin.TypeError(this_name + ".__new__(): not enough arguments");
          }
          const subtype = args.shift();
          if (subtype.sk$type === void 0) {
            this_name = native_type_proto.tp$name;
            throw new Sk.builtin.TypeError(
              this_name + "__new__(X): X is not a type object (" + Sk.abstr.typeName(subtype) + ")"
            );
          }
          if (!subtype.$isSubType(this)) {
            this_name = native_type_proto.tp$name;
            subs_name = subtype.prototype.tp$name;
            throw new Sk.builtin.TypeError(
              this_name + ".__new__(" + subs_name + "): " + subs_name + " is not a subtype of " + this_name
            );
          }
          const static_proto = subtype.prototype.sk$staticNew.prototype;
          if (static_proto.tp$new !== native_type_proto.tp$new) {
            this_name = native_type_proto.tp$name;
            subs_name = subtype.prototype.tp$name;
            const suitable = static_proto.tp$name;
            throw new Sk.builtin.TypeError(
              this_name + ".__new__(" + subs_name + ") is not safe, use " + suitable + ".__new__()"
            );
          }
          return native_type_proto.tp$new.call(subtype.prototype, args, kwargs);
        },
        $flags: { FastCall: true },
        $textsig: "($type, *args, **kwargs)",
        $name: "__new__"
      };
      Sk.generic.selfIter = function __iter__() {
        return this;
      };
      Sk.generic.iterNextWithArrayCheckSize = function __next__() {
        if (this.$seq.length !== this.$orig.get$size()) {
          const error_name = this.tp$name.split("_")[0];
          throw new Sk.builtin.RuntimeError(error_name + " changed size during iteration");
        } else if (this.$index >= this.$seq.length) {
          return void 0;
        }
        return this.$seq[this.$index++];
      };
      Sk.generic.iterNextWithArray = function __next__() {
        const next = this.$seq[this.$index++];
        if (next === void 0) {
          this.tp$iternext = () => void 0;
        }
        return next;
      };
      Sk.generic.iterLengthHintWithArrayMethodDef = {
        $meth: function __length_hint__() {
          return new Sk.builtin.int_(this.$seq.length - this.$index);
        },
        $flags: { NoArgs: true }
      };
      Sk.generic.iterReverseLengthHintMethodDef = {
        $meth: function __length_hint__() {
          return new Sk.builtin.int_(this.$index);
        },
        $flags: { NoArgs: true }
      };
      Sk.generic.getSetDict = {
        $get() {
          return this.$d;
        },
        $set(value) {
          if (value === void 0) {
            throw new Sk.builtin.TypeError("cannot delete __dict__");
          } else if (value instanceof Sk.builtin.dict) {
            this.$d = value;
          } else {
            throw new Sk.builtin.TypeError(
              "__dict__ must be set to a dictionary, not a '" + Sk.abstr.typeName(value) + "'"
            );
          }
        },
        $doc: "dictionary for instance variables (if defined)",
        $name: "__dict__"
      };
      Sk.generic.seqCompare = function(other, op) {
        if (this === other && Sk.misceval.opAllowsEquality(op)) {
          return true;
        }
        if (!(other instanceof this.sk$builtinBase)) {
          return Sk.builtin.NotImplemented.NotImplemented$;
        }
        const v = this.v;
        const w = other.v;
        let i;
        if (v.length !== w.length && (op === "Eq" || op === "NotEq")) {
          return op === "Eq" ? false : true;
        }
        for (i = 0; i < v.length && i < w.length; ++i) {
          if (!(v[i] === w[i] || Sk.misceval.richCompareBool(v[i], w[i], "Eq"))) {
            break;
          }
        }
        const vl = v.length;
        const wl = w.length;
        if (i >= vl || i >= wl) {
          switch (op) {
            case "Lt":
              return vl < wl;
            case "LtE":
              return vl <= wl;
            case "Eq":
              return vl === wl;
            case "NotEq":
              return vl !== wl;
            case "Gt":
              return vl > wl;
            case "GtE":
              return vl >= wl;
            default:
              Sk.asserts.fail();
          }
        }
        if (op === "Eq") {
          return false;
        }
        if (op === "NotEq") {
          return true;
        }
        return Sk.misceval.richCompareBool(v[i], w[i], op);
      };
      Sk.generic.classGetItem = {
        __class_getitem__: {
          $meth(args) {
            return new Sk.builtin.GenericAlias(this, args);
          },
          $flags: { OneArg: true }
        }
      };
    }
  });

  // src/check.js
  var require_check = __commonJS({
    "src/check.js"() {
      Sk.builtin.pyCheckArgs = function(name, args, minargs, maxargs, kwargs, free) {
        var nargs = args.length;
        var msg = "";
        if (maxargs === void 0) {
          maxargs = Infinity;
        }
        if (kwargs) {
          nargs -= 1;
        }
        if (free) {
          nargs -= 1;
        }
        if (nargs < minargs || nargs > maxargs) {
          if (minargs === maxargs) {
            msg = name + "() takes exactly " + minargs + " arguments";
          } else if (nargs < minargs) {
            msg = name + "() takes at least " + minargs + " arguments";
          } else if (minargs > 0) {
            msg = name + "() takes at most " + maxargs + " arguments";
          } else {
            msg = name + "() takes no arguments";
          }
          msg += " (" + nargs + " given)";
          throw new Sk.builtin.TypeError(msg);
        }
      };
      Sk.exportSymbol("Sk.builtin.pyCheckArgs", Sk.builtin.pyCheckArgs);
      Sk.builtin.pyCheckArgsLen = function(name, nargs, minargs, maxargs, kwargs, free) {
        var msg = "";
        if (maxargs === void 0) {
          maxargs = Infinity;
        }
        if (kwargs) {
          nargs -= 1;
        }
        if (free) {
          nargs -= 1;
        }
        if (nargs < minargs || nargs > maxargs) {
          if (minargs === maxargs) {
            msg = name + "() takes exactly " + minargs + " arguments";
          } else if (nargs < minargs) {
            msg = name + "() takes at least " + minargs + " arguments";
          } else {
            msg = name + "() takes at most " + maxargs + " arguments";
          }
          msg += " (" + nargs + " given)";
          throw new Sk.builtin.TypeError(msg);
        }
      };
      Sk.builtin.pyCheckType = function(name, exptype, check) {
        if (!check) {
          throw new Sk.builtin.TypeError(name + " must be a " + exptype);
        }
      };
      Sk.exportSymbol("Sk.builtin.pyCheckType", Sk.builtin.pyCheckType);
      Sk.builtin.checkSequence = function(arg) {
        return arg != null && arg.mp$subscript !== void 0;
      };
      Sk.exportSymbol("Sk.builtin.checkSequence", Sk.builtin.checkSequence);
      Sk.builtin.checkIterable = function(arg) {
        if (arg === void 0) {
          return false;
        }
        if (arg.tp$iter) {
          const iter = arg.tp$iter();
          return iter.tp$iternext !== void 0;
        }
        return arg.mp$subscript !== void 0;
      };
      Sk.exportSymbol("Sk.builtin.checkIterable", Sk.builtin.checkIterable);
      Sk.builtin.checkCallable = function(obj) {
        return obj != null && obj.tp$call !== void 0;
      };
      Sk.builtin.checkNumber = function(arg) {
        return typeof arg === "number" || arg instanceof Sk.builtin.int_ || arg instanceof Sk.builtin.float_ || arg instanceof Sk.builtin.lng;
      };
      Sk.exportSymbol("Sk.builtin.checkNumber", Sk.builtin.checkNumber);
      Sk.builtin.checkComplex = function(arg) {
        return arg instanceof Sk.builtin.complex;
      };
      Sk.exportSymbol("Sk.builtin.checkComplex", Sk.builtin.checkComplex);
      Sk.builtin.checkInt = function(arg) {
        return arg instanceof Sk.builtin.int_ || typeof arg === "number" && Number.isInteger(arg);
      };
      Sk.exportSymbol("Sk.builtin.checkInt", Sk.builtin.checkInt);
      Sk.builtin.checkFloat = function(arg) {
        return arg instanceof Sk.builtin.float_;
      };
      Sk.exportSymbol("Sk.builtin.checkFloat", Sk.builtin.checkFloat);
      Sk.builtin.checkString = function(arg) {
        return arg instanceof Sk.builtin.str;
      };
      Sk.exportSymbol("Sk.builtin.checkString", Sk.builtin.checkString);
      Sk.builtin.checkBytes = function(arg) {
        return arg instanceof Sk.builtin.bytes;
      };
      Sk.builtin.checkClass = function(arg) {
        return arg instanceof Sk.builtin.type;
      };
      Sk.exportSymbol("Sk.builtin.checkClass", Sk.builtin.checkClass);
      Sk.builtin.checkBool = function(arg) {
        return arg instanceof Sk.builtin.bool;
      };
      Sk.exportSymbol("Sk.builtin.checkBool", Sk.builtin.checkBool);
      Sk.builtin.checkNone = function(arg) {
        return arg === Sk.builtin.none.none$;
      };
      Sk.exportSymbol("Sk.builtin.checkNone", Sk.builtin.checkNone);
      Sk.builtin.checkFunction = function(arg) {
        return arg != null && arg.tp$call !== void 0;
      };
      Sk.exportSymbol("Sk.builtin.checkFunction", Sk.builtin.checkFunction);
      Sk.builtin.checkDataDescr = function(arg) {
        return arg && arg.tp$descr_set !== void 0;
      };
      Sk.exportSymbol("Sk.builtin.checkDataDescr", Sk.builtin.checkDataDescr);
      Sk.builtin.checkAnySet = function(arg) {
        return arg instanceof Sk.builtin.set || arg instanceof Sk.builtin.frozenset;
      };
      Sk.builtin.checkMapping = function(arg) {
        return arg instanceof Sk.builtin.dict || arg instanceof Sk.builtin.mappingproxy || arg != null && arg.mp$subscript !== void 0 && Sk.abstr.lookupSpecial(arg, Sk.builtin.str.$keys) !== void 0;
      };
    }
  });

  // src/abstract.js
  var require_abstract = __commonJS({
    "src/abstract.js"() {
      Sk.abstr = {};
      Sk.abstr.typeName = function(obj) {
        if (obj != null && obj.tp$name !== void 0) {
          let name = obj.ht$name;
          if (name !== void 0) {
            return name.toString();
          }
          name = obj.tp$name;
          if (name.includes(".")) {
            name = name.slice(name.lastIndexOf(".") + 1);
          }
          return name;
        } else {
          Sk.asserts.fail(obj + " passed to typeName");
          return "<invalid type>";
        }
      };
      var binop_name_to_symbol = {
        Add: "+",
        Sub: "-",
        Mult: "*",
        MatMult: "@",
        Div: "/",
        FloorDiv: "//",
        Mod: "%",
        DivMod: "divmod()",
        Pow: "** or pow()",
        LShift: "<<",
        RShift: ">>",
        BitAnd: "&",
        BitXor: "^",
        BitOr: "|"
      };
      function binop_type_error(v, w, name) {
        const vtypename = Sk.abstr.typeName(v);
        const wtypename = Sk.abstr.typeName(w);
        throw new Sk.builtin.TypeError(
          "unsupported operand type(s) for " + binop_name_to_symbol[name] + ": '" + vtypename + "' and '" + wtypename + "'"
        );
      }
      function biniop_type_error(v, w, name) {
        const vtypename = Sk.abstr.typeName(v);
        const wtypename = Sk.abstr.typeName(w);
        throw new Sk.builtin.TypeError(
          "unsupported operand type(s) for " + binop_name_to_symbol[name] + "=: '" + vtypename + "' and '" + wtypename + "'"
        );
      }
      var uop_name_to_symbol = {
        UAdd: "+",
        USub: "-",
        Invert: "~"
      };
      function unop_type_error(v, name) {
        var vtypename = Sk.abstr.typeName(v);
        throw new Sk.builtin.TypeError(
          "bad operand type for unary " + uop_name_to_symbol[name] + ": '" + vtypename + "'"
        );
      }
      function boNameToSlotFuncLhs_(obj, name) {
        switch (name) {
          case "Add":
            return obj.nb$add;
          case "Sub":
            return obj.nb$subtract;
          case "Mult":
            return obj.nb$multiply;
          case "MatMult":
            if (Sk.__future__.python3) {
              return obj.nb$matrix_multiply;
            }
          case "Div":
            return obj.nb$divide;
          case "FloorDiv":
            return obj.nb$floor_divide;
          case "Mod":
            return obj.nb$remainder;
          case "DivMod":
            return obj.nb$divmod;
          case "Pow":
            return obj.nb$power;
          case "LShift":
            return obj.nb$lshift;
          case "RShift":
            return obj.nb$rshift;
          case "BitAnd":
            return obj.nb$and;
          case "BitXor":
            return obj.nb$xor;
          case "BitOr":
            return obj.nb$or;
        }
      }
      function boNameToSlotFuncRhs_(obj, name) {
        switch (name) {
          case "Add":
            return obj.nb$reflected_add;
          case "Sub":
            return obj.nb$reflected_subtract;
          case "Mult":
            return obj.nb$reflected_multiply;
          case "MatMult":
            if (Sk.__future__.python3) {
              return obj.nb$reflected_matrix_multiply;
            }
          case "Div":
            return obj.nb$reflected_divide;
          case "FloorDiv":
            return obj.nb$reflected_floor_divide;
          case "Mod":
            return obj.nb$reflected_remainder;
          case "DivMod":
            return obj.nb$reflected_divmod;
          case "Pow":
            return obj.nb$reflected_power;
          case "LShift":
            return obj.nb$reflected_lshift;
          case "RShift":
            return obj.nb$reflected_rshift;
          case "BitAnd":
            return obj.nb$reflected_and;
          case "BitXor":
            return obj.nb$reflected_xor;
          case "BitOr":
            return obj.nb$reflected_or;
        }
      }
      function iboNameToSlotFunc_(obj, name) {
        switch (name) {
          case "Add":
            return obj.nb$inplace_add;
          case "Sub":
            return obj.nb$inplace_subtract;
          case "Mult":
            return obj.nb$inplace_multiply;
          case "MatMult":
            if (Sk.__future__.python3) {
              return obj.nb$inplace_matrix_multiply;
            }
          case "Div":
            return obj.nb$inplace_divide;
          case "FloorDiv":
            return obj.nb$inplace_floor_divide;
          case "Mod":
            return obj.nb$inplace_remainder;
          case "Pow":
            return obj.nb$inplace_power;
          case "LShift":
            return obj.nb$inplace_lshift;
          case "RShift":
            return obj.nb$inplace_rshift;
          case "BitAnd":
            return obj.nb$inplace_and;
          case "BitOr":
            return obj.nb$inplace_or;
          case "BitXor":
            return obj.nb$inplace_xor;
        }
      }
      function uoNameToSlotFunc_(obj, name) {
        switch (name) {
          case "USub":
            return obj.nb$negative;
          case "UAdd":
            return obj.nb$positive;
          case "Invert":
            return obj.nb$invert;
        }
      }
      function binary_op_(v, w, opname) {
        const w_type = w.constructor;
        const v_type = v.constructor;
        const w_is_subclass = w_type !== v_type && w_type.sk$baseClass === void 0 && w instanceof v_type;
        let wop;
        let ret;
        let tried_reflected = false;
        if (w_is_subclass) {
          wop = boNameToSlotFuncRhs_(w, opname);
          if (wop === void 0) {
            tried_reflected = true;
          } else if (wop !== boNameToSlotFuncRhs_(v, opname)) {
            tried_reflected = true;
            ret = wop.call(w, v);
            if (ret !== Sk.builtin.NotImplemented.NotImplemented$) {
              return ret;
            }
          }
        }
        const vop = boNameToSlotFuncLhs_(v, opname);
        if (vop !== void 0) {
          ret = vop.call(v, w);
          if (ret !== Sk.builtin.NotImplemented.NotImplemented$) {
            return ret;
          }
        }
        if (!tried_reflected && w_type !== v_type) {
          wop || (wop = boNameToSlotFuncRhs_(w, opname));
          if (wop !== void 0) {
            ret = wop.call(w, v);
            if (ret !== Sk.builtin.NotImplemented.NotImplemented$) {
              return ret;
            }
          }
        }
      }
      function binary_iop_(v, w, opname) {
        const vop = iboNameToSlotFunc_(v, opname);
        if (vop !== void 0) {
          const ret = vop.call(v, w);
          if (ret !== Sk.builtin.NotImplemented.NotImplemented$) {
            return ret;
          }
        }
        return binary_op_(v, w, opname);
      }
      function unary_op_(v, opname) {
        const vop = uoNameToSlotFunc_(v, opname);
        if (vop !== void 0) {
          return vop.call(v);
        }
      }
      Sk.abstr.numberBinOp = function(v, w, op) {
        return binary_op_(v, w, op) || binop_type_error(v, w, op);
      };
      Sk.exportSymbol("Sk.abstr.numberBinOp", Sk.abstr.numberBinOp);
      Sk.abstr.numberInplaceBinOp = function(v, w, op) {
        return binary_iop_(v, w, op) || biniop_type_error(v, w, op);
      };
      Sk.exportSymbol("Sk.abstr.numberInplaceBinOp", Sk.abstr.numberInplaceBinOp);
      Sk.abstr.numberUnaryOp = function(v, op) {
        if (op === "Not") {
          return Sk.misceval.isTrue(v) ? Sk.builtin.bool.false$ : Sk.builtin.bool.true$;
        }
        return unary_op_(v, op) || unop_type_error(v, op);
      };
      Sk.exportSymbol("Sk.abstr.numberUnaryOp", Sk.abstr.numberUnaryOp);
      Sk.abstr.fixSeqIndex_ = function(seq, i) {
        i = Sk.builtin.asnum$(i);
        if (i < 0 && seq.sq$length) {
          i += seq.sq$length();
        }
        return i;
      };
      Sk.abstr.sequenceContains = function(seq, ob, canSuspend) {
        if (seq.sq$contains) {
          return seq.sq$contains(ob, canSuspend);
        }
        const r = Sk.misceval.iterFor(
          Sk.abstr.iter(seq),
          function(i) {
            if (i === ob || Sk.misceval.richCompareBool(i, ob, "Eq")) {
              return new Sk.misceval.Break(true);
            } else {
              return false;
            }
          },
          false
        );
        return canSuspend ? r : Sk.misceval.retryOptionalSuspensionOrThrow(r);
      };
      Sk.abstr.sequenceConcat = function(s, o) {
        if (s.sq$concat) {
          return s.sq$concat(o);
        }
        if (Sk.builtin.checkSequence(s) && Sk.builtin.checkSequence(o)) {
          const res = binary_op_(s, o, "Add");
          if (res !== void 0) {
            return res;
          }
        }
        throw new Sk.builtin.TypeError("'" + Sk.abstr.typeName(s) + "' object can't be concatenated");
      };
      Sk.abstr.sequenceInPlaceConcat = function(s, o) {
        if (s.sq$inplace_concat) {
          return s.sq$inplace_concat(o);
        } else if (s.sq$concat) {
          return s.sq$concat(o);
        }
        if (Sk.builtin.checkSequence(s) && Sk.builtin.checkSequence(o)) {
          const res = binary_iop_(s, o, "Add");
          if (res !== void 0) {
            return res;
          }
        }
        throw new Sk.builtin.TypeError("'" + Sk.abstr.typeName(s) + "' object can't be concatenated");
      };
      Sk.abstr.sequenceGetIndexOf = function(seq, ob) {
        if (seq.index) {
          return Sk.misceval.callsimArray(seq.index, [seq, ob]);
        }
        let index = 0;
        for (let it = Sk.abstr.iter(seq), i = it.tp$iternext(); i !== void 0; i = it.tp$iternext()) {
          if (Sk.misceval.richCompareBool(ob, i, "Eq")) {
            return new Sk.builtin.int_(index);
          }
          index += 1;
        }
        throw new Sk.builtin.ValueError("sequence.index(x): x not in sequence");
      };
      Sk.abstr.sequenceGetCountOf = function(seq, ob) {
        if (seq.count) {
          return Sk.misceval.callsimArray(seq.count, [seq, ob]);
        }
        let count = 0;
        for (let it = Sk.abstr.iter(seq), i = it.tp$iternext(); i !== void 0; i = it.tp$iternext()) {
          if (Sk.misceval.richCompareBool(ob, i, "Eq")) {
            count += 1;
          }
        }
        return new Sk.builtin.int_(count);
      };
      Sk.abstr.sequenceGetItem = function(seq, i, canSuspend) {
        if (typeof i === "number") {
          i = new Sk.builtin.int_(i);
        }
        return Sk.abstr.objectGetItem(seq, i, canSuspend);
      };
      Sk.abstr.sequenceSetItem = function(seq, i, x, canSuspend) {
        if (typeof i === "number") {
          i = new Sk.builtin.int_(i);
        }
        return Sk.abstr.objectSetItem(seq, i, x, canSuspend);
      };
      Sk.abstr.sequenceDelItem = function(seq, i, canSuspend) {
        return Sk.abstr.objectDelItem(seq, i, canSuspend);
      };
      Sk.abstr.sequenceGetSlice = function(seq, i1, i2) {
        return Sk.abstr.objectGetItem(seq, new Sk.builtin.slice(i1, i2));
      };
      Sk.abstr.sequenceDelSlice = function(seq, i1, i2) {
        return Sk.abstr.objectDelItem(seq, new Sk.builtin.slice(i1, i2));
      };
      Sk.abstr.sequenceSetSlice = function(seq, i1, i2, x) {
        return Sk.abstr.objectSetItem(seq, new Sk.builtin.slice(i1, i2));
      };
      Sk.abstr.sequenceUnpack = function(seq, breakIdx, numvals, hasStar) {
        if (!Sk.builtin.checkIterable(seq)) {
          throw new Sk.builtin.TypeError(
            "cannot unpack non-iterable " + Sk.abstr.typeName(seq) + " object"
          );
        }
        const it = Sk.abstr.iter(seq);
        const res = [];
        let i = 0;
        let upToStar;
        if (breakIdx > 0) {
          upToStar = Sk.misceval.iterFor(it, (nxt) => {
            res.push(nxt);
            if (++i === breakIdx) {
              return new Sk.misceval.Break();
            }
          });
        }
        return Sk.misceval.chain(upToStar, () => {
          if (res.length < breakIdx) {
            throw new Sk.builtin.ValueError(
              "not enough values to unpack (expected at least " + numvals + ", got " + res.length + ")"
            );
          }
          if (!hasStar) {
            return Sk.misceval.chain(it.tp$iternext(true), (nxt) => {
              if (nxt !== void 0) {
                throw new Sk.builtin.ValueError(
                  "too many values to unpack (expected " + breakIdx + ")"
                );
              }
              return res;
            });
          }
          const starred = [];
          return Sk.misceval.chain(
            Sk.misceval.iterFor(it, (nxt) => {
              starred.push(nxt);
            }),
            () => {
              const starred_end = starred.length + breakIdx - numvals;
              if (starred_end < 0) {
                throw new Sk.builtin.ValueError(
                  "not enough values to unpack (expected at least " + numvals + ", got " + (numvals + starred_end) + ")"
                );
              }
              res.push(new Sk.builtin.list(starred.slice(0, starred_end)));
              res.push(...starred.slice(starred_end));
              return res;
            }
          );
        });
      };
      Sk.abstr.mappingUnpackIntoKeywordArray = function(jsArray, pyMapping, pyCodeObject) {
        if (pyMapping instanceof Sk.builtin.dict) {
          pyMapping.$items().forEach(([key, val]) => {
            if (!Sk.builtin.checkString(key)) {
              throw new Sk.builtin.TypeError(
                (pyCodeObject.$qualname ? pyCodeObject.$qualname + "() " : "") + "keywords must be strings"
              );
            }
            jsArray.push(key.v);
            jsArray.push(val);
          });
          return;
        }
        const keyf = Sk.abstr.lookupSpecial(pyMapping, Sk.builtin.str.$keys);
        if (keyf === void 0) {
          throw new Sk.builtin.TypeError("Object is not a mapping");
        }
        return Sk.misceval.chain(
          Sk.misceval.callsimOrSuspendArray(keyf),
          (keys) => Sk.misceval.iterFor(Sk.abstr.iter(keys), (key) => {
            if (!Sk.builtin.checkString(key)) {
              throw new Sk.builtin.TypeError(
                (pyCodeObject.$qualname ? pyCodeObject.$qualname + "() " : "") + "keywords must be strings"
              );
            }
            return Sk.misceval.chain(pyMapping.mp$subscript(key, true), (val) => {
              jsArray.push(key.v);
              jsArray.push(val);
            });
          })
        );
      };
      Sk.abstr.keywordArrayFromPyDict = function(dict) {
        const kwarray = [];
        dict.$items().forEach(([key, val]) => {
          if (!Sk.builtin.checkString(key)) {
            throw new Sk.builtin.TypeError("keywords must be strings");
          }
          kwarray.push(key.toString());
          kwarray.push(val);
        });
        return kwarray;
      };
      Sk.abstr.keywordArrayToPyDict = function(kwarray) {
        const dict = new Sk.builtin.dict();
        for (let i = 0; i < kwarray.length; i += 2) {
          dict.mp$ass_subscript(new Sk.builtin.str(kwarray[i]), kwarray[i + 1]);
        }
        return dict;
      };
      Sk.abstr.copyKeywordsToNamedArgs = function(func_name, varnames, args, kwargs, defaults) {
        kwargs = kwargs || [];
        const nargs = args.length + kwargs.length / 2;
        if (nargs > varnames.length) {
          throw new Sk.builtin.TypeError(
            func_name + "() expected at most " + varnames.length + " arguments (" + nargs + " given)"
          );
        }
        if (!kwargs.length && defaults === void 0) {
          return args;
        } else if (nargs === varnames.length && !kwargs.length) {
          return args;
        } else if (nargs === 0 && varnames.length === (defaults && defaults.length)) {
          return defaults;
        }
        args = args.slice(0);
        for (let i = 0; i < kwargs.length; i += 2) {
          const name = kwargs[i];
          if (name === null) {
            continue;
          }
          const value = kwargs[i + 1];
          const idx = varnames.indexOf(name);
          if (idx >= 0) {
            if (args[idx] !== void 0) {
              throw new Sk.builtin.TypeError(
                func_name + "() got multiple values for argument '" + name + "'"
              );
            }
            args[idx] = value;
          } else {
            throw new Sk.builtin.TypeError(
              func_name + "() got an unexpected keyword argument '" + name + "'"
            );
          }
        }
        if (defaults) {
          const nargs2 = varnames.length;
          for (let i = nargs2 - 1; i >= 0; i--) {
            if (args[i] === void 0) {
              args[i] = defaults[defaults.length - 1 - (nargs2 - 1 - i)];
            }
          }
          const missing = varnames.filter((x, i) => args[i] === void 0);
          if (missing.length) {
            throw new Sk.builtin.TypeError(
              func_name + "() missing " + missing.length + " required positional arguments: " + missing.join(", ")
            );
          }
        }
        return args;
      };
      Sk.exportSymbol("Sk.abstr.copyKeywordsToNamedArgs", Sk.abstr.copyKeywordsToNamedArgs);
      Sk.abstr.checkNoKwargs = function(func_name, kwargs) {
        if (kwargs && kwargs.length) {
          throw new Sk.builtin.TypeError(func_name + "() takes no keyword arguments");
        }
      };
      Sk.exportSymbol("Sk.abstr.checkNoKwargs", Sk.abstr.checkNoKwargs);
      Sk.abstr.checkNoArgs = function(func_name, args, kwargs) {
        const nargs = args.length + (kwargs ? kwargs.length : 0);
        if (nargs) {
          throw new Sk.builtin.TypeError(func_name + "() takes no arguments (" + nargs + " given)");
        }
      };
      Sk.exportSymbol("Sk.abstr.checkNoArgs", Sk.abstr.checkNoArgs);
      Sk.abstr.checkOneArg = function(func_name, args, kwargs) {
        Sk.abstr.checkNoKwargs(func_name, kwargs);
        if (args.length !== 1) {
          throw new Sk.builtin.TypeError(
            func_name + "() takes exactly one argument (" + args.length + " given)"
          );
        }
      };
      Sk.exportSymbol("Sk.abstr.checkOneArg", Sk.abstr.checkOneArg);
      Sk.abstr.checkArgsLen = function(func_name, args, minargs, maxargs) {
        const nargs = args.length;
        let msg;
        if (maxargs === void 0) {
          maxargs = Infinity;
        }
        if (nargs < minargs || nargs > maxargs) {
          if (minargs === maxargs) {
            msg = func_name + "() takes exactly " + minargs + " arguments";
          } else if (nargs < minargs) {
            msg = func_name + "() takes at least " + minargs + " arguments";
          } else {
            msg = func_name + "() takes at most " + maxargs + " arguments";
          }
          msg += " (" + nargs + " given)";
          throw new Sk.builtin.TypeError(msg);
        }
      };
      Sk.exportSymbol("Sk.abstr.checkArgsLen", Sk.abstr.checkArgsLen);
      Sk.abstr.objectFormat = function(obj, format_spec) {
        if (format_spec === void 0) {
          format_spec = Sk.builtin.str.$emptystr;
        } else if (!Sk.builtin.checkString(format_spec)) {
          throw new Sk.builtin.TypeError(
            "Format specifier must be a string, not " + Sk.abstr.typeName(format_spec)
          );
        }
        const meth = Sk.abstr.lookupSpecial(obj, Sk.builtin.str.$format);
        const result = Sk.misceval.callsimArray(meth, [format_spec]);
        if (!Sk.builtin.checkString(result)) {
          throw new Sk.builtin.TypeError(
            "__format__ must return a str, not " + Sk.abstr.typeName(result)
          );
        }
        return result;
      };
      Sk.abstr.objectHash = function(obj) {
        const hash_func = obj.tp$hash;
        if (hash_func !== void 0) {
          if (Sk.builtin.checkNone(hash_func)) {
            throw new Sk.builtin.TypeError("unhashable type: '" + Sk.abstr.typeName(obj) + "'");
          }
          return obj.tp$hash();
        }
        throw new Sk.builtin.TypeError("unsupported Javascript type");
      };
      Sk.abstr.objectAdd = function(a, b) {
        if (a.nb$add) {
          return a.nb$add(b);
        }
        const atypename = Sk.abstr.typeName(a);
        const btypename = Sk.abstr.typeName(b);
        throw new Sk.builtin.TypeError(
          "unsupported operand type(s) for +: '" + atypename + "' and '" + btypename + "'"
        );
      };
      Sk.abstr.objectNegative = function(obj) {
        if (obj.nb$negative) {
          return obj.nb$negative();
        }
        throw new Sk.builtin.TypeError(
          "bad operand type for unary -: '" + Sk.abstr.typeName(obj) + "'"
        );
      };
      Sk.abstr.objectPositive = function(obj) {
        if (obj.nb$positive) {
          return obj.nb$positive();
        }
        throw new Sk.builtin.TypeError(
          "bad operand type for unary +: '" + Sk.abstr.typeName(obj) + "'"
        );
      };
      Sk.abstr.objectDelItem = function(o, key, canSuspend) {
        if (o.mp$ass_subscript) {
          return o.mp$ass_subscript(key, void 0, canSuspend);
        }
        throw new Sk.builtin.TypeError(
          "'" + Sk.abstr.typeName(o) + "' object does not support item deletion"
        );
      };
      Sk.exportSymbol("Sk.abstr.objectDelItem", Sk.abstr.objectDelItem);
      Sk.abstr.objectGetItem = function(o, key, canSuspend) {
        if (o.mp$subscript) {
          return o.mp$subscript(key, canSuspend);
        }
        if (Sk.builtin.checkClass(o)) {
          if (o === Sk.builtin.type) {
            return new Sk.builtin.GenericAlias(o, key);
          }
          const meth = Sk.abstr.typeLookup(o, Sk.builtin.str.$class_getitem);
          if (meth !== void 0) {
            const res = Sk.misceval.callsimOrSuspendArray(meth, [key]);
            return canSuspend ? res : Sk.misceval.retryOptionalSuspensionOrThrow(res);
          }
        }
        throw new Sk.builtin.TypeError("'" + Sk.abstr.typeName(o) + "' does not support indexing");
      };
      Sk.exportSymbol("Sk.abstr.objectGetItem", Sk.abstr.objectGetItem);
      Sk.abstr.objectSetItem = function(o, key, v, canSuspend) {
        if (o.mp$ass_subscript) {
          return o.mp$ass_subscript(key, v, canSuspend);
        }
        throw new Sk.builtin.TypeError(
          "'" + Sk.abstr.typeName(o) + "' does not support item assignment"
        );
      };
      Sk.exportSymbol("Sk.abstr.objectSetItem", Sk.abstr.objectSetItem);
      Sk.abstr.gattr = function(obj, pyName, canSuspend) {
        const ret = obj.tp$getattr(pyName, canSuspend);
        if (ret === void 0) {
          throw new Sk.builtin.AttributeError(
            obj.sk$attrError() + " has no attribute '" + pyName.$jsstr() + "'"
          );
        } else if (ret.$isSuspension) {
          return Sk.misceval.chain(ret, function(r) {
            if (r === void 0) {
              throw new Sk.builtin.AttributeError(
                obj.sk$attrError() + " has no attribute '" + pyName.$jsstr() + "'"
              );
            }
            return r;
          });
        } else {
          return ret;
        }
      };
      Sk.exportSymbol("Sk.abstr.gattr", Sk.abstr.gattr);
      Sk.abstr.sattr = function(obj, pyName, data, canSuspend) {
        return obj.tp$setattr(pyName, data, canSuspend);
      };
      Sk.exportSymbol("Sk.abstr.sattr", Sk.abstr.sattr);
      Sk.abstr.iternext = function(it, canSuspend) {
        return it.tp$iternext(canSuspend);
      };
      Sk.exportSymbol("Sk.abstr.iternext", Sk.abstr.iternext);
      Sk.abstr.iter = function(obj) {
        if (obj.tp$iter) {
          const iter = obj.tp$iter();
          if (iter.tp$iternext) {
            return iter;
          }
          throw new Sk.builtin.TypeError(
            "iter() returned non-iterator of type '" + Sk.abstr.typeName(iter) + "'"
          );
        }
        if (obj.mp$subscript) {
          return new Sk.builtin.seq_iter_(obj);
        }
        throw new Sk.builtin.TypeError("'" + Sk.abstr.typeName(obj) + "' object is not iterable");
      };
      Sk.exportSymbol("Sk.abstr.iter", Sk.abstr.iter);
      Sk.abstr.lookupSpecial = function(obj, pyName) {
        var obtype = obj.ob$type;
        if (obtype === void 0) {
          Sk.asserts.fail("javascript object sent to lookupSpecial");
          return;
        }
        var func = obtype.$typeLookup(pyName);
        if (func === void 0) {
          return;
        } else if (func.tp$descr_get !== void 0) {
          func = func.tp$descr_get(obj, obtype);
        }
        return func;
      };
      Sk.exportSymbol("Sk.abstr.lookupSpecial", Sk.abstr.lookupSpecial);
      Sk.abstr.typeLookup = function(type_obj, pyName) {
        const res = type_obj.$typeLookup(pyName);
        if (res !== void 0 && res.tp$descr_get) {
          return res.tp$descr_get(null, type_obj);
        }
        return res;
      };
      Sk.abstr.markUnhashable = function(thisClass) {
        const proto = thisClass.prototype;
        proto.__hash__ = Sk.builtin.none.none$;
        proto.tp$hash = Sk.builtin.none.none$;
      };
      Sk.abstr.setUpInheritance = function(childName, child, parent, metaclass) {
        metaclass = metaclass || Sk.builtin.type;
        parent = parent === void 0 ? Sk.builtin.object : parent;
        const parentproto = parent !== null ? parent.prototype : null;
        Object.setPrototypeOf(child, metaclass.prototype);
        Object.setPrototypeOf(child.prototype, parentproto);
        Object.defineProperties(child.prototype, {
          sk$object: { value: child, writable: true },
          ob$type: { value: child, writable: true },
          tp$name: { value: childName, writable: true },
          tp$base: { value: parent, writable: true }
        });
      };
      Sk.abstr.setUpBuiltinMro = function(child) {
        let base = child.prototype.tp$base;
        const bases = base === null ? [] : [base];
        if (base === Sk.builtin.object || base === null) {
          Object.defineProperty(child, "sk$baseClass", { value: true, writable: true });
          Object.defineProperty(child.prototype, "sk$builtinBase", { value: child, writable: true });
        }
        Object.defineProperty(child, "sk$solidBase", { value: true, writable: true });
        const mro = [child];
        while (base !== null) {
          mro.push(base);
          base = base.prototype.tp$base;
        }
        Object.defineProperties(child.prototype, {
          sk$prototypical: { value: true, writable: true },
          tp$bases: { value: bases, writable: true },
          tp$mro: { value: mro, writable: true }
        });
        Object.defineProperty(child, "$typeLookup", {
          value: function(pyName) {
            var jsName = pyName.$mangled;
            return this.prototype[jsName];
          },
          writable: true
        });
      };
      Sk.abstr.setUpGetSets = function(klass, getsets) {
        if (Sk.builtin.getset_descriptor === void 0) {
          return;
        }
        const klass_proto = klass.prototype;
        getsets = getsets || klass_proto.tp$getsets || {};
        Object.entries(getsets).forEach(([getset_name, getset_def]) => {
          getset_def.$name = getset_name;
          klass_proto[getset_name] = new Sk.builtin.getset_descriptor(klass, getset_def);
        });
        Object.defineProperty(klass_proto, "tp$getsets", { value: null, writable: true });
      };
      Sk.abstr.setUpMethods = function(klass, methods) {
        if (Sk.builtin.method_descriptor === void 0) {
          return;
        }
        const klass_proto = klass.prototype;
        methods = methods || klass_proto.tp$methods || {};
        Object.entries(methods).forEach(([method_name, method_def]) => {
          method_def.$name = method_name;
          klass_proto[method_name] = new Sk.builtin.method_descriptor(klass, method_def);
        });
        Object.defineProperty(klass_proto, "tp$methods", { value: null, writable: true });
      };
      Sk.abstr.setUpClassMethods = function(klass, methods) {
        if (Sk.builtin.classmethod_descriptor === void 0) {
          return;
        }
        const klass_proto = klass.prototype;
        methods = methods || klass_proto.tp$classmethods || {};
        Object.entries(methods).forEach(([method_name, method_def]) => {
          method_def.$name = method_name;
          klass_proto[method_name] = new Sk.builtin.classmethod_descriptor(klass, method_def);
        });
        Object.defineProperty(klass_proto, "tp$classmethods", { value: null, writable: true });
      };
      var op2shortcut = Object.entries({
        Eq: "ob$eq",
        NotEq: "ob$ne",
        Gt: "ob$gt",
        GtE: "ob$ge",
        Lt: "ob$lt",
        LtE: "ob$le"
      });
      function _set_up_richcompare_wrappers(slots) {
        op2shortcut.forEach(([op, shortcut]) => {
          slots[shortcut] = function(other) {
            return this.tp$richcompare(other, op);
          };
        });
      }
      function _set_up_reflected_number_slots(slots) {
        const reflected_slots = Sk.reflectedNumberSlots;
        Object.keys(reflected_slots).forEach((slot_name) => {
          if (slots[slot_name] !== void 0) {
            const reflected_slot_def = reflected_slots[slot_name];
            const reflect_name = reflected_slot_def.reflected;
            const reflected_slot = slots[reflect_name];
            if (reflected_slot !== void 0) {
              if (reflected_slot === null) {
                delete slots[reflect_name];
              }
            } else {
              slots[reflect_name] = reflected_slot_def.slot || slots[slot_name];
            }
          }
        });
      }
      function _set_up_sequence_to_number_slots(slots) {
        const sequenceToNumber = Sk.sequenceAndMappingSlots;
        Object.keys(sequenceToNumber).forEach((slot_name) => {
          if (slots[slot_name] !== void 0) {
            const equiv_slots = sequenceToNumber[slot_name];
            equiv_slots.forEach((equv_slot_name) => {
              slots[equv_slot_name] = slots[slot_name];
            });
          }
        });
      }
      Sk.abstr.setUpSlots = function(klass, slots) {
        if (Sk.builtin.wrapper_descriptor === void 0) {
          return;
        }
        const proto = klass.prototype;
        slots = slots || proto.tp$slots || {};
        if (slots.tp$new === Sk.generic.new) {
          slots.tp$new = Sk.generic.new(klass);
        }
        if (slots.tp$richcompare) {
          _set_up_richcompare_wrappers(slots);
        }
        if (slots.tp$as_number) {
          _set_up_reflected_number_slots(slots);
        }
        if (slots.tp$as_sequence_or_mapping) {
          _set_up_sequence_to_number_slots(slots);
        }
        Object.entries(slots).forEach(([slot_name, value]) => {
          Object.defineProperty(proto, slot_name, {
            value,
            writable: true
          });
        });
        if (slots.tp$new) {
          proto.__new__ = new Sk.builtin.sk_method(Sk.generic.newMethodDef, klass);
          Object.defineProperty(proto, "sk$staticNew", { value: klass, writable: true });
        }
        function wrap_func(dunder_name, wrapped_func) {
          const slot_def = Sk.slots[dunder_name];
          proto[dunder_name] = new Sk.builtin.wrapper_descriptor(klass, slot_def, wrapped_func);
        }
        function set_up_slot(dunder_name, wrapped_func) {
          if (typeof dunder_name === "string") {
            wrap_func(dunder_name, wrapped_func);
          } else {
            dunder_name.forEach((related_dunder_name) => {
              wrap_func(related_dunder_name, wrapped_func);
            });
          }
        }
        Sk.subSlots.main_slots.forEach(([slot_name, dunder_name]) => {
          const wrapped_func = slots[slot_name];
          if (wrapped_func !== void 0) {
            set_up_slot(dunder_name, wrapped_func);
          }
        });
        const hash = slots.tp$hash;
        if (hash !== void 0) {
          if (typeof hash === "function") {
            wrap_func("__hash__", hash);
          } else if (hash === Sk.builtin.none.none$) {
            proto.__hash__ = hash;
          } else {
            Sk.asserts.fail("invalid tp$hash");
          }
        }
        if (slots.tp$as_number) {
          Sk.subSlots.number_slots.forEach(([slot_name, dunder_name]) => {
            const wrapped_func = slots[slot_name];
            if (wrapped_func !== void 0) {
              set_up_slot(dunder_name, wrapped_func);
            }
          });
        }
        if (slots.tp$as_sequence_or_mapping) {
          Sk.subSlots.sequence_and_mapping_slots.forEach(([slot_name, dunder_name]) => {
            const wrapped_func = slots[slot_name];
            if (wrapped_func !== void 0) {
              set_up_slot(dunder_name, wrapped_func);
            }
          });
        }
        Object.defineProperty(proto, "tp$slots", { value: null, writable: true });
      };
      Sk.abstr.buildNativeClass = function(typename, options) {
        options = options || {};
        Sk.asserts.assert(
          options.hasOwnProperty("constructor"),
          "A constructor is required to build a native class"
        );
        let typeobject = options.constructor;
        Sk.abstr.setUpInheritance(typename, typeobject, options.base, options.meta);
        Sk.abstr.setUpBuiltinMro(typeobject);
        const type_proto = typeobject.prototype;
        Object.defineProperties(type_proto, {
          // memoise these and make them null later
          tp$slots: { value: options.slots, writable: true },
          tp$getsets: { value: options.getsets, writable: true },
          tp$methods: { value: options.methods, writable: true },
          tp$classmethods: { value: options.classmethods, writable: true }
        });
        Sk.abstr.setUpSlots(
          typeobject,
          /**@lends {typeobject.prototype} */
          options.slots || {}
        );
        Sk.abstr.setUpMethods(typeobject, options.methods);
        Sk.abstr.setUpGetSets(typeobject, options.getsets);
        Sk.abstr.setUpClassMethods(typeobject, options.classmethods);
        const proto = options.proto || {};
        Object.entries(proto).forEach(([p, val]) => {
          Object.defineProperty(type_proto, p, {
            value: val,
            writable: true,
            enumerable: !(p.includes("$") || p in Object.prototype)
            // only make these private in these cases otherwise they're public methods
          });
        });
        const flags = options.flags || {};
        Object.entries(flags).forEach(([flag, val]) => {
          Object.defineProperty(typeobject, flag, {
            value: val,
            writable: true
          });
        });
        if (Sk.builtin.str !== void 0 && type_proto.hasOwnProperty("tp$doc") && !type_proto.hasOwnProperty("__doc__")) {
          const docstr = type_proto.tp$doc || null;
          if (typeof docstr === "string") {
            type_proto.__doc__ = new Sk.builtin.str(docstr);
          } else {
            type_proto.__doc__ = Sk.builtin.none.none$;
          }
        }
        return typeobject;
      };
      Sk.abstr.buildIteratorClass = function(typename, iterator) {
        Sk.asserts.assert(iterator.hasOwnProperty("constructor"), "must provide a constructor");
        iterator.slots = iterator.slots || {};
        iterator.slots.tp$iter = Sk.generic.selfIter;
        iterator.slots.tp$iternext = iterator.slots.tp$iternext || iterator.iternext;
        iterator.slots.tp$getattr = iterator.slots.tp$getattr || Sk.generic.getAttr;
        let ret = Sk.abstr.buildNativeClass(typename, iterator);
        Sk.abstr.built$iterators.push(ret);
        return ret;
      };
      Sk.abstr.built$iterators = [];
      Sk.abstr.setUpModuleMethods = function(module_name, module2, method_defs) {
        Object.entries(method_defs).forEach(([method_name, method_def]) => {
          method_def.$name = method_def.$name || method_name;
          module2[method_name] = new Sk.builtin.sk_method(method_def, null, module_name);
        });
      };
      Sk.abstr.superConstructor = function(thisClass, self2, args) {
        var argumentsForConstructor = Array.prototype.slice.call(arguments, 2);
        thisClass.prototype.tp$base.apply(self2, argumentsForConstructor);
      };
    }
  });

  // src/object.js
  var require_object = __commonJS({
    "src/object.js"() {
      var hashMap = /* @__PURE__ */ new Map();
      Sk.builtin.object = Sk.abstr.buildNativeClass("object", {
        constructor: function object() {
          Sk.asserts.assert(this instanceof Sk.builtin.object, "bad call to object, use 'new'");
        },
        base: null,
        slots: {
          tp$new(args, kwargs) {
            if (args.length || kwargs && kwargs.length) {
              if (this.tp$new !== Sk.builtin.object.prototype.tp$new) {
                throw new Sk.builtin.TypeError(
                  "object.__new__() takes exactly one argument (the type to instantiate)"
                );
              }
              if (this.tp$init === Sk.builtin.object.prototype.tp$init) {
                throw new Sk.builtin.TypeError(
                  Sk.abstr.typeName(this) + "() takes no arguments"
                );
              }
            }
            return new this.constructor();
          },
          tp$init(args, kwargs) {
            if (args.length || kwargs && kwargs.length) {
              if (this.tp$init !== Sk.builtin.object.prototype.tp$init) {
                throw new Sk.builtin.TypeError(
                  "object.__init__() takes exactly one argument (the instance to initialize)"
                );
              }
              if (this.tp$new === Sk.builtin.object.prototype.tp$new) {
                throw new Sk.builtin.TypeError(
                  Sk.abstr.typeName(this) + ".__init__() takes exactly one argument (the instance to initialize)"
                );
              }
            }
          },
          tp$getattr: Sk.generic.getAttr,
          tp$setattr: Sk.generic.setAttr,
          $r() {
            const mod = Sk.abstr.lookupSpecial(this, Sk.builtin.str.$module);
            let cname = "";
            if (mod && Sk.builtin.checkString(mod)) {
              cname = mod.v + ".";
            }
            return new Sk.builtin.str("<" + cname + Sk.abstr.typeName(this) + " object>");
          },
          tp$str() {
            return this.$r();
          },
          tp$hash() {
            let hash = hashMap.get(this);
            if (hash !== void 0) {
              return hash;
            }
            hash = Math.floor(
              Math.random() * Number.MAX_SAFE_INTEGER - Number.MAX_SAFE_INTEGER / 2
            );
            hashMap.set(this, hash);
            return hash;
          },
          tp$richcompare(other, op) {
            let res;
            switch (op) {
              case "Eq":
                res = this === other || Sk.builtin.NotImplemented.NotImplemented$;
                break;
              case "NotEq":
                res = this.ob$eq(other, "Eq");
                if (res !== Sk.builtin.NotImplemented.NotImplemented$) {
                  res = !Sk.misceval.isTrue(res);
                }
                break;
              default:
                res = Sk.builtin.NotImplemented.NotImplemented$;
            }
            return res;
          },
          tp$doc: "The most base type"
        },
        getsets: {
          __class__: {
            $get() {
              return this.ob$type;
            },
            $set(value) {
              if (value === void 0) {
                throw new Sk.builtin.TypeError("can't delete __class__ attribute");
              } else if (!Sk.builtin.checkClass(value)) {
                throw new Sk.builtin.TypeError(
                  "__class__ must be set to a class, not '" + Sk.abstr.typeName(value) + "' object"
                );
              }
              const oldto = this.ob$type;
              const newto = value;
              if (!(oldto.$isSubType(Sk.builtin.module) && newto.$isSubType(Sk.builtin.module)) && (oldto.sk$klass === void 0 || newto.sk$klass === void 0)) {
                throw new Sk.builtin.TypeError(
                  " __class__ assignment only supported for heap types or ModuleType subclasses"
                );
              } else if (value.prototype.sk$builtinBase !== this.sk$builtinBase) {
                throw new Sk.builtin.TypeError(
                  "__class__ assignment: '" + Sk.abstr.typeName(this) + "' object layout differs from '" + value.prototype.tp$name + "'"
                );
              }
              Object.setPrototypeOf(this, value.prototype);
              return;
            },
            $doc: "the object's class"
          }
        },
        methods: {
          __dir__: {
            $meth: function __dir__() {
              let dir = [];
              if (this.$d) {
                if (this.$d instanceof Sk.builtin.dict) {
                  dir = this.$d.sk$asarray();
                } else {
                  for (let key in this.$d) {
                    dir.push(new Sk.builtin.str(key));
                  }
                }
              }
              const type_dir = Sk.misceval.callsimArray(Sk.builtin.type.prototype.__dir__, [
                this.ob$type
              ]);
              dir.push(...type_dir.v);
              type_dir.v = dir;
              return type_dir;
            },
            $flags: { NoArgs: true },
            $doc: "Default dir() implementation."
          },
          __format__: {
            $meth(format_spec) {
              if (!Sk.builtin.checkString(format_spec)) {
                throw new Sk.builtin.TypeError(
                  "__format__() argument must be str, not " + Sk.abstr.typeName(format_spec)
                );
              } else if (format_spec !== Sk.builtin.str.$empty) {
                throw new Sk.builtin.TypeError(
                  `unsupported format string passed to ${Sk.abstr.typeName(this)}.__format__`
                );
              }
              return this.tp$str();
            },
            $flags: { OneArg: true },
            $doc: "Default object formatter."
          }
        },
        proto: (
          /**@lends {Sk.builtin.object.prototype}*/
          {
            valueOf: Object.prototype.valueOf,
            toString: function() {
              return this.tp$str().v;
            },
            hasOwnProperty: Object.prototype.hasOwnProperty,
            ht$type: void 0,
            // private method used for error messages
            sk$attrError() {
              return "'" + this.tp$name + "' object";
            }
          }
        )
      });
      (function setUpBaseInheritance() {
        Sk.abstr.setUpInheritance("type", Sk.builtin.type, Sk.builtin.object);
        Sk.abstr.setUpBuiltinMro(Sk.builtin.type);
      })();
    }
  });

  // src/slotdefs.js
  var require_slotdefs = __commonJS({
    "src/slotdefs.js"() {
      function wrapperCallNoArgs(self2, args, kwargs) {
        Sk.abstr.checkNoArgs(this.$name, args, kwargs);
        const res = this.call(self2);
        if (res === void 0) {
          return Sk.builtin.none.none$;
        }
        return res;
      }
      function wrapperCallOneArg(self2, args, kwargs) {
        Sk.abstr.checkOneArg(this.$name, args, kwargs);
        const res = this.call(self2, args[0]);
        if (res === void 0) {
          return Sk.builtin.none.none$;
        }
        return res;
      }
      function wrapperCallTernary(self2, args, kwargs) {
        Sk.abstr.checkNoKwargs(this.$name, kwargs);
        Sk.abstr.checkArgsLen(this.$name, args, 1, 2);
        const res = this.call(self2, ...args);
        if (res === void 0) {
          return Sk.builtin.none.none$;
        }
        return res;
      }
      function wrapperSet(self2, args, kwargs) {
        Sk.abstr.checkNoKwargs(this.$name, kwargs);
        Sk.abstr.checkArgsLen(this.$name, args, 2, 2);
        this.call(self2, args[0], args[1]);
        return Sk.builtin.none.none$;
      }
      function wrapperDel(self2, args, kwargs) {
        Sk.abstr.checkOneArg(this.$name, args, kwargs);
        const res = this.call(self2, args[0], void 0, true);
        return Sk.misceval.chain(res, (res2) => {
          if (res2 === void 0) {
            return Sk.builtin.none.none$;
          }
          return res2;
        });
      }
      function wrapperRichCompare(self2, args, kwargs) {
        const res = wrapperCallOneArg.call(this, self2, args, kwargs);
        if (res === Sk.builtin.NotImplemented.NotImplemented$) {
          return res;
        }
        return new Sk.builtin.bool(res);
      }
      function wrapperCallBack(wrapper, callback) {
        return function(self2, args, kwargs) {
          const res = wrapper.call(this, self2, args, kwargs);
          return callback(res);
        };
      }
      function slotFuncNoArgs(dunderFunc) {
        return function() {
          const func = dunderFunc.tp$descr_get ? dunderFunc.tp$descr_get(this) : dunderFunc;
          return Sk.misceval.callsimArray(func, []);
        };
      }
      function slotFuncNoArgsWithCheck(dunderName, checkFunc, checkMsg, f) {
        return function(dunderFunc) {
          return function() {
            const func = dunderFunc.tp$descr_get ? dunderFunc.tp$descr_get(this) : dunderFunc;
            let res = Sk.misceval.callsimArray(func, []);
            if (!checkFunc(res)) {
              throw new Sk.builtin.TypeError(
                dunderName + " should return " + checkMsg + " (returned " + Sk.abstr.typeName(res) + ")"
              );
            }
            if (f !== void 0) {
              return f(res);
            }
            return res;
          };
        };
      }
      function slotFuncOneArg(dunderFunc) {
        return function(value) {
          const func = dunderFunc.tp$descr_get ? dunderFunc.tp$descr_get(this) : dunderFunc;
          return Sk.misceval.callsimArray(func, [value]);
        };
      }
      function slotFuncGetAttribute(pyName, canSuspend) {
        let getattributeFn = this.ob$type.$typeLookup(Sk.builtin.str.$getattribute);
        if (getattributeFn instanceof Sk.builtin.wrapper_descriptor) {
          return getattributeFn.d$wrapped.call(this, pyName, canSuspend);
        }
        if (getattributeFn.tp$descr_get) {
          getattributeFn = getattributeFn.tp$descr_get(this);
        }
        const ret = Sk.misceval.tryCatch(
          () => Sk.misceval.callsimOrSuspendArray(getattributeFn, [pyName]),
          (e) => {
            if (e instanceof Sk.builtin.AttributeError) {
              return void 0;
            } else {
              throw e;
            }
          }
        );
        return canSuspend ? ret : Sk.misceval.retryOptionalSuspensionOrThrow(ret);
      }
      function slotFuncFastCall(dunderFunc) {
        return function(args, kwargs) {
          const func = dunderFunc.tp$descr_get ? dunderFunc.tp$descr_get(this) : dunderFunc;
          return Sk.misceval.callsimOrSuspendArray(func, args, kwargs);
        };
      }
      function slotFuncSetDelete(set_name, del_name, error_msg) {
        return function(dunderFunc) {
          return function(pyObject2, value, canSuspend) {
            let res, dunderName;
            if (value === void 0) {
              dunderName = del_name;
              error_msg = null;
            } else {
              dunderName = set_name;
            }
            let func = this.ob$type.$typeLookup(new Sk.builtin.str(dunderName));
            if (func instanceof Sk.builtin.wrapper_descriptor) {
              return func.d$wrapped.call(this, pyObject2, value);
            }
            if (func.tp$descr_get) {
              func = func.tp$descr_get(this);
            }
            if (func !== void 0) {
              const args = value === void 0 ? [pyObject2] : [pyObject2, value];
              res = Sk.misceval.callsimOrSuspendArray(func, args);
            } else if (error_msg) {
              throw new Sk.builtin.TypeError(
                "'" + Sk.abstr.typeName(this) + "' object " + error_msg
              );
            } else {
              throw new Sk.builtin.AttributeError(dunderName);
            }
            return canSuspend ? res : Sk.misceval.retryOptionalSuspensionOrThrow(res);
          };
        };
      }
      Sk.slots = /* @__PURE__ */ Object.create(null);
      var slots = Sk.slots;
      Sk.slots.__init__ = {
        $name: "__init__",
        $slot_name: "tp$init",
        $slot_func: function(dunderFunc) {
          return function tp$init(args, kwargs) {
            const func = dunderFunc.tp$descr_get ? dunderFunc.tp$descr_get(this) : dunderFunc;
            let ret = Sk.misceval.callsimOrSuspendArray(func, args, kwargs);
            return Sk.misceval.chain(ret, (r) => {
              if (!Sk.builtin.checkNone(r) && r !== void 0) {
                throw new Sk.builtin.TypeError(
                  "__init__() should return None, not " + Sk.abstr.typeName(r)
                );
              }
              return;
            });
          };
        },
        $wrapper: function(self2, args, kwargs) {
          this.call(self2, args, kwargs);
          return Sk.builtin.none.none$;
        },
        $textsig: "($self, /, *args, **kwargs)",
        $flags: { FastCall: true },
        $doc: "Initialize self.  See help(type(self)) for accurate signature."
      };
      slots.__new__ = {
        $name: "__new__",
        $slot_name: "tp$new",
        $slot_func: function(dunderFunc) {
          const tp$new = function(args, kwargs) {
            let func = dunderFunc;
            if (dunderFunc.tp$descr_get) {
              func = dunderFunc.tp$descr_get(null, this.constructor);
            }
            return Sk.misceval.callsimOrSuspendArray(func, [this.constructor, ...args], kwargs);
          };
          tp$new.sk$static_new = false;
          return tp$new;
        },
        $wrapper: null,
        // handled separately since it's not a slot wrapper but an sk_method
        $textsig: "($self, /, *args, **kwargs)",
        $flags: { FastCall: true },
        $doc: "Create and return a new object."
      };
      slots.__call__ = {
        $name: "__call__",
        $slot_name: "tp$call",
        $slot_func: slotFuncFastCall,
        $wrapper: function __call__(self2, args, kwargs) {
          const res = self2.tp$call(args, kwargs);
          if (res === void 0) {
            return Sk.builtin.none.none$;
          }
          return res;
        },
        $textsig: "($self, /, *args, **kwargs)",
        $flags: { FastCall: true },
        $doc: "Call self as a function."
      };
      slots.__repr__ = {
        $name: "__repr__",
        $slot_name: "$r",
        $slot_func: slotFuncNoArgsWithCheck("__repr__", Sk.builtin.checkString, "str"),
        $wrapper: wrapperCallNoArgs,
        $textsig: "($self, /)",
        $flags: { NoArgs: true },
        $doc: "Return repr(self)."
      };
      slots.__str__ = {
        $name: "__str__",
        $slot_name: "tp$str",
        $slot_func: slotFuncNoArgsWithCheck("__str__", Sk.builtin.checkString, "str"),
        $wrapper: wrapperCallNoArgs,
        $textsig: "($self, /)",
        $flags: { NoArgs: true },
        $doc: "Return str(self)."
      };
      var hash_slot = slotFuncNoArgsWithCheck(
        "__hash__",
        Sk.builtin.checkInt,
        "int",
        (res) => typeof res.v === "number" ? res.v : res.tp$hash()
      );
      slots.__hash__ = {
        $name: "__hash__",
        $slot_name: "tp$hash",
        $slot_func: function(dunder_func) {
          if (dunder_func === Sk.builtin.none.none$) {
            return Sk.builtin.none.none$;
          }
          return hash_slot(dunder_func);
        },
        $wrapper: wrapperCallBack(wrapperCallNoArgs, (res) => new Sk.builtin.int_(res)),
        $textsig: "($self, /)",
        $flags: { NoArgs: true },
        $doc: "Return hash(self)."
      };
      slots.__getattribute__ = {
        $name: "__getattribute__",
        $slot_name: "tp$getattr",
        $slot_func: function(dunderFunc) {
          return function tp$getattr(pyName, canSuspend) {
            let getattrFn = this.ob$type.$typeLookup(Sk.builtin.str.$getattr);
            if (getattrFn === void 0) {
              return slotFuncGetAttribute.call(this, pyName, canSuspend);
            }
            const ret = Sk.misceval.chain(
              slotFuncGetAttribute.call(this, pyName, canSuspend),
              (val) => Sk.misceval.tryCatch(
                () => {
                  if (val !== void 0) {
                    return val;
                  }
                  if (getattrFn.tp$descr_get) {
                    getattrFn = getattrFn.tp$descr_get(this);
                  }
                  return Sk.misceval.callsimOrSuspendArray(getattrFn, [pyName]);
                },
                function(e) {
                  if (e instanceof Sk.builtin.AttributeError) {
                    return void 0;
                  } else {
                    throw e;
                  }
                }
              )
            );
            return canSuspend ? ret : Sk.misceval.retryOptionalSuspensionOrThrow(ret);
          };
        },
        $wrapper: function(self2, args, kwargs) {
          Sk.abstr.checkOneArg(this.$name, args, kwargs);
          const pyName = args[0];
          if (!Sk.builtin.checkString(pyName)) {
            throw new Sk.builtin.TypeError(
              "attribute name must be string, not '" + Sk.abstr.typeName(pyName) + "'"
            );
          }
          const res = this.call(self2, pyName);
          if (res === void 0) {
            throw new Sk.builtin.AttributeError(
              Sk.abstr.typeName(self2) + " has no attribute " + pyName.$jsstr()
            );
          }
          return res;
        },
        $textsig: "($self, name, /)",
        $flags: { OneArg: true },
        $doc: "Return getattr(self, name)."
      };
      slots.__getattr__ = {
        $name: "__getattr__",
        $slot_name: "tp$getattr",
        $slot_func: slots.__getattribute__.$slot_func,
        $wrapper: null,
        $textsig: "($self, name, /)",
        $flags: { OneArg: true },
        $doc: "Return getattr(self, name)."
      };
      function hackcheck(obj, func) {
        let type = obj.ob$type;
        while (type && type.sk$klass !== void 0) {
          type = type.prototype.tp$base;
        }
        if (type && type.prototype.tp$setattr !== func) {
          throw new Sk.builtin.TypeError(
            "can't apply this " + func.$name + " to " + Sk.abstr.typeName(obj) + " object"
          );
        }
      }
      slots.__setattr__ = {
        $name: "__setattr__",
        $slot_name: "tp$setattr",
        $slot_func: slotFuncSetDelete("__setattr__", "__delattr__"),
        // not need for an error message setattr is always defined on object
        $wrapper: function(self2, args, kwargs) {
          Sk.abstr.checkNoKwargs(this.$name, kwargs);
          Sk.abstr.checkArgsLen(this.$name, args, 2, 2);
          hackcheck(self2, this);
          this.call(self2, args[0], args[1]);
          return Sk.builtin.none.none$;
        },
        $textsig: "($self, name, value, /)",
        $flags: { MinArgs: 2, MaxArgs: 2 },
        $doc: "Implement setattr(self, name, value)."
      };
      slots.__delattr__ = {
        $name: "__delattr__",
        $slot_name: "tp$setattr",
        $slot_func: slots.__setattr__.$slot_func,
        $wrapper: function(self2, args, kwargs) {
          Sk.abstr.checkOneArg(this.$name, args, kwargs);
          hackcheck(self2, this);
          this.call(self2, args[0]);
          return Sk.builtin.none.none$;
        },
        $textsig: "($self, name, /)",
        $flags: { OneArg: true },
        $doc: "Implement delattr(self, name)."
      };
      slots.__get__ = {
        $name: "__get__",
        $slot_name: "tp$descr_get",
        $slot_func: function(dunderFunc) {
          return function tp$descr_get(obj, obtype, canSuspend) {
            if (obj === null) {
              obj = Sk.builtin.none.none$;
            }
            if (obtype == null) {
              obtype = Sk.builtin.none.none$;
            }
            const func = dunderFunc.tp$descr_get ? dunderFunc.tp$descr_get(this) : dunderFunc;
            const ret = Sk.misceval.callsimOrSuspendArray(func, [obj, obtype]);
            return canSuspend ? ret : Sk.misceval.retryOptionalSuspensionOrThrow(ret);
          };
        },
        $wrapper: function(self2, args, kwargs) {
          Sk.abstr.checkNoKwargs(this.$name, kwargs);
          Sk.abstr.checkArgsLen(this.$name, args, 1, 2);
          let obj = args[0];
          let obtype = args[1];
          if (obj === Sk.builtin.none.none$) {
            obj = null;
          }
          if (obtype === Sk.builtin.none.none$) {
            obtype = null;
          }
          if (obtype === null && obj === null) {
            throw new Sk.builtin.TypeError("__get__(None, None) is invalid");
          }
          return this.call(self2, obj, obtype);
        },
        $textsig: "($self, instance, owner, /)",
        $flags: { MinArgs: 2, MaxArgs: 2 },
        $doc: "Return an attribute of instance, which is of type owner."
      };
      slots.__set__ = {
        $name: "__set__",
        $slot_name: "tp$descr_set",
        $slot_func: slotFuncSetDelete("__set__", "__delete__"),
        $wrapper: wrapperSet,
        $textsig: "($self, instance, value, /)",
        $flags: { MinArgs: 2, MaxArgs: 2 },
        $doc: "Set an attribute of instance to value."
      };
      slots.__delete__ = {
        $name: "__delete__",
        $slot_name: "tp$descr_set",
        $slot_func: slots.__set__.$slot_func,
        $wrapper: wrapperDel,
        $textsig: "($self, instance, /)",
        $flags: { OneArg: true },
        $doc: "Delete an attribute of instance."
      };
      slots.__eq__ = {
        $name: "__eq__",
        $slot_name: "ob$eq",
        $slot_func: slotFuncOneArg,
        $wrapper: wrapperRichCompare,
        $textsig: "($self, value, /)",
        $flags: { OneArg: true },
        $doc: "Return self==value."
      };
      slots.__ge__ = {
        $name: "__ge__",
        $slot_name: "ob$ge",
        $slot_func: slotFuncOneArg,
        $wrapper: wrapperRichCompare,
        $textsig: "($self, value, /)",
        $flags: { OneArg: true },
        $doc: "Return self>=value."
      };
      slots.__gt__ = {
        $name: "__gt__",
        $slot_name: "ob$gt",
        $slot_func: slotFuncOneArg,
        $wrapper: wrapperRichCompare,
        $textsig: "($self, value, /)",
        $flags: { OneArg: true },
        $doc: "Return self>value."
      };
      slots.__le__ = {
        $name: "__le__",
        $slot_name: "ob$le",
        $slot_func: slotFuncOneArg,
        $wrapper: wrapperRichCompare,
        $textsig: "($self, value, /)",
        $flags: { OneArg: true },
        $doc: "Return self<=value."
      };
      slots.__lt__ = {
        $name: "__lt__",
        $slot_name: "ob$lt",
        $slot_func: slotFuncOneArg,
        $wrapper: wrapperRichCompare,
        $textsig: "($self, value, /)",
        $flags: { OneArg: true },
        $doc: "Return self<value."
      };
      slots.__ne__ = {
        $name: "__ne__",
        $slot_name: "ob$ne",
        $slot_func: slotFuncOneArg,
        $wrapper: wrapperRichCompare,
        $textsig: "($self, value, /)",
        $flags: { OneArg: true },
        $doc: "Return self!=value."
      };
      slots.__iter__ = {
        $name: "__iter__",
        $slot_name: "tp$iter",
        $slot_func: slotFuncNoArgs,
        $wrapper: wrapperCallNoArgs,
        $textsig: "($self, /)",
        $flags: { NoArgs: true },
        $doc: "Implement iter(self)."
      };
      slots.__next__ = {
        $name: "__next__",
        $slot_name: "tp$iternext",
        $slot_func: function(dunderFunc) {
          return function tp$iternext(canSuspend) {
            const func = dunderFunc.tp$descr_get ? dunderFunc.tp$descr_get(this) : dunderFunc;
            const ret = Sk.misceval.tryCatch(
              () => Sk.misceval.callsimOrSuspendArray(func, []),
              (e) => {
                if (e instanceof Sk.builtin.StopIteration) {
                  this.gi$ret = e.$value;
                  return void 0;
                } else {
                  throw e;
                }
              }
            );
            return canSuspend ? ret : Sk.misceval.retryOptionalSuspensionOrThrow(ret);
          };
        },
        /**
         *
         * @param {*} self
         * @param {Array} args
         * @param {Array|undefined=} kwargs
         */
        $wrapper: function(self2, args, kwargs) {
          Sk.abstr.checkNoArgs(this.$name, args, kwargs);
          return Sk.misceval.chain(self2.tp$iternext(true), (res) => {
            if (res === void 0) {
              throw new Sk.builtin.StopIteration();
            }
            return res;
          });
        },
        $textsig: "($self, /)",
        $flags: { NoArgs: true },
        $doc: "Implement next(self)."
      };
      slots.__len__ = {
        $name: "__len__",
        $slot_name: "sq$length",
        $slot_func: function(dunderFunc) {
          return function sq$length(canSuspend) {
            let res;
            const func = dunderFunc.tp$descr_get ? dunderFunc.tp$descr_get(this) : dunderFunc;
            if (canSuspend) {
              res = Sk.misceval.callsimOrSuspendArray(func, []);
              return Sk.misceval.chain(res, (r) => {
                return Sk.misceval.asIndexOrThrow(r);
              });
            } else {
              res = Sk.misceval.callsimArray(func, []);
              return Sk.misceval.asIndexOrThrow(res);
            }
          };
        },
        $wrapper: wrapperCallBack(wrapperCallNoArgs, (res) => new Sk.builtin.int_(res)),
        $flags: { NoArgs: true },
        $textsig: "($self, /)",
        $doc: "Return len(self)."
      };
      slots.__contains__ = {
        $name: "__contains__",
        $slot_name: "sq$contains",
        $slot_func: function(dunderFunc) {
          return function sq$contains(key, canSuspend) {
            const func = dunderFunc.tp$descr_get ? dunderFunc.tp$descr_get(this) : dunderFunc;
            let res = Sk.misceval.callsimOrSuspendArray(func, [key]);
            res = Sk.misceval.chain(res, (r) => Sk.misceval.isTrue(r));
            if (res.$isSuspension) {
              return canSuspend ? res : Sk.misceval.retryOptionalSuspensionOrThrow(res);
            }
            return res;
          };
        },
        // todo - allow for suspensions - but no internal functions suspend here
        $wrapper: wrapperCallBack(wrapperCallOneArg, (res) => new Sk.builtin.bool(res)),
        $textsig: "($self, key, /)",
        $flags: { OneArg: true },
        $doc: "Return key in self."
      };
      slots.__getitem__ = {
        $name: "__getitem__",
        $slot_name: "mp$subscript",
        $slot_func: function(dunderFunc) {
          return function mp$subscript(key, canSuspend) {
            const func = dunderFunc.tp$descr_get ? dunderFunc.tp$descr_get(this) : dunderFunc;
            const ret = Sk.misceval.callsimOrSuspendArray(func, [key]);
            return canSuspend ? ret : Sk.misceval.retryOptionalSuspensionOrThrow(ret);
          };
        },
        $wrapper: wrapperCallOneArg,
        $textsig: "($self, key, /)",
        $flags: { OneArg: true },
        $doc: "Return self[key]."
      };
      slots.__setitem__ = {
        $name: "__setitem__",
        $slot_name: "mp$ass_subscript",
        $slot_func: slotFuncSetDelete("__setitem__", "__delitem__", "does not support item assignment"),
        $wrapper: wrapperSet,
        $textsig: "($self, key, value, /)",
        $flags: { MinArgs: 2, MaxArgs: 2 },
        $doc: "Set self[key] to value."
      };
      slots.__delitem__ = {
        $name: "__delitem__",
        $slot_name: "mp$ass_subscript",
        $slot_func: slots.__setitem__.$slot_func,
        $wrapper: wrapperDel,
        $textsig: "($self, key, /)",
        $flags: { OneArg: true },
        $doc: "Delete self[key]."
      };
      slots.__add__ = {
        $name: "__add__",
        $slot_name: "nb$add",
        $slot_func: slotFuncOneArg,
        $wrapper: wrapperCallOneArg,
        $textsig: "($self, value, /)",
        $flags: { OneArg: true },
        $doc: "Return self+value."
      };
      slots.__radd__ = {
        $name: "__radd__",
        $slot_name: "nb$reflected_add",
        $slot_func: slotFuncOneArg,
        $wrapper: wrapperCallOneArg,
        $textsig: "($self, value, /)",
        $flags: { OneArg: true },
        $doc: "Return value+self."
      };
      slots.__iadd__ = {
        $name: "__iadd__",
        $slot_name: "nb$inplace_add",
        $slot_func: slotFuncOneArg,
        $wrapper: wrapperCallOneArg,
        $textsig: "($self, value, /)",
        $flags: { OneArg: true },
        $doc: "Implement self+=value."
      };
      slots.__sub__ = {
        $name: "__sub__",
        $slot_name: "nb$subtract",
        $slot_func: slotFuncOneArg,
        $wrapper: wrapperCallOneArg,
        $textsig: "($self, value, /)",
        $flags: { OneArg: true },
        $doc: "Return self-value."
      };
      slots.__rsub__ = {
        $name: "__rsub__",
        $slot_name: "nb$reflected_subtract",
        $slot_func: slotFuncOneArg,
        $wrapper: wrapperCallOneArg,
        $textsig: "($self, value, /)",
        $flags: { OneArg: true },
        $doc: "Return value-self."
      };
      slots.__imul__ = {
        $name: "__imul__",
        $slot_name: "nb$inplace_multiply",
        $slot_func: slotFuncOneArg,
        $wrapper: wrapperCallOneArg,
        $textsig: "($self, value, /)",
        $flags: { OneArg: true },
        $doc: "Implement self*=value."
      };
      slots.__mul__ = {
        $name: "__mul__",
        $slot_name: "nb$multiply",
        $slot_func: slotFuncOneArg,
        $wrapper: wrapperCallOneArg,
        $textsig: "($self, value, /)",
        $flags: { OneArg: true },
        $doc: "Return self*value."
      };
      slots.__rmul__ = {
        $name: "__rmul__",
        $slot_name: "nb$reflected_multiply",
        $slot_func: slotFuncOneArg,
        $wrapper: wrapperCallOneArg,
        $textsig: "($self, value, /)",
        $flags: { OneArg: true },
        $doc: "Return value*self."
      };
      slots.__isub__ = {
        $name: "__isub__",
        $slot_name: "nb$inplace_subtract",
        $slot_func: slotFuncOneArg,
        $wrapper: wrapperCallOneArg,
        $textsig: "($self, value, /)",
        $flags: { OneArg: true },
        $doc: "Implement self-=value."
      };
      slots.__mod__ = {
        $name: "__mod__",
        $slot_name: "nb$remainder",
        $slot_func: slotFuncOneArg,
        $wrapper: wrapperCallOneArg,
        $textsig: "($self, value, /)",
        $flags: { OneArg: true },
        $doc: "Return self%value."
      };
      slots.__rmod__ = {
        $name: "__rmod__",
        $slot_name: "nb$reflected_remainder",
        $slot_func: slotFuncOneArg,
        $wrapper: wrapperCallOneArg,
        $textsig: "($self, value, /)",
        $flags: { OneArg: true },
        $doc: "Return value%self."
      };
      slots.__imod__ = {
        $name: "__imod__",
        $slot_name: "nb$inplace_remainder",
        $slot_func: slotFuncOneArg,
        $wrapper: wrapperCallOneArg,
        $textsig: "($self, value, /)",
        $flags: { OneArg: true },
        $doc: "Implement value%=self."
      };
      slots.__divmod__ = {
        $name: "__divmod__",
        $slot_name: "nb$divmod",
        $slot_func: slotFuncOneArg,
        $wrapper: wrapperCallOneArg,
        $textsig: "($self, value, /)",
        $flags: { OneArg: true },
        $doc: "Return divmod(self, value)."
      };
      slots.__rdivmod__ = {
        $name: "__rdivmod__",
        $slot_name: "nb$reflected_divmod",
        $slot_func: slotFuncOneArg,
        $wrapper: wrapperCallOneArg,
        $textsig: "($self, value, /)",
        $flags: { OneArg: true },
        $doc: "Return divmod(value, self)"
      };
      slots.__pos__ = {
        $name: "__pos__",
        $slot_name: "nb$positive",
        $slot_func: slotFuncNoArgs,
        $wrapper: wrapperCallNoArgs,
        $textsig: "($self, /)",
        $flags: { NoArgs: true },
        $doc: "+self"
      };
      slots.__neg__ = {
        $name: "__neg__",
        $slot_name: "nb$negative",
        $slot_func: slotFuncNoArgs,
        $wrapper: wrapperCallNoArgs,
        $textsig: "($self, /)",
        $flags: { NoArgs: true },
        $doc: "-self"
      };
      slots.__abs__ = {
        $name: "__abs__",
        $slot_name: "nb$abs",
        $slot_func: slotFuncNoArgs,
        $wrapper: wrapperCallNoArgs,
        $textsig: "($self, /)",
        $flags: { NoArgs: true },
        $doc: "abs(self)"
      };
      slots.__bool__ = {
        $name: "__bool__",
        $slot_name: "nb$bool",
        $slot_func: slotFuncNoArgsWithCheck(
          "__bool__",
          Sk.builtin.checkBool,
          "bool",
          (res) => res.v !== 0
        ),
        $wrapper: wrapperCallBack(wrapperCallNoArgs, (res) => new Sk.builtin.bool(res)),
        $textsig: "($self, /)",
        $flags: { NoArgs: true },
        $doc: "self != 0"
      };
      slots.__invert__ = {
        $name: "__invert__",
        $slot_name: "nb$invert",
        $slot_func: slotFuncNoArgs,
        $wrapper: wrapperCallNoArgs,
        $textsig: "($self, /)",
        $flags: { NoArgs: true },
        $doc: "~self"
      };
      slots.__lshift__ = {
        $name: "__lshift__",
        $slot_name: "nb$lshift",
        $slot_func: slotFuncOneArg,
        $wrapper: wrapperCallOneArg,
        $textsig: "($self, value, /)",
        $flags: { OneArg: true },
        $doc: "Return self<<value."
      };
      slots.__rlshift__ = {
        $name: "__rlshift__",
        $slot_name: "nb$reflected_lshift",
        $slot_func: slotFuncOneArg,
        $wrapper: wrapperCallOneArg,
        $textsig: "($self, value, /)",
        $flags: { OneArg: true },
        $doc: "Return value<<self."
      };
      slots.__rshift__ = {
        $name: "__rshift__",
        $slot_name: "nb$rshift",
        $slot_func: slotFuncOneArg,
        $wrapper: wrapperCallOneArg,
        $textsig: "($self, value, /)",
        $flags: { OneArg: true },
        $doc: "Return self>>value."
      };
      slots.__rrshift__ = {
        $name: "__rrshift__",
        $slot_name: "nb$reflected_rshift",
        $slot_func: slotFuncOneArg,
        $wrapper: wrapperCallOneArg,
        $textsig: "($self, value, /)",
        $flags: { OneArg: true },
        $doc: "Return value>>self."
      };
      slots.__ilshift__ = {
        $name: "__ilshift__",
        $slot_name: "nb$inplace_lshift",
        $slot_func: slotFuncOneArg,
        $wrapper: wrapperCallOneArg,
        $textsig: "($self, value, /)",
        $flags: { OneArg: true },
        $doc: "Implement self<<=value."
      };
      slots.__irshift__ = {
        $name: "__irshift__",
        $slot_name: "nb$inplace_rshift",
        $slot_func: slotFuncOneArg,
        $wrapper: wrapperCallOneArg,
        $textsig: "($self, value, /)",
        $flags: { OneArg: true },
        $doc: "Implement self=>>value."
      };
      slots.__and__ = {
        $name: "__and__",
        $slot_name: "nb$and",
        $slot_func: slotFuncOneArg,
        $wrapper: wrapperCallOneArg,
        $textsig: "($self, value, /)",
        $flags: { OneArg: true },
        $doc: "Return self&value."
      };
      slots.__rand__ = {
        $name: "__rand__",
        $slot_name: "nb$refelcted_and",
        $slot_func: slotFuncOneArg,
        $wrapper: wrapperCallOneArg,
        $textsig: "($self, value, /)",
        $flags: { OneArg: true },
        $doc: "Return value&self."
      };
      slots.__iand__ = {
        $name: "__iand__",
        $slot_name: "nb$and",
        $slot_func: slotFuncOneArg,
        $wrapper: wrapperCallOneArg,
        $textsig: "($self, value, /)",
        $flags: { OneArg: true },
        $doc: "Implement self&=value."
      };
      slots.__xor__ = {
        $name: "__xor__",
        $slot_name: "nb$xor",
        $slot_func: slotFuncOneArg,
        $wrapper: wrapperCallOneArg,
        $textsig: "($self, value, /)",
        $flags: { OneArg: true },
        $doc: "Return self^value."
      };
      slots.__rxor__ = {
        $name: "__rxor__",
        $slot_name: "nb$reflected_xor",
        $slot_func: slotFuncOneArg,
        $wrapper: wrapperCallOneArg,
        $textsig: "($self, value, /)",
        $flags: { OneArg: true },
        $doc: "Return value^self."
      };
      slots.__ixor__ = {
        $name: "__ixor__",
        $slot_name: "nb$inplace_xor",
        $slot_func: slotFuncOneArg,
        $wrapper: wrapperCallOneArg,
        $textsig: "($self, value, /)",
        $flags: { OneArg: true },
        $doc: "Implement self^=value."
      };
      slots.__or__ = {
        $name: "__or__",
        $slot_name: "nb$or",
        $slot_func: slotFuncOneArg,
        $wrapper: wrapperCallOneArg,
        $textsig: "($self, value, /)",
        $flags: { OneArg: true },
        $doc: "Return self|value."
      };
      slots.__ror__ = {
        $name: "__ror__",
        $slot_name: "nb$reflected_or",
        $slot_func: slotFuncOneArg,
        $wrapper: wrapperCallOneArg,
        $textsig: "($self, value, /)",
        $flags: { OneArg: true },
        $doc: "Return value|self."
      };
      slots.__ior__ = {
        $name: "__ior__",
        $slot_name: "nb$inplace_or",
        $slot_func: slotFuncOneArg,
        $wrapper: wrapperCallOneArg,
        $textsig: "($self, value, /)",
        $flags: { OneArg: true },
        $doc: "Implement self|=value."
      };
      slots.__int__ = {
        $name: "__int__",
        $slot_name: "nb$int",
        $slot_func: slotFuncNoArgsWithCheck("__int__", Sk.builtin.checkInt, "int"),
        $wrapper: wrapperCallNoArgs,
        $textsig: "($self, /)",
        $flags: { NoArgs: true },
        $doc: "int(self)"
      };
      slots.__float__ = {
        $name: "__float__",
        $slot_name: "nb$float",
        $slot_func: slotFuncNoArgsWithCheck("__float__", Sk.builtin.checkFloat, "float"),
        $wrapper: wrapperCallNoArgs,
        $textsig: "($self, /)",
        $flags: { NoArgs: true },
        $doc: "float(self)"
      };
      slots.__floordiv__ = {
        $name: "__floordiv__",
        $slot_name: "nb$floor_divide",
        $slot_func: slotFuncOneArg,
        $wrapper: wrapperCallOneArg,
        $textsig: "($self, value, /)",
        $flags: { OneArg: true },
        $doc: "Return self//value."
      };
      slots.__rfloordiv__ = {
        $name: "__rfloordiv__",
        $slot_name: "nb$reflected_floor_divide",
        $slot_func: slotFuncOneArg,
        $wrapper: wrapperCallOneArg,
        $textsig: "($self, value, /)",
        $flags: { OneArg: true },
        $doc: "Return value//self."
      };
      slots.__ifloordiv__ = {
        $name: "__ifloordiv__",
        $slot_name: "nb$inplace_floor_divide",
        $slot_func: slotFuncOneArg,
        $wrapper: wrapperCallOneArg,
        $textsig: "($self, value, /)",
        $flags: { OneArg: true },
        $doc: "Implement self//=value."
      };
      slots.__truediv__ = {
        $name: "__truediv__",
        $slot_name: "nb$divide",
        $slot_func: slotFuncOneArg,
        $wrapper: wrapperCallOneArg,
        $textsig: "($self, value, /)",
        $flags: { OneArg: true },
        $doc: "Return self/value."
      };
      slots.__rtruediv__ = {
        $name: "__rtruediv__",
        $slot_name: "nb$reflected_divide",
        $slot_func: slotFuncOneArg,
        $wrapper: wrapperCallOneArg,
        $textsig: "($self, value, /)",
        $flags: { OneArg: true },
        $doc: "Return value/self."
      };
      slots.__itruediv__ = {
        $name: "__itruediv__",
        $slot_name: "nb$inplace_divide",
        $slot_func: slotFuncOneArg,
        $wrapper: wrapperCallOneArg,
        $textsig: "($self, value, /)",
        $flags: { OneArg: true },
        $doc: "Implement self/=value."
      };
      slots.__index__ = {
        $name: "__index__",
        $slot_name: "nb$index",
        $slot_func: slotFuncNoArgsWithCheck("__index__", Sk.builtin.checkInt, "int", (res) => res.v),
        $wrapper: wrapperCallBack(wrapperCallNoArgs, (res) => new Sk.builtin.int_(res)),
        $textsig: "($self, /)",
        $flags: { NoArgs: true },
        $doc: "Return self converted to an integer, if self is suitable for use as an index into a list."
      };
      slots.__pow__ = {
        $name: "__pow__",
        $slot_name: "nb$power",
        $slot_func: function(dunderFunc) {
          return function(value, mod) {
            const func = dunderFunc.tp$descr_get ? dunderFunc.tp$descr_get(this) : dunderFunc;
            if (mod == void 0) {
              return Sk.misceval.callsimArray(func, [value]);
            } else {
              return Sk.misceval.callsimArray(func, [value, mod]);
            }
          };
        },
        $wrapper: wrapperCallTernary,
        $textsig: "($self, value, mod=None, /)",
        $flags: { MinArgs: 1, MaxArgs: 2 },
        $doc: "Return pow(self, value, mod)."
      };
      slots.__rpow__ = {
        $name: "__rpow__",
        $slot_name: "nb$reflected_power",
        $slot_func: slots.__pow__.$slot_func,
        $wrapper: wrapperCallTernary,
        $textsig: "($self, value, mod=None, /)",
        $flags: { MinArgs: 1, MaxArgs: 2 },
        $doc: "Return pow(value, self, mod)."
      };
      slots.__ipow__ = {
        $name: "__ipow__",
        $slot_name: "nb$inplace_power",
        $slot_func: slots.__pow__.$slot_func,
        $wrapper: wrapperCallTernary,
        $textsig: "($self, value, mod=None, /)",
        $flags: { MinArgs: 1, MaxArgs: 2 },
        $doc: "Implement **="
      };
      slots.__matmul__ = {
        $name: "__matmul__",
        $slot_name: "nb$matrix_multiply",
        $slot_func: slotFuncOneArg,
        $wrapper: wrapperCallOneArg,
        $textsig: "($self, value, /)",
        $flags: { OneArg: true },
        $doc: "Return self@value."
      };
      slots.__rmatmul__ = {
        $name: "__rmatmul__",
        $slot_name: "nb$reflected_matrix_multiply",
        $slot_func: slotFuncOneArg,
        $wrapper: wrapperCallOneArg,
        $textsig: "($self, value, /)",
        $flags: { OneArg: true },
        $doc: "Return value@self."
      };
      slots.__imatmul__ = {
        $name: "__imatmul__",
        $slot_name: "nb$inplace_matrix_multiply",
        $slot_func: slotFuncOneArg,
        $wrapper: wrapperCallOneArg,
        $textsig: "($self, value, /)",
        $flags: { OneArg: true },
        $doc: "Implement self@=value."
      };
      slots.__long__ = {
        $name: "__long__",
        $slot_name: "nb$long",
        $slot_func: slotFuncNoArgsWithCheck("__long__", Sk.builtin.checkInt, "int"),
        $wrapper: wrapperCallNoArgs,
        $textsig: "($self, /)",
        $flags: { NoArgs: true },
        $doc: "int(self)"
      };
      var py3$slots;
      var py2$slots = {
        next: {
          $name: "next",
          $slot_name: "tp$iternext",
          $slot_func: slots.__next__.$slot_func,
          $wrapper: slots.__next__.$wrapper,
          $textsig: slots.__next__.$textsig,
          $flags: slots.__next__.$flags
        },
        __nonzero__: {
          $name: "__nonzero__",
          $slot_name: "nb$bool",
          $slot_func: slotFuncNoArgsWithCheck(
            "__nonzero__",
            Sk.builtin.checkInt,
            "int",
            (res) => res.v !== 0
          ),
          $wrapper: wrapperCallBack(wrapperCallNoArgs, (res) => new Sk.builtin.bool(res)),
          $textsig: "($self, /)",
          $flags: { NoArgs: true },
          $doc: "x.__nonzero__() <==> x != 0"
        },
        __div__: {
          $name: "__div__",
          $slot_name: "nb$divide",
          $slot_func: slotFuncOneArg,
          $wrapper: wrapperCallOneArg,
          $textsig: "($self, other/)",
          $flags: { OneArg: true },
          $doc: "x.__div__(y) <==> x/y"
        },
        __rdiv__: {
          $name: "__rdiv__",
          $slot_name: "nb$reflected_divide",
          $slot_func: slotFuncOneArg,
          $wrapper: wrapperCallOneArg,
          $textsig: "($self, other/)",
          $flags: { OneArg: true },
          $doc: "x.__rdiv__(y) <==> x/y"
        },
        __idiv__: {
          $name: "__idiv__",
          $slot_name: "nb$inplace_divide",
          $slot_func: slotFuncOneArg,
          $wrapper: wrapperCallOneArg,
          $textsig: "($self, other/)",
          $flags: { OneArg: true },
          $doc: "implement self /= other"
        }
      };
      Sk.subSlots = {
        main_slots: Object.entries({
          // nb we handle tp$new differently
          // tp_slots
          tp$init: "__init__",
          tp$call: "__call__",
          $r: "__repr__",
          // tp$hash: "__hash__", // do tp$hash separately since it could be None
          tp$str: "__str__",
          // getattribute, setattr, delattr
          tp$getattr: "__getattribute__",
          tp$setattr: ["__setattr__", "__delattr__"],
          // tp$richcompare
          ob$eq: "__eq__",
          ob$ne: "__ne__",
          ob$lt: "__lt__",
          ob$le: "__le__",
          ob$gt: "__gt__",
          ob$ge: "__ge__",
          // getters and setters
          tp$descr_get: "__get__",
          tp$descr_set: ["__set__", "__delete__"],
          // iter
          tp$iter: "__iter__",
          tp$iternext: "__next__"
        }),
        number_slots: Object.entries({
          nb$abs: "__abs__",
          nb$negative: "__neg__",
          nb$positive: "__pos__",
          nb$int: "__int__",
          nb$long: "__long__",
          nb$float: "__float__",
          nb$index: "__index__",
          nb$add: "__add__",
          nb$reflected_add: "__radd__",
          nb$inplace_add: "__iadd__",
          nb$subtract: "__sub__",
          nb$reflected_subtract: "__rsub__",
          nb$inplace_subtract: "__isub__",
          nb$multiply: "__mul__",
          nb$reflected_multiply: "__rmul__",
          nb$inplace_multiply: "__imul__",
          nb$floor_divide: "__floordiv__",
          nb$reflected_floor_divide: "__rfloordiv__",
          nb$inplace_floor_divide: "__ifloordiv__",
          nb$invert: "__invert__",
          nb$remainder: "__mod__",
          nb$reflected_remainder: "__rmod__",
          nb$inplace_remainder: "__imod__",
          nb$divmod: "__divmod__",
          nb$reflected_divmod: "__rdivmod__",
          nb$power: "__pow__",
          nb$reflected_power: "__rpow__",
          nb$inplace_power: "__ipow__",
          nb$divide: "__truediv__",
          // TODO: think about py2 vs py3 truediv vs div
          nb$reflected_divide: "__rtruediv__",
          nb$inplace_divide: "__itruediv__",
          nb$bool: "__bool__",
          nb$and: "__and__",
          nb$reflected_and: "__rand__",
          nb$inplace_and: "__iand__",
          nb$or: "__or__",
          nb$reflected_or: "__ror__",
          nb$inplace_or: "__ior__",
          nb$xor: "__xor__",
          nb$reflected_xor: "__rxor__",
          nb$inplace_xor: "__ixor__",
          nb$lshift: "__lshift__",
          nb$reflected_lshift: "__rlshift__",
          nb$rshift: "__rshift__",
          nb$reflected_rshift: "__rrshift__",
          nb$inplace_lshift: "__ilshift__",
          nb$inplace_rshift: "__irshift__",
          nb$matrix_multiply: "__matmul__",
          nb$reflected_matrix_multiply: "__rmatmul__",
          nb$inplace_matrix_multiply: "__imatmul__"
        }),
        sequence_and_mapping_slots: Object.entries({
          // sequence and mapping slots
          sq$length: "__len__",
          sq$contains: "__contains__",
          mp$subscript: "__getitem__",
          mp$ass_subscript: ["__setitem__", "__delitem__"],
          nb$add: "__add__",
          nb$multiply: "__mul__",
          nb$reflected_multiply: "__rmul__",
          nb$inplace_add: "__iadd__",
          nb$inplace_multiply: "__imul__"
        })
      };
      Sk.reflectedNumberSlots = {
        nb$add: { reflected: "nb$reflected_add" },
        nb$subtract: {
          reflected: "nb$reflected_subtract",
          slot: function(other) {
            if (other instanceof this.constructor) {
              return other.nb$subtract(this);
            }
            return Sk.builtin.NotImplemented.NotImplemented$;
          }
        },
        nb$multiply: { reflected: "nb$reflected_multiply" },
        nb$divide: {
          reflected: "nb$reflected_divide",
          slot: function(other) {
            if (other instanceof this.constructor) {
              return other.nb$divide(this);
            }
            return Sk.builtin.NotImplemented.NotImplemented$;
          }
        },
        nb$floor_divide: {
          reflected: "nb$reflected_floor_divide",
          slot: function(other) {
            if (other instanceof this.constructor) {
              return other.nb$floor_divide(this);
            }
            return Sk.builtin.NotImplemented.NotImplemented$;
          }
        },
        nb$remainder: {
          reflected: "nb$reflected_remainder",
          slot: function(other) {
            if (other instanceof this.constructor) {
              return other.nb$remainder(this);
            }
            return Sk.builtin.NotImplemented.NotImplemented$;
          }
        },
        nb$divmod: {
          reflected: "nb$reflected_divmod",
          slot: function(other) {
            if (other instanceof this.constructor) {
              return other.nb$divmod(this);
            }
            return Sk.builtin.NotImplemented.NotImplemented$;
          }
        },
        nb$power: {
          reflected: "nb$reflected_power",
          slot: function(other, mod) {
            if (other instanceof this.constructor) {
              return other.nb$power(this, mod);
            }
            return Sk.builtin.NotImplemented.NotImplemented$;
          }
        },
        nb$and: { reflected: "nb$reflected_and" },
        nb$or: { reflected: "nb$reflected_or" },
        nb$xor: { reflected: "nb$reflected_xor" },
        nb$lshift: {
          reflected: "nb$reflected_lshift",
          slot: function(other) {
            if (other instanceof this.constructor) {
              return other.nb$lshift(this);
            }
            return Sk.builtin.NotImplemented.NotImplemented$;
          }
        },
        nb$rshift: {
          reflected: "nb$reflected_rshift",
          slot: function(other) {
            if (other instanceof this.constructor) {
              return other.nb$rshift(this);
            }
            return Sk.builtin.NotImplemented.NotImplemented$;
          }
        },
        nb$matrix_multiply: {
          reflected: "nb$reflexted_matrix_multiply",
          slot: function(other) {
            if (other instanceof this.constructor) {
              return other.nb$matrix_multiply(this);
            }
            return Sk.builtin.NotImplemented.NotImplemented$;
          }
        }
      };
      Sk.sequenceAndMappingSlots = {
        sq$concat: ["nb$add"],
        sq$repeat: ["nb$multiply", "nb$reflected_multiply"],
        mp$length: ["sq$length"],
        sq$inplace_repeat: ["nb$inplace_multiply"],
        sq$inplace_concat: ["nb$inplace_add"]
      };
      Sk.dunderToSkulpt = {
        __repr__: "$r",
        __str__: "tp$str",
        __init__: "tp$init",
        __new__: "tp$new",
        __hash__: "tp$hash",
        __call__: "tp$call",
        __iter__: "tp$iter",
        __next__: "tp$iternext",
        __eq__: "ob$eq",
        __ne__: "ob$ne",
        __lt__: "ob$lt",
        __le__: "ob$le",
        __gt__: "ob$gt",
        __ge__: "ob$ge",
        __abs__: "nb$abs",
        __neg__: "nb$negative",
        __pos__: "nb$positive",
        __int__: "nb$int",
        __float__: "nb$float",
        __index__: "nb$index",
        __add__: "nb$add",
        __radd__: "nb$reflected_add",
        __iadd__: "nb$inplace_add",
        __sub__: "nb$subtract",
        __rsub__: "nb$reflected_subtract",
        __isub__: "nb$inplace_subtract",
        __mul__: "nb$multiply",
        __rmul__: "nb$reflected_multiply",
        __imul__: "nb$inplace_multiply",
        __truediv__: "nb$divide",
        __rtruediv__: "nb$reflected_divide",
        __itruediv__: "nb$inplace_divide",
        __floordiv__: "nb$floor_divide",
        __rfloordiv__: "nb$reflected_floor_divide",
        __ifloordiv__: "nb$inplace_floor_divide",
        __invert__: "nb$invert",
        __mod__: "nb$remainder",
        __rmod__: "nb$reflected_remainder",
        __imod__: "nb$inplace_remainder",
        __divmod__: "nb$divmod",
        __rdivmod__: "nb$reflected_divmod",
        //no inplace divmod
        __pow__: "nb$power",
        __rpow__: "nb$reflected_power",
        __ipow__: "nb$inplace_power",
        __bool__: "nb$bool",
        // py2 only
        __long__: "nb$long",
        __lshift__: "nb$lshift",
        __rlshift__: "nb$reflected_lshift",
        __ilshift__: "nb$inplace_lshift",
        __rshift__: "nb$rshift",
        __rrshift__: "nb$reflected_rshift",
        __irshift__: "nb$inplace_rshift",
        __and__: "nb$and",
        __rand__: "nb$reflected_and",
        __iand__: "nb$inplace_and",
        __or__: "nb$or",
        __ror__: "nb$reflected_or",
        __ior__: "nb$inplace_or",
        __xor__: "nb$xor",
        __rxor__: "nb$reflected_xor",
        __ixor__: "nb$inplace_xor",
        __matmul__: "nb$matrix_multiply",
        __rmatmul__: "nb$reflected_matrix_multiply",
        __imatmul__: "nb$inplace_matrix_multiply",
        __get__: "tp$descr_get",
        __set__: "tp$descr_set",
        __delete__: "tp$descr_set",
        __getattribute__: "tp$getattr",
        __getattr__: "tp$getattr",
        __setattr__: "tp$setattr",
        __delattr__: "tp$setattr",
        __len__: "sq$length",
        __contains__: "sq$contains",
        __getitem__: "mp$subscript",
        __setitem__: "mp$ass_subscript",
        __delitem__: "mp$ass_subscript"
      };
      Sk.exportSymbol("Sk.setupDunderMethods", Sk.setupDunderMethods);
      Sk.setupDunderMethods = function(py3) {
        const slots2 = Sk.slots;
        if (py3 && py3$slots === void 0) {
          return;
        }
        const classes_with_next = Sk.abstr.built$iterators;
        const classes_with_bool = [
          Sk.builtin.int_,
          Sk.builtin.lng,
          Sk.builtin.float_,
          Sk.builtin.complex
        ];
        const classes_with_divide = classes_with_bool;
        const number_slots = Sk.subSlots.number_slots;
        const main_slots = Sk.subSlots.main_slots;
        const indexofnext = main_slots.findIndex((x) => x[0] === "tp$iternext");
        const indexofbool = number_slots.findIndex((x) => x[0] === "nb$bool");
        const dunderToSkulpt = Sk.dunderToSkulpt;
        function switch_version(classes_with, old_meth, new_meth) {
          for (let i = 0; i < classes_with.length; i++) {
            const cls_proto = classes_with[i].prototype;
            if (cls_proto.hasOwnProperty(new_meth)) {
              continue;
            }
            cls_proto[new_meth] = cls_proto[old_meth];
            delete cls_proto[old_meth];
          }
        }
        if (py3) {
          dunderToSkulpt.__bool__ = "nb$bool";
          dunderToSkulpt.__next__ = "tp$iternext";
          delete dunderToSkulpt.__nonzero__;
          delete dunderToSkulpt.__div__;
          delete dunderToSkulpt.__rdiv__;
          delete dunderToSkulpt.__idiv__;
          delete dunderToSkulpt.next;
          for (let slot_name in py3$slots) {
            slots2[slot_name] = py3$slots[slot_name];
          }
          for (let slot_name in py2$slots) {
            delete slots2[slot_name];
          }
          for (let i = 0; i < classes_with_divide.length; i++) {
            const cls_proto = classes_with_divide[i].prototype;
            delete cls_proto.__div__;
            delete cls_proto.__rdiv__;
          }
          main_slots[indexofnext][1] = "__next__";
          number_slots[indexofbool][1] = "__bool__";
          switch_version(classes_with_next, "next", "__next__");
          switch_version(classes_with_bool, "__bool__", "__nonzero__");
        } else {
          if (py3$slots === void 0) {
            slots2.py3$slots = {
              __next__: slots2.__next__
            };
            py3$slots = slots2.py3$slots;
          }
          dunderToSkulpt.next = "tp$iternext";
          dunderToSkulpt.__nonzero__ = "nb$bool";
          dunderToSkulpt.__div__ = "nb$divide";
          dunderToSkulpt.__rdiv__ = "nb$reflected_divide";
          dunderToSkulpt.__idiv__ = "nb$inplace_divide";
          delete dunderToSkulpt.__bool__;
          delete dunderToSkulpt.__next__;
          for (let slot_name in py2$slots) {
            slots2[slot_name] = py2$slots[slot_name];
          }
          for (let slot_name in py3$slots) {
            delete slots2[slot_name];
          }
          main_slots[indexofnext][1] = "next";
          number_slots[indexofbool][1] = "__nonzero__";
          switch_version(classes_with_next, "__next__", "next");
          switch_version(classes_with_bool, "__nonzero__", "__bool__");
          for (let i = 0; i < classes_with_divide.length; i++) {
            const cls = classes_with_divide[i];
            const cls_proto = cls.prototype;
            if (cls_proto.hasOwnProperty("__div__")) {
              continue;
            }
            cls_proto.__div__ = new Sk.builtin.wrapper_descriptor(
              cls,
              py2$slots.__div__,
              cls_proto.nb$divide
            );
            cls_proto.__rdiv__ = new Sk.builtin.wrapper_descriptor(
              cls,
              py2$slots.__rdiv__,
              Sk.reflectedNumberSlots.nb$divide.slot
            );
          }
        }
      };
    }
  });

  // src/descr.js
  var require_descr = __commonJS({
    "src/descr.js"() {
      function buildDescriptor(type_name, repr_name, descr_options) {
        const descr = Sk.abstr.buildNativeClass(type_name, {
          constructor: descr_options.constructor,
          slots: Object.assign(
            {
              tp$getattr: Sk.generic.getAttr,
              $r: descriptorRepr
            },
            descr_options.slots
          ),
          getsets: Object.assign(descr_options.getsets || {}, descriptorGetsets),
          proto: (
            /**@lends {descr_object.prototype}*/
            Object.assign(descr_options.proto || {}, {
              d$repr_name: repr_name || type_name,
              d$check: descriptorCheck,
              d$set_check: descriptorSetCheck
            })
          ),
          flags: { sk$unacceptableBase: true }
        });
        return descr;
      }
      function descriptorCheck(obj) {
        if (obj == null) {
          return this;
        } else if (!obj.ob$type.$isSubType(this.d$type)) {
          throw new Sk.builtin.TypeError(
            "descriptor '" + this.d$name + "' requires a '" + this.d$type.prototype.tp$name + "' object but received a '" + Sk.abstr.typeName(obj) + "' object"
          );
        }
        return;
      }
      function descriptorSetCheck(obj) {
        if (!obj.ob$type.$isSubType(this.d$type)) {
          throw new Sk.builtin.TypeError(
            "descriptor '" + this.d$name + "' requires a '" + this.d$type.prototype.tp$name + "' object but received a '" + Sk.abstr.typeName(obj) + "' object"
          );
        }
      }
      function descriptorRepr() {
        return new Sk.builtin.str(
          "<" + this.d$repr_name + " '" + this.d$name + "' of '" + this.d$type.prototype.tp$name + "' objects>"
        );
      }
      var descriptorGetsets = {
        __doc__: {
          $get() {
            return this.d$def.$doc ? new Sk.builtin.str(this.d$def.$doc) : Sk.builtin.none.none$;
          }
        },
        __objclass__: {
          $get() {
            return this.d$type;
          }
        },
        __name__: {
          $get() {
            return new Sk.builtin.str(this.d$name);
          }
        }
      };
      var descrTextSig = {
        __text_signature__: {
          $get() {
            return this.d$def.$textsig ? new Sk.builtin.str(this.d$def.$textsig) : Sk.builtin.none.none$;
          }
        }
      };
      Sk.builtin.getset_descriptor = buildDescriptor("getset_descriptor", void 0, {
        constructor: function getset_descr(typeobj, getset_def) {
          this.d$def = getset_def;
          this.$get = getset_def.$get;
          this.$set = getset_def.$set;
          this.d$type = typeobj;
          this.d$name = getset_def.$name;
        },
        slots: {
          tp$descr_get(obj, type) {
            let ret;
            if (ret = this.d$check(obj)) {
              return ret;
            }
            if (this.$get !== void 0) {
              return this.$get.call(obj);
            }
            throw new Sk.builtin.AttributeError(
              "getset_descriptor '" + this.d$name + "' of '" + this.d$type.prototype.tp$name + "' objects is not readable"
            );
          },
          tp$descr_set(obj, value) {
            this.d$set_check(obj);
            if (this.$set !== void 0) {
              return this.$set.call(obj, value);
            }
            throw new Sk.builtin.AttributeError(
              "attribute '" + this.d$name + "' of '" + this.d$type.prototype.tp$name + "' objects is readonly"
            );
          }
        }
      });
      Sk.builtin.method_descriptor = buildDescriptor("method_descriptor", "method", {
        constructor: function method_descriptor(typeobj, method_def) {
          this.d$def = method_def;
          this.$meth = method_def.$meth;
          this.d$type = typeobj;
          this.d$name = method_def.$name || "<native JS>";
          const flags = method_def.$flags || {};
          this.$flags = flags;
          if (flags.FastCall && flags.NoKwargs) {
            this.tp$call = this.$methodFastCallNoKwargs;
          } else if (flags.FastCall) {
            this.tp$call = this.$methodFastCall;
          } else if (flags.NoArgs) {
            this.tp$call = this.$methodCallNoArgs;
          } else if (flags.OneArg) {
            this.tp$call = this.$methodCallOneArg;
          } else if (flags.NamedArgs) {
            this.tp$call = this.$methodCallNamedArgs;
          } else if (flags.MinArgs !== void 0) {
            this.tp$call = this.$methodCallMinArgs;
          } else {
            this.func_code = method_def.$meth;
            this.tp$call = this.$defaultCall;
            this.$memoiseFlags = Sk.builtin.func.prototype.$memoiseFlags;
            this.$resolveArgs = Sk.builtin.func.prototype.$resolveArgs;
          }
        },
        slots: {
          tp$call(args, kwargs) {
            return this.tp$call(args, kwargs);
          },
          tp$descr_get(obj, type) {
            let ret;
            if (ret = this.d$check(obj)) {
              return ret;
            }
            return new Sk.builtin.sk_method(this.d$def, obj);
          }
        },
        getsets: descrTextSig,
        proto: {
          $methodFastCall(args, kwargs) {
            const self2 = args.shift();
            this.m$checkself(self2);
            return this.$meth.call(self2, args, kwargs);
          },
          $methodFastCallNoKwargs(args, kwargs) {
            const self2 = args.shift();
            this.m$checkself(self2);
            Sk.abstr.checkNoKwargs(this.d$name, kwargs);
            return this.$meth.call(self2, args);
          },
          $methodCallNoArgs(args, kwargs) {
            const self2 = args.shift();
            this.m$checkself(self2);
            Sk.abstr.checkNoArgs(this.d$name, args, kwargs);
            return this.$meth.call(self2);
          },
          $methodCallOneArg(args, kwargs) {
            const self2 = args.shift();
            this.m$checkself(self2);
            Sk.abstr.checkOneArg(this.d$name, args, kwargs);
            return this.$meth.call(self2, args[0]);
          },
          $methodCallNamedArgs(args, kwargs) {
            const self2 = args.shift();
            this.m$checkself(self2);
            args = Sk.abstr.copyKeywordsToNamedArgs(
              this.d$name,
              this.$flags.NamedArgs,
              args,
              kwargs,
              this.$flags.Defaults
            );
            return this.$meth.call(self2, ...args);
          },
          $methodCallMinArgs(args, kwargs) {
            const self2 = args.shift();
            this.m$checkself(self2);
            Sk.abstr.checkNoKwargs(this.d$name, kwargs);
            Sk.abstr.checkArgsLen(this.d$name, args, this.$flags.MinArgs, this.$flags.MaxArgs);
            return this.$meth.call(self2, ...args);
          },
          $defaultCall(args, kwargs) {
            this.m$checkself(args[0]);
            return Sk.builtin.func.prototype.tp$call.call(this, args, kwargs);
          },
          m$checkself(self2) {
            if (self2 === void 0) {
              throw new Sk.builtin.TypeError(
                "descriptor '" + this.d$name + "' of '" + this.d$type.prototype.tp$name + "' object needs an argument"
              );
            }
            this.d$check(self2);
          }
        }
      });
      Sk.builtin.wrapper_descriptor = buildDescriptor("wrapper_descriptor", "slot wrapper", {
        constructor: function wrapper_descriptor(typeobj, slot_def, wrapped) {
          this.d$def = slot_def;
          this.d$type = typeobj;
          this.d$name = wrapped.$name = slot_def.$name;
          this.d$wrapped = wrapped;
        },
        slots: {
          tp$descr_get(obj, type) {
            let ret;
            if (ret = this.d$check(obj)) {
              return ret;
            }
            return new Sk.builtin.method_wrapper(this, obj);
          },
          tp$call(args, kwargs) {
            if (args.length < 1) {
              throw new Sk.builtin.TypeError(
                "descriptor '" + this.d$name + "' of '" + this.d$type.prototype.tp$name + "' object needs an argument"
              );
            }
            const self2 = args.shift();
            if (!self2.ob$type.$isSubType(this.d$type)) {
              throw new Sk.builtin.TypeError(
                "descriptor '" + this.d$name + "' requires a '" + this.d$type.prototype.tp$name + "' object but received a '" + Sk.abstr.typeName(self2) + "'"
              );
            }
            return this.raw$call(self2, args, kwargs);
          }
        },
        proto: {
          raw$call(self2, args, kwargs) {
            this.d$wrapped.$name = this.d$name;
            return this.d$def.$wrapper.call(this.d$wrapped, self2, args, kwargs);
          }
        }
      });
      Sk.builtin.method_wrapper = buildDescriptor("method_wrapper", void 0, {
        constructor: function method_wrapper(wrapper_descr, self2) {
          this.m$descr = wrapper_descr;
          this.m$self = self2;
          this.d$def = wrapper_descr.d$def;
          this.d$name = wrapper_descr.d$name;
          this.d$type = wrapper_descr.d$type;
        },
        slots: {
          tp$call(args, kwargs) {
            return this.m$descr.raw$call(this.m$self, args, kwargs);
          },
          tp$richcompare(other, op) {
            if (op !== "Eq" && op !== "NotEq" || !(other instanceof Sk.builtin.method_wrapper)) {
              return Sk.builtin.NotImplemented.NotImplemented$;
            }
            let eq = this.m$self === other.m$self && this.m$descr === other.m$descr;
            return op === "Eq" ? eq : !eq;
          },
          $r() {
            return new Sk.builtin.str(
              "<method-wrapper '" + this.d$name + "' of " + Sk.abstr.typeName(this.m$self) + " object>"
            );
          }
        },
        getsets: {
          __self__: {
            $get() {
              return this.m$self;
            }
          }
        }
      });
      Sk.builtin.classmethod_descriptor = buildDescriptor("classmethod_descriptor", "method", {
        constructor: function classmethod_descriptor(typeobj, method_def) {
          this.d$def = method_def;
          this.$meth = method_def.$meth;
          this.d$type = typeobj;
          this.d$name = method_def.$name || "<native JS>";
        },
        slots: {
          tp$call(args, kwargs) {
            if (args.length < 1) {
              throw new Sk.builtin.TypeError(
                "descriptor '" + this.d$name + "' of '" + this.d$type.prototype.tp$name + "' object needs an argument"
              );
            }
            const self2 = args.shift();
            const bound = this.tp$descr_get(null, self2);
            return bound.tp$call(args, kwargs);
          },
          tp$descr_get(obj, type, canSuspend) {
            if (type === void 0) {
              if (obj !== null) {
                type = type || obj.ob$type;
              } else {
                throw new Sk.builtin.TypeError(
                  "descriptor '" + this.d$name + "' for type '" + this.d$type.prototype.tp$name + "' needs an object or a type"
                );
              }
            }
            if (type.ob$type !== Sk.builtin.type) {
              throw new Sk.builtin.TypeError(
                "descriptor '" + this.d$name + "' for type '" + this.d$type.prototype.tp$name + "' needs a type not a '" + Sk.abstr.typeName(type) + "' as arg 2"
              );
            }
            if (!type.$isSubType(this.d$type)) {
              throw new Sk.builtin.TypeError(
                "descriptor '" + this.d$name + "' requires a '" + this.d$type.prototype.tp$name + "' object but received a '" + Sk.abstr.typeName(type) + "' object"
              );
            }
            return new Sk.builtin.sk_method(this.d$def, type);
          }
        },
        getsets: descrTextSig
      });
      [
        Sk.builtin.method_descriptor,
        Sk.builtin.getset_descriptor,
        Sk.builtin.wrapper_descriptor,
        Sk.builtin.method_wrapper,
        Sk.builtin.classmethod_descriptor
      ].forEach((cls) => {
        Sk.abstr.setUpSlots(cls);
        Sk.abstr.setUpMethods(cls);
        Sk.abstr.setUpGetSets(cls);
      });
    }
  });

  // src/sk_method.js
  var require_sk_method = __commonJS({
    "src/sk_method.js"() {
      Sk.builtin.sk_method = Sk.abstr.buildNativeClass("builtin_function_or_method", {
        constructor: function builtin_function_or_method(method_def, self2, module2) {
          this.$meth = method_def.$meth.bind(self2);
          this.$doc = method_def.$doc;
          this.$self = self2 || null;
          this.$module = module2 ? new Sk.builtin.str(module2) : null;
          this.$name = method_def.$name || method_def.$meth.name || "<native JS>";
          this.m$def = method_def;
          this.$textsig = method_def.$textsig;
          const flags = method_def.$flags || {};
          this.$flags = flags;
          if (flags.FastCall && flags.NoKwargs) {
            this.tp$call = this.$fastCallNoKwargs;
          } else if (flags.FastCall) {
            this.tp$call = this.$meth;
          } else if (flags.NoArgs) {
            this.tp$call = this.$callNoArgs;
          } else if (flags.OneArg) {
            this.tp$call = this.$callOneArg;
          } else if (flags.NamedArgs) {
            this.tp$call = this.$callNamedArgs;
          } else if (flags.MinArgs !== void 0) {
            this.tp$call = this.$callMinArgs;
          } else {
            this.func_code = this.$meth;
            this.tp$call = this.$defaultCallMethod;
          }
        },
        proto: {
          $fastCallNoKwargs(args, kwargs) {
            Sk.abstr.checkNoKwargs(this.$name, kwargs);
            return this.$meth(args);
          },
          $callNoArgs(args, kwargs) {
            Sk.abstr.checkNoArgs(this.$name, args, kwargs);
            return this.$meth();
          },
          $callOneArg(args, kwargs) {
            Sk.abstr.checkOneArg(this.$name, args, kwargs);
            return this.$meth(args[0]);
          },
          $callNamedArgs(args, kwargs) {
            args = Sk.abstr.copyKeywordsToNamedArgs(
              this.$name,
              this.$flags.NamedArgs,
              args,
              kwargs,
              this.$flags.Defaults
            );
            return this.$meth(...args);
          },
          $callMinArgs(args, kwargs) {
            Sk.abstr.checkNoKwargs(this.$name, kwargs);
            Sk.abstr.checkArgsLen(this.$name, args, this.$flags.MinArgs, this.$flags.MaxArgs);
            return this.$meth(...args);
          },
          $defaultCallMethod(args, kwargs) {
            if (this.$self !== null) {
              return Sk.builtin.func.prototype.tp$call.call(this, [this.$self, ...args], kwargs);
            }
            return Sk.builtin.func.prototype.tp$call.call(this, args, kwargs);
          },
          $memoiseFlags() {
            return Sk.builtin.func.prototype.$memoiseFlags.call(this);
          },
          $resolveArgs() {
            return Sk.builtin.func.prototype.$resolveArgs.call(this);
          }
        },
        flags: { sk$unacceptableBase: true },
        slots: {
          tp$getattr: Sk.generic.getAttr,
          $r() {
            if (this.$self === null) {
              return new Sk.builtin.str("<built-in function " + this.$name + ">");
            }
            return new Sk.builtin.str(
              "<built-in method " + this.$name + " of " + Sk.abstr.typeName(this.$self) + " object>"
            );
          },
          tp$call(args, kwargs) {
            return this.tp$call(args, kwargs);
          },
          tp$richcompare(other, op) {
            if (op !== "Eq" && op !== "NotEq" || !(other instanceof Sk.builtin.sk_method)) {
              return Sk.builtin.NotImplemented.NotImplemented$;
            }
            let eq = this.$self === other.$self && this.m$def.$meth === other.m$def.$meth;
            return op === "Eq" ? eq : !eq;
          }
        },
        getsets: {
          __module__: {
            $get() {
              return this.$module || Sk.builtin.none.none$;
            },
            $set(value) {
              value = value || Sk.builtin.none.none$;
              this.$module = value;
            }
          },
          __doc__: {
            $get() {
              return this.$doc ? new Sk.builtin.str(this.$doc) : Sk.builtin.none.none$;
            }
          },
          __name__: {
            $get() {
              return new Sk.builtin.str(this.$name);
            }
          },
          __text_signature__: {
            $get() {
              return new Sk.builtin.str(this.$textsig);
            }
          },
          __self__: {
            $get() {
              return this.$self || Sk.sysModules.mp$lookup(this.$module) || Sk.builtin.none.none$;
            }
          }
        }
      });
    }
  });

  // src/nonetype.js
  var require_nonetype = __commonJS({
    "src/nonetype.js"() {
      Sk.builtin.none = Sk.abstr.buildNativeClass("NoneType", {
        constructor: function NoneType() {
          return Sk.builtin.none.none$;
        },
        slots: (
          /**@lends {Sk.builtin.none.prototype}*/
          {
            tp$new(args, kwargs) {
              Sk.abstr.checkNoArgs("NoneType", args, kwargs);
              return Sk.builtin.none.none$;
            },
            $r() {
              return new Sk.builtin.str("None");
            },
            tp$as_number: true,
            nb$bool() {
              return false;
            }
          }
        ),
        flags: {
          sk$unacceptableBase: true
        }
      });
      Sk.builtin.none.none$ = /** @type {Sk.builtin.none} */
      Object.create(Sk.builtin.none.prototype, {
        v: { value: null, enumerable: true }
      });
      Sk.builtin.NotImplemented = Sk.abstr.buildNativeClass("NotImplementedType", {
        constructor: function NotImplementedType() {
          return Sk.builtin.NotImplemented.NotImplemented$;
        },
        slots: (
          /**@lends {Sk.builtin.NotImplemented.prototype}*/
          {
            $r() {
              return new Sk.builtin.str("NotImplemented");
            },
            tp$new(args, kwargs) {
              Sk.abstr.checkNoArgs("NotImplementedType", args, kwargs);
              return Sk.builtin.NotImplemented.NotImplemented$;
            }
          }
        ),
        flags: {
          sk$unacceptableBase: true
        }
      });
      Sk.builtin.NotImplemented.NotImplemented$ = /** @type {Sk.builtin.NotImplemented} */
      Object.create(Sk.builtin.NotImplemented.prototype, {
        v: { value: null, enumerable: true }
      });
      var EllipsisType = Sk.abstr.buildNativeClass("ellipsis", {
        constructor: function ellipsis() {
          return Sk.builtin.Ellipsis;
        },
        slots: {
          tp$new(args, kwargs) {
            Sk.abstr.checkNoArgs("ellipsis", args, kwargs);
            return Sk.builtin.Ellipsis;
          },
          $r() {
            return new Sk.builtin.str("Ellipsis");
          }
        },
        flags: {
          sk$unacceptableBase: true
        }
      });
      Sk.builtin.Ellipsis = Object.create(EllipsisType.prototype, { v: { value: "..." } });
    }
  });

  // src/formatting.js
  var require_formatting = __commonJS({
    "src/formatting.js"() {
      var FORMAT_SPEC_REGEX = /^(?:(.)?([<\>\=\^]))?([\+\-\s])?(#)?(0)?(\d+)?(,|_)?(?:\.(\d+))?([bcdeEfFgGnosxX%])?$/;
      var FMT = {
        FILL_CHAR: 1,
        FILL_ALIGN: 2,
        SIGN: 3,
        ALT_FORM: 4,
        ZERO_PAD: 5,
        FIELD_WIDTH: 6,
        COMMA: 7,
        PRECISION: 8,
        CONVERSION_TYPE: 9
      };
      Sk.formatting = {};
      var handleWidth = function(m, r, prefix, isNumber) {
        Sk.asserts.assert(typeof r === "string");
        if (m[FMT.FIELD_WIDTH]) {
          let fieldWidth = parseInt(m[FMT.FIELD_WIDTH], 10);
          let fillChar = m[FMT.FILL_CHAR] || (m[FMT.ZERO_PAD] ? "0" : " ");
          let fillAlign = m[FMT.FILL_ALIGN] || (m[FMT.ZERO_PAD] ? "=" : isNumber ? ">" : "<");
          let nFill = fieldWidth - (r.length + (prefix ? prefix.length : 0));
          if (nFill <= 0) {
            return prefix + r;
          }
          let fill = fillChar.repeat(nFill);
          switch (fillAlign) {
            case "=":
              if (m[FMT.CONVERSION_TYPE] === "s") {
                throw new Sk.builtin.ValueError(
                  "'=' alignment not allowed in string format specifier"
                );
              }
              return prefix + fill + r;
            case ">":
              return fill + prefix + r;
            case "<":
              return prefix + r + fill;
            case "^":
              let idx = Math.floor(nFill / 2);
              return fill.substring(0, idx) + prefix + r + fill.substring(idx);
          }
        }
        return prefix + r;
      };
      var signForNeg = function(m, neg) {
        return neg ? "-" : m[FMT.SIGN] === "+" ? "+" : m[FMT.SIGN] === " " ? " " : "";
      };
      var thousandSep = /\B(?=(\d{3})+(?!\d))/g;
      var otherBaseSep = /\B(?=([A-Za-z0-9]{4})+(?![A-Za-z0-9]))/g;
      var handleInteger = function(m, n, base) {
        Sk.asserts.assert(n instanceof Sk.builtin.int_ || n instanceof Sk.builtin.lng);
        if (m[FMT.PRECISION]) {
          throw new Sk.builtin.ValueError("Precision not allowed in integer format");
        }
        let r = n.str$(base, false);
        let neg = n.nb$isnegative();
        let prefix = signForNeg(m, neg);
        if (m[FMT.ALT_FORM]) {
          if (base === 16) {
            prefix += "0x";
          } else if (base === 8) {
            prefix += "0o";
          } else if (base === 2) {
            prefix += "0b";
          }
        }
        const conversionType = m[FMT.CONVERSION_TYPE];
        if (conversionType === "X") {
          r = r.toUpperCase();
        }
        if (m[FMT.CONVERSION_TYPE] === "n") {
          r = (+r).toLocaleString();
        } else if (m[FMT.COMMA]) {
          const parts = r.split(".");
          const sep = m[FMT.COMMA];
          if (sep === "," && base !== 10) {
            throw new Sk.builtin.ValueError(`Cannot specify ',' with '${conversionType}'`);
          }
          parts[0] = parts[0].replace(base === 10 ? thousandSep : otherBaseSep, sep);
          r = parts.join(".");
        }
        return handleWidth(m, r, prefix, true);
      };
      var formatNumber = function(num, formatSpec, isFractional) {
        if (!formatSpec) {
          return num.str$(10, true);
        }
        let m = formatSpec.match(FORMAT_SPEC_REGEX);
        if (!m) {
          throw new Sk.builtin.ValueError("Invalid format specifier");
        }
        let conversionType = m[FMT.CONVERSION_TYPE];
        if (!conversionType) {
          conversionType = isFractional ? "g" : "d";
        }
        let validConversions = isFractional ? "fFeEgG%" : "bcdoxXnfFeEgG%";
        if (validConversions.indexOf(conversionType) == -1) {
          throw new Sk.builtin.ValueError(
            "Unknown format code '" + m[FMT.CONVERSION_TYPE] + "' for object of type '" + Sk.abstr.typeName(num) + "'"
          );
        }
        switch (conversionType) {
          case "d":
          case "n":
            return handleInteger(m, num, 10);
          case "x":
          case "X":
            return handleInteger(m, num, 16);
          case "o":
            return handleInteger(m, num, 8);
          case "b":
            return handleInteger(m, num, 2);
          case "c": {
            if (m[FMT.SIGN]) {
              throw new Sk.builtin.ValueError(
                "Sign not allowed with integer format specifier 'c'"
              );
            }
            if (m[FMT.ALT_FORM]) {
              throw new Sk.builtin.ValueError(
                "Alternate form not allowed with integer format specifier 'c'"
              );
            }
            if (m[FMT.COMMA]) {
              throw new Sk.builtin.ValueError("Cannot specify ',' with 'c'");
            }
            if (m[FMT.PRECISION]) {
              throw new Sk.builtin.ValueError("Cannot specify ',' with 'c'");
            }
            return handleWidth(m, String.fromCodePoint(Sk.builtin.asnum$(num)), "", true);
          }
          case "f":
          case "F":
          case "e":
          case "E":
          case "g":
          case "G": {
            if (m[FMT.ALT_FORM]) {
              throw new Sk.builtin.ValueError(
                "Alternate form (#) not allowed in float format specifier"
              );
            }
            let convValue = Sk.builtin.asnum$(num);
            if (typeof convValue === "string") {
              convValue = Number(convValue);
            }
            if (convValue === Infinity) {
              return handleWidth(m, "inf", "", true);
            }
            if (convValue === -Infinity) {
              return handleWidth(m, "inf", "-", true);
            }
            if (isNaN(convValue)) {
              return handleWidth(m, "nan", "", true);
            }
            let neg = false;
            if (convValue < 0) {
              convValue = -convValue;
              neg = true;
            }
            let convName = ["toExponential", "toFixed", "toPrecision"]["efg".indexOf(conversionType.toLowerCase())];
            let precision = m[FMT.PRECISION] ? parseInt(m[FMT.PRECISION], 10) : 6;
            let result = convValue[convName](precision);
            if ("EFG".indexOf(conversionType) !== -1) {
              result = result.toUpperCase();
            }
            if (conversionType.toLowerCase() === "g" || !m[FMT.CONVERSION_TYPE]) {
              let trailingZeros = result.match(/\.(\d*[1-9])?(0+)$/);
              if (trailingZeros) {
                let [_, hasMoreDigits, zs] = trailingZeros;
                result = result.slice(0, hasMoreDigits ? -zs.length : -(zs.length + 1));
              }
              if (result.indexOf(".") == -1 && !m[FMT.CONVERSION_TYPE]) {
                result += ".0";
              }
            }
            if (conversionType.toLowerCase() === "e") {
              result = result.replace(/^([-+]?[0-9]*\.?[0-9]+[eE][-+]?)([0-9])?$/, "$10$2");
            }
            if (m[FMT.COMMA]) {
              var parts = result.toString().split(".");
              parts[0] = parts[0].replace(/\B(?=(\d{3})+(?!\d))/g, ",");
              result = parts.join(".");
            }
            return handleWidth(m, result, signForNeg(m, neg), true);
          }
          case "%": {
            if (m[FMT.ALT_FORM]) {
              throw new Sk.builtin.ValueError(
                "Alternate form (#) not allowed with format specifier '%'"
              );
            }
            let convValue = Sk.builtin.asnum$(num);
            if (typeof convValue === "string") {
              convValue = Number(convValue);
            }
            if (convValue === Infinity) {
              return handleWidth(m, "inf%", "", true);
            }
            if (convValue === -Infinity) {
              return handleWidth(m, "inf%", "-", true);
            }
            if (isNaN(convValue)) {
              return handleWidth(m, "nan%", "", true);
            }
            let neg = false;
            if (convValue < 0) {
              convValue = -convValue;
              neg = true;
            }
            let precision = m[FMT.PRECISION] ? parseInt(m[FMT.PRECISION], 10) : 6;
            let result = (convValue * 100).toFixed(precision) + "%";
            return handleWidth(m, result, signForNeg(m, neg), true);
          }
          default:
            throw new Sk.builtin.ValueError("Unknown format code '" + m[FMT.CONVERSION_TYPE] + "'");
        }
      };
      Sk.formatting.mkNumber__format__ = (isFractional) => function(format_spec) {
        if (!Sk.builtin.checkString(format_spec)) {
          throw new Sk.builtin.TypeError(
            "format() argument 2 must be str, not " + Sk.abstr.typeName(format_spec)
          );
        }
        return new Sk.builtin.str(formatNumber(this, format_spec.$jsstr(), isFractional));
      };
      function formatString(format_spec) {
        if (!Sk.builtin.checkString(format_spec)) {
          throw new Sk.builtin.TypeError(
            "format() argument 2 must be str, not " + Sk.abstr.typeName(format_spec)
          );
        }
        let m = format_spec.$jsstr().match(FORMAT_SPEC_REGEX);
        if (m[FMT.CONVERSION_TYPE] && m[FMT.CONVERSION_TYPE] !== "s") {
          throw new Sk.builtin.ValueError(
            "Unknown format code '" + m[FMT.CONVERSION_TYPE] + "' for object of type 'str'"
          );
        }
        if (m[FMT.SIGN]) {
          throw new Sk.builtin.ValueError("Sign not allowed in string format specifier");
        }
        if (m[FMT.ALT_FORM]) {
          throw new Sk.builtin.ValueError(
            "Alternate form (#) not allowed with string format specifier"
          );
        }
        if (m[FMT.COMMA]) {
          throw new Sk.builtin.ValueError("Cannot specify ',' with 's'");
        }
        let value = this.v;
        if (m[FMT.PRECISION]) {
          value = value.substring(0, m[FMT.PRECISION]);
        }
        return new Sk.builtin.str(handleWidth(m, value, "", false));
      }
      function format(args, kwargs) {
        kwargs = kwargs || [];
        const arg_dict = {};
        const regex = /{(((?:\d+)|(?:\w+))?((?:\.(\w+))|(?:\[((?:\d+)|(?:\w+))\])?))?(?:\!([rs]))?(?:\:([^}]*))?}/g;
        for (let i = 0; i < kwargs.length; i += 2) {
          arg_dict[kwargs[i]] = kwargs[i + 1];
        }
        for (let i in args) {
          arg_dict[i] = args[i];
        }
        let index = 0;
        function replFunc(substring, field_name, arg_name, attr_name, attribute_name, element_index, conversion, format_spec, offset, str_whole) {
          let value;
          if (element_index !== void 0 && element_index !== "") {
            let container = arg_dict[arg_name];
            if (container.constructor === Array) {
              value = container[element_index];
            } else if (/^\d+$/.test(element_index)) {
              value = Sk.abstr.objectGetItem(
                container,
                new Sk.builtin.int_(parseInt(element_index, 10)),
                false
              );
            } else {
              value = Sk.abstr.objectGetItem(container, new Sk.builtin.str(element_index), false);
            }
            index++;
          } else if (attribute_name !== void 0 && attribute_name !== "") {
            value = Sk.abstr.gattr(
              arg_dict[arg_name || index++],
              new Sk.builtin.str(attribute_name)
            );
          } else if (arg_name !== void 0 && arg_name !== "") {
            value = arg_dict[arg_name];
          } else if (field_name === void 0 || field_name === "") {
            value = arg_dict[index];
            index++;
          } else if (field_name instanceof Sk.builtin.int_ || field_name instanceof Sk.builtin.float_ || field_name instanceof Sk.builtin.lng || /^\d+$/.test(field_name)) {
            value = arg_dict[field_name];
            index++;
          }
          if (conversion === "s") {
            value = new Sk.builtin.str(value);
          } else if (conversion === "r") {
            value = Sk.builtin.repr(value);
          } else if (conversion !== "" && conversion !== void 0) {
            throw new Sk.builtin.ValueError("Unknown conversion specifier " + conversion);
          }
          return Sk.abstr.objectFormat(value, new Sk.builtin.str(format_spec)).$jsstr();
        }
        const ret = this.v.replace(regex, replFunc);
        return new Sk.builtin.str(ret);
      }
      Sk.formatting.format = format;
      Sk.formatting.formatString = formatString;
    }
  });

  // src/str.js
  var require_str = __commonJS({
    "src/str.js"() {
      var keyhash_regex = /^[0-9!#_]/;
      var interned = /* @__PURE__ */ Object.create(null);
      function getInterned(x) {
        return interned[x];
      }
      function setInterned(x, pyStr) {
        interned[x] = pyStr;
      }
      Sk.builtin.str = Sk.abstr.buildNativeClass("str", {
        constructor: function str(x) {
          Sk.asserts.assert(this instanceof Sk.builtin.str, "bad call to str - use 'new'");
          let ret;
          if (typeof x === "string") {
            ret = x;
          } else if (x === void 0) {
            ret = "";
          } else if (x === null) {
            ret = "None";
          } else if (x.tp$str !== void 0) {
            return x.tp$str();
          } else if (typeof x === "number") {
            ret = Number.isFinite(x) ? String(x) : String(x).replace("Infinity", "inf").replace("NaN", "nan");
          } else {
            throw new Sk.builtin.TypeError(
              "could not convert object of type '" + Sk.abstr.typeName(x) + "' to str"
            );
          }
          const interned2 = getInterned(ret);
          if (interned2 !== void 0) {
            return interned2;
          } else {
            setInterned(ret, this);
          }
          this.$mangled = fixReserved(ret);
          this.$savedKeyHash = ret.replace(keyhash_regex, "!$&");
          this.v = ret;
        },
        slots: (
          /**@lends {Sk.builtin.str.prototype} */
          {
            tp$getattr: Sk.generic.getAttr,
            tp$as_sequence_or_mapping: true,
            tp$doc: "str(object='') -> str\nstr(bytes_or_buffer[, encoding[, errors]]) -> str\n\nCreate a new string object from the given object. If encoding or\nerrors is specified, then the object must expose a data buffer\nthat will be decoded using the given encoding and error handler.\nOtherwise, returns the result of object.__str__() (if defined)\nor repr(object).\nencoding defaults to sys.getdefaultencoding().\nerrors defaults to 'strict'.",
            tp$new(args, kwargs) {
              kwargs = kwargs || [];
              if (this !== Sk.builtin.str.prototype) {
                return this.$subtype_new(args, kwargs);
              }
              if (args.length <= 1 && !kwargs.length) {
                return new Sk.builtin.str(args[0]);
              } else if (!Sk.__future__.python3) {
                throw new Sk.builtin.TypeError(
                  "str takes at most one argument (" + (args.length + kwargs.length) + " given)"
                );
              } else {
                const [x, encoding, errors] = Sk.abstr.copyKeywordsToNamedArgs(
                  "str",
                  ["object", "encoding", "errors"],
                  args,
                  kwargs
                );
                if (x === void 0 || encoding === void 0 && errors === void 0) {
                  return new Sk.builtin.str(x);
                }
                Sk.builtin.bytes.check$encodeArgs("str", encoding, errors);
                if (!Sk.builtin.checkBytes(x)) {
                  throw new Sk.builtin.TypeError(
                    "decoding to str: need a bytes-like object, " + Sk.abstr.typeName(x) + " found"
                  );
                }
                return Sk.builtin.bytes.$decode.call(x, encoding, errors);
              }
            },
            $r() {
              let quote = "'";
              if (this.v.indexOf("'") !== -1 && this.v.indexOf('"') === -1) {
                quote = '"';
              }
              const len = this.v.length;
              let c, cc, ret = quote;
              for (let i = 0; i < len; i++) {
                c = this.v.charAt(i);
                cc = this.v.charCodeAt(i);
                if (c === quote || c === "\\") {
                  ret += "\\" + c;
                } else if (c === "	") {
                  ret += "\\t";
                } else if (c === "\n") {
                  ret += "\\n";
                } else if (c === "\r") {
                  ret += "\\r";
                } else if ((cc > 255 && cc < 55296 || cc >= 57344) && !Sk.__future__.python3) {
                  ret += "\\u" + ("000" + cc.toString(16)).slice(-4);
                } else if (cc >= 55296 && !Sk.__future__.python3) {
                  let val = this.v.codePointAt(i);
                  i++;
                  val = val.toString(16);
                  let s = "0000000" + val.toString(16);
                  if (val.length > 4) {
                    ret += "\\U" + s.slice(-8);
                  } else {
                    ret += "\\u" + s.slice(-4);
                  }
                } else if (cc > 255 && !Sk.__future__.python3) {
                  ret += "\\ufffd";
                } else if (c < " " || cc >= 127 && !Sk.__future__.python3) {
                  let ashex = c.charCodeAt(0).toString(16);
                  if (ashex.length < 2) {
                    ashex = "0" + ashex;
                  }
                  ret += "\\x" + ashex;
                } else {
                  ret += c;
                }
              }
              ret += quote;
              return new Sk.builtin.str(ret);
            },
            tp$str() {
              if (this.constructor === Sk.builtin.str) {
                return this;
              } else {
                return new Sk.builtin.str(this.v);
              }
            },
            tp$iter() {
              return new str_iter_(this);
            },
            tp$richcompare(other, op) {
              if (!(other instanceof Sk.builtin.str)) {
                return Sk.builtin.NotImplemented.NotImplemented$;
              }
              switch (op) {
                case "Lt":
                  return this.v < other.v;
                case "LtE":
                  return this.v <= other.v;
                case "Eq":
                  return this.v === other.v;
                case "NotEq":
                  return this.v !== other.v;
                case "Gt":
                  return this.v > other.v;
                case "GtE":
                  return this.v >= other.v;
              }
            },
            mp$subscript(index) {
              let len;
              if (Sk.misceval.isIndex(index)) {
                index = Sk.misceval.asIndexSized(index, Sk.builtin.OverflowError);
                len = this.sq$length();
                if (index < 0) {
                  index = index + len;
                }
                if (index < 0 || index >= len) {
                  throw new Sk.builtin.IndexError("string index out of range");
                }
                if (this.codepoints) {
                  return new Sk.builtin.str(
                    this.v.substring(this.codepoints[index], this.codepoints[index + 1])
                  );
                } else {
                  return new Sk.builtin.str(this.v.charAt(index));
                }
              } else if (index instanceof Sk.builtin.slice) {
                let ret = "";
                len = this.sq$length();
                if (this.codepoints) {
                  index.sssiter$(len, (i) => {
                    ret += this.v.substring(this.codepoints[i], this.codepoints[i + 1]);
                  });
                } else {
                  index.sssiter$(len, (i) => {
                    ret += this.v.charAt(i);
                  });
                }
                return new Sk.builtin.str(ret);
              }
              throw new Sk.builtin.TypeError(
                "string indices must be integers, not " + Sk.abstr.typeName(index)
              );
            },
            sq$length() {
              return this.$hasAstralCodePoints() ? this.codepoints.length : this.v.length;
            },
            sq$concat(other) {
              if (!(other instanceof Sk.builtin.str)) {
                throw new Sk.builtin.TypeError(
                  "cannot concatenate 'str' and '" + Sk.abstr.typeName(other) + "' objects"
                );
              }
              return new Sk.builtin.str(this.v + other.v);
            },
            sq$repeat(n) {
              if (!Sk.misceval.isIndex(n)) {
                throw new Sk.builtin.TypeError(
                  "can't multiply sequence by non-int of type '" + Sk.abstr.typeName(n) + "'"
                );
              }
              n = Sk.misceval.asIndexSized(n, Sk.builtin.OverflowError);
              if (n * this.v.length > Number.MAX_SAFE_INTEGER) {
                throw new Sk.builtin.OverflowError();
              }
              let ret = "";
              for (let i = 0; i < n; i++) {
                ret += this.v;
              }
              return new Sk.builtin.str(ret);
            },
            sq$contains(ob) {
              if (!(ob instanceof Sk.builtin.str)) {
                throw new Sk.builtin.TypeError(
                  "'in <string>' requires string as left operand not " + Sk.abstr.typeName(ob)
                );
              }
              return this.v.indexOf(ob.v) !== -1;
            },
            tp$as_number: true,
            nb$remainder: strBytesRemainder
          }
        ),
        proto: (
          /**@lends {Sk.builtin.str.prototype} */
          {
            toString() {
              return this.v;
            },
            $subtype_new(args, kwargs) {
              const instance = new this.constructor();
              const str_instance = Sk.builtin.str.prototype.tp$new(args, kwargs);
              instance.$mangled = str_instance.$mangled;
              instance.$savedKeyHash = str_instance.$savedKeyHash;
              instance.v = str_instance.v;
              return instance;
            },
            $jsstr() {
              return this.v;
            },
            $hasAstralCodePoints() {
              if (this.codepoints === null) {
                return false;
              } else if (this.codepoints !== void 0) {
                return true;
              }
              for (let i = 0; i < this.v.length; i++) {
                let cc = this.v.charCodeAt(i);
                if (cc >= 55296 && cc < 57344) {
                  this.codepoints = [];
                  for (let j = 0; j < this.v.length; j++) {
                    this.codepoints.push(j);
                    cc = this.v.charCodeAt(j);
                    if (cc >= 55296 && cc < 56320) {
                      j++;
                    }
                  }
                  return true;
                }
              }
              this.codepoints = null;
              return false;
            },
            sk$asarray() {
              const ret = [];
              if (this.$hasAstralCodePoints()) {
                const codepoints = this.codepoints;
                for (let i = 0; i < codepoints.length; i++) {
                  ret.push(
                    new Sk.builtin.str(this.v.substring(codepoints[i], codepoints[i + 1]))
                  );
                }
              } else {
                for (let i = 0; i < this.v.length; i++) {
                  ret.push(new Sk.builtin.str(this.v[i]));
                }
              }
              return ret;
            },
            find$left: mkFind(false),
            find$right: mkFind(true),
            get$tgt(tgt) {
              if (tgt instanceof Sk.builtin.str) {
                return tgt.v;
              }
              throw new Sk.builtin.TypeError(
                "a str instance is required not '" + Sk.abstr.typeName(tgt) + "'"
              );
            },
            $isIdentifier() {
              return Sk.token.isIdentifier(this.v);
            }
          }
        ),
        methods: (
          /**@lends {Sk.builtin.str.prototype} */
          {
            encode: {
              $meth: function encode(encoding, errors) {
                ({ encoding, errors } = Sk.builtin.bytes.check$encodeArgs(
                  "encode",
                  encoding,
                  errors
                ));
                const pyBytes = Sk.builtin.bytes.str$encode(this, encoding, errors);
                return Sk.__future__.python3 ? pyBytes : new Sk.builtin.str(pyBytes.$jsstr());
              },
              $flags: { NamedArgs: ["encoding", "errors"] },
              $textsig: "($self, /, encoding='utf-8', errors='strict')",
              $doc: "Encode the string using the codec registered for encoding.\n\n  encoding\n    The encoding in which to encode the string.\n  errors\n    The error handling scheme to use for encoding errors.\n    The default is 'strict' meaning that encoding errors raise a\n    UnicodeEncodeError.  Other possible values are 'ignore', 'replace' and\n    'xmlcharrefreplace' as well as any other name registered with\n    codecs.register_error that can handle UnicodeEncodeErrors."
            },
            replace: {
              $meth(oldS, newS, count) {
                oldS = this.get$tgt(oldS);
                newS = this.get$tgt(newS);
                count = count === void 0 ? -1 : Sk.misceval.asIndexSized(count, Sk.builtin.OverflowError);
                const patt = new RegExp(re_escape_(oldS), "g");
                if (count < 0) {
                  return new Sk.builtin.str(this.v.replace(patt, newS));
                }
                let c = 0;
                const ret = this.v.replace(patt, (match) => c++ < count ? newS : match);
                return new Sk.builtin.str(ret);
              },
              $flags: { MinArgs: 2, MaxArgs: 3 },
              $textsig: "($self, old, new, count=-1, /)",
              $doc: "Return a copy with all occurrences of substring old replaced by new.\n\n  count\n    Maximum number of occurrences to replace.\n    -1 (the default value) means replace all occurrences.\n\nIf the optional argument count is given, only the first count occurrences are\nreplaced."
            },
            split: {
              $meth: function split(sep, maxsplit) {
                maxsplit = Sk.misceval.asIndexSized(maxsplit, Sk.builtin.OverflowError);
                const codepoints = splitPoints(this, sep, maxsplit);
                const ret = [];
                for (let i = 0; i < codepoints.length; i++) {
                  ret.push(new Sk.builtin.str(this.v.substring(codepoints[i], codepoints[++i])));
                }
                return new Sk.builtin.list(ret);
              },
              $flags: { NamedArgs: ["sep", "maxsplit"], Defaults: [Sk.builtin.none.none$, -1] },
              $textsig: "($self, /, sep=None, maxsplit=-1)",
              $doc: "Return a list of the words in the string, using sep as the delimiter string.\n\n  sep\n    The delimiter according which to split the string.\n    None (the default value) means split according to any whitespace,\n    and discard empty strings from the result.\n  maxsplit\n    Maximum number of splits to do.\n    -1 (the default value) means no limit."
            },
            rsplit: {
              $meth: function rsplit(sep, maxsplit) {
                maxsplit = Sk.misceval.asIndexSized(maxsplit, Sk.builtin.OverflowError);
                const codepoints = splitPoints(this, sep, -1);
                let from = maxsplit < 0 ? 0 : (codepoints.length / 2 - maxsplit) * 2;
                const ret = [];
                if (from <= 0) {
                  from = 0;
                } else {
                  ret.push(new Sk.builtin.str(this.v.slice(0, codepoints[from - 1])));
                }
                for (let i = from; i < codepoints.length; i++) {
                  ret.push(new Sk.builtin.str(this.v.substring(codepoints[i], codepoints[++i])));
                }
                return new Sk.builtin.list(ret);
              },
              $flags: { NamedArgs: ["sep", "maxsplit"], Defaults: [Sk.builtin.none.none$, -1] },
              $textsig: "($self, /, sep=None, maxsplit=-1)",
              $doc: "Return a list of the words in the string, using sep as the delimiter string.\n\n  sep\n    The delimiter according which to split the string.\n    None (the default value) means split according to any whitespace,\n    and discard empty strings from the result.\n  maxsplit\n    Maximum number of splits to do.\n    -1 (the default value) means no limit.\n\nSplits are done starting at the end of the string and working to the front."
            },
            join: {
              $meth(seq) {
                const arrOfStrs = [];
                return Sk.misceval.chain(
                  Sk.misceval.iterFor(Sk.abstr.iter(seq), (i) => {
                    if (!(i instanceof Sk.builtin.str)) {
                      throw new Sk.builtin.TypeError(
                        "sequence item " + arrOfStrs.length + ": expected str, " + Sk.abstr.typeName(i) + " found"
                      );
                    }
                    arrOfStrs.push(i.v);
                  }),
                  () => new Sk.builtin.str(arrOfStrs.join(this.v))
                );
              },
              $flags: { OneArg: true },
              $textsig: "($self, iterable, /)",
              $doc: "Concatenate any number of strings.\n\nThe string whose method is called is inserted in between each given string.\nThe result is returned as a new string.\n\nExample: '.'.join(['ab', 'pq', 'rs']) -> 'ab.pq.rs'"
            },
            capitalize: {
              $meth: function capitalize() {
                return new Sk.builtin.str(
                  this.v.charAt(0).toUpperCase() + this.v.slice(1).toLowerCase()
                );
              },
              $flags: { NoArgs: true },
              $textsig: "($self, /)",
              $doc: "Return a capitalized version of the string.\n\nMore specifically, make the first character have upper case and the rest lower\ncase."
            },
            // casefold: {
            //     $meth: methods.casefold,
            //     $flags: { NoArgs: true },
            //     $textsig: "($self, /)",
            //     $doc: "Return a version of the string suitable for caseless comparisons.",
            // },
            title: {
              $meth: function title() {
                const ret = this.v.replace(
                  /[a-z][a-z]*/gi,
                  (str) => str[0].toUpperCase() + str.substr(1).toLowerCase()
                );
                return new Sk.builtin.str(ret);
              },
              $flags: { NoArgs: true },
              $textsig: "($self, /)",
              $doc: "Return a version of the string where each word is titlecased.\n\nMore specifically, words start with uppercased characters and all remaining\ncased characters have lower case."
            },
            center: {
              $meth: mkJust(false, true),
              $flags: { MinArgs: 1, MaxArgs: 2 },
              $textsig: "($self, width, fillchar=' ', /)",
              $doc: "Return a centered string of length width.\n\nPadding is done using the specified fill character (default is a space)."
            },
            count: {
              $meth: function count(pat, start, end) {
                pat = this.get$tgt(pat);
                ({ start, end } = indices(this, start, end));
                if (end < start) {
                  return new Sk.builtin.int_(0);
                }
                const normaltext = pat.replace(/[-[\]{}()*+?.,\\^$|#\s]/g, "\\$&");
                const m = new RegExp(normaltext, "g");
                const slice = this.v.slice(start, end);
                const ctl = slice.match(m);
                if (!ctl) {
                  return new Sk.builtin.int_(0);
                } else {
                  return new Sk.builtin.int_(ctl.length);
                }
              },
              $flags: { MinArgs: 1, MaxArgs: 3 },
              $textsig: null,
              $doc: "S.count(sub[, start[, end]]) -> int\n\nReturn the number of non-overlapping occurrences of substring sub in\nstring S[start:end].  Optional arguments start and end are\ninterpreted as in slice notation."
            },
            expandtabs: {
              $meth: function expandtabs(tabsize2) {
                if (Sk.builtin.checkInt(tabsize2)) {
                  tabsize2 = Sk.builtin.asnum$(tabsize2);
                } else {
                  throw new Sk.builtin.TypeError(
                    "an integer is required, got type" + Sk.abstr.typeName(tabsize2)
                  );
                }
                const spaces = new Array(tabsize2 + 1).join(" ");
                const expanded = this.v.replace(
                  /([^\r\n\t]*)\t/g,
                  (a, b) => b + spaces.slice(b.length % tabsize2)
                );
                return new Sk.builtin.str(expanded);
              },
              $flags: { NamedArgs: ["tabsize"], Defaults: [8] },
              $textsig: "($self, /, tabsize=8)",
              $doc: "Return a copy where all tab characters are expanded using spaces.\n\nIf tabsize is not given, a tab size of 8 characters is assumed."
            },
            find: {
              $meth: function find(tgt, start, end) {
                return new Sk.builtin.int_(this.find$left(tgt, start, end));
              },
              $flags: { MinArgs: 1, MaxArgs: 3 },
              $textsig: null,
              $doc: "S.find(sub[, start[, end]]) -> int\n\nReturn the lowest index in S where substring sub is found,\nsuch that sub is contained within S[start:end].  Optional\narguments start and end are interpreted as in slice notation.\n\nReturn -1 on failure."
            },
            partition: {
              $meth: mkPartition(false),
              $flags: { OneArg: true },
              $textsig: "($self, sep, /)",
              $doc: "Partition the string into three parts using the given separator.\n\nThis will search for the separator in the string.  If the separator is found,\nreturns a 3-tuple containing the part before the separator, the separator\nitself, and the part after it.\n\nIf the separator is not found, returns a 3-tuple containing the original string\nand two empty strings."
            },
            index: {
              $meth: function index(tgt, start, end) {
                const val = this.find$left(tgt, start, end);
                if (val === -1) {
                  throw new Sk.builtin.ValueError("substring not found");
                } else {
                  return new Sk.builtin.int_(val);
                }
              },
              $flags: { MinArgs: 1, MaxArgs: 3 },
              $textsig: null,
              $doc: "S.index(sub[, start[, end]]) -> int\n\nReturn the lowest index in S where substring sub is found, \nsuch that sub is contained within S[start:end].  Optional\narguments start and end are interpreted as in slice notation.\n\nRaises ValueError when the substring is not found."
            },
            ljust: {
              $meth: mkJust(false, false),
              $flags: { MinArgs: 1, MaxArgs: 2 },
              $textsig: "($self, width, fillchar=' ', /)",
              $doc: "Return a left-justified string of length width.\n\nPadding is done using the specified fill character (default is a space)."
            },
            lower: {
              $meth() {
                return new Sk.builtin.str(this.v.toLowerCase());
              },
              $flags: { NoArgs: true },
              $textsig: "($self, /)",
              $doc: "Return a copy of the string converted to lowercase."
            },
            lstrip: {
              $meth: mkStrip(/^\s+/g, (regex) => "^[" + regex + "]+"),
              $flags: { MinArgs: 0, MaxArgs: 1 },
              $textsig: "($self, chars=None, /)",
              $doc: "Return a copy of the string with leading whitespace removed.\n\nIf chars is given and not None, remove characters in chars instead."
            },
            rfind: {
              $meth(tgt, start, end) {
                return new Sk.builtin.int_(this.find$right(tgt, start, end));
              },
              $flags: { MinArgs: 1, MaxArgs: 3 },
              $textsig: null,
              $doc: "S.rfind(sub[, start[, end]]) -> int\n\nReturn the highest index in S where substring sub is found,\nsuch that sub is contained within S[start:end].  Optional\narguments start and end are interpreted as in slice notation.\n\nReturn -1 on failure."
            },
            rindex: {
              $meth: function rindex(tgt, start, end) {
                const val = this.find$right(tgt, start, end);
                if (val === -1) {
                  throw new Sk.builtin.ValueError("substring not found");
                } else {
                  return new Sk.builtin.int_(val);
                }
              },
              $flags: { MinArgs: 1, MaxArgs: 3 },
              $textsig: null,
              $doc: "S.rindex(sub[, start[, end]]) -> int\n\nReturn the highest index in S where substring sub is found,\nsuch that sub is contained within S[start:end].  Optional\narguments start and end are interpreted as in slice notation.\n\nRaises ValueError when the substring is not found."
            },
            rjust: {
              $meth: mkJust(true, false),
              $flags: { MinArgs: 1, MaxArgs: 2 },
              $textsig: "($self, width, fillchar=' ', /)",
              $doc: "Return a right-justified string of length width.\n\nPadding is done using the specified fill character (default is a space)."
            },
            rstrip: {
              $meth: mkStrip(/\s+$/g, (regex) => "[" + regex + "]+$"),
              $flags: { MinArgs: 0, MaxArgs: 1 },
              $textsig: "($self, chars=None, /)",
              $doc: "Return a copy of the string with trailing whitespace removed.\n\nIf chars is given and not None, remove characters in chars instead."
            },
            rpartition: {
              $meth: mkPartition(true),
              $flags: { OneArg: true },
              $textsig: "($self, sep, /)",
              $doc: "Partition the string into three parts using the given separator.\n\nThis will search for the separator in the string, starting at the end. If\nthe separator is found, returns a 3-tuple containing the part before the\nseparator, the separator itself, and the part after it.\n\nIf the separator is not found, returns a 3-tuple containing two empty strings\nand the original string."
            },
            splitlines: {
              $meth: function splitlines(keepends) {
                keepends = Sk.misceval.isTrue(keepends);
                const data = this.v;
                const final = [];
                const len = data.length;
                let slice, ch, eol, sol = 0;
                for (let i = 0; i < len; i++) {
                  ch = data.charAt(i);
                  if (data.charAt(i + 1) === "\n" && ch === "\r") {
                    eol = i + 2;
                    slice = data.slice(sol, eol);
                    if (!keepends) {
                      slice = slice.replace(/(\r|\n)/g, "");
                    }
                    final.push(new Sk.builtin.str(slice));
                    sol = eol;
                  } else if (ch === "\n" && data.charAt(i - 1) !== "\r" || ch === "\r") {
                    eol = i + 1;
                    slice = data.slice(sol, eol);
                    if (!keepends) {
                      slice = slice.replace(/(\r|\n)/g, "");
                    }
                    final.push(new Sk.builtin.str(slice));
                    sol = eol;
                  }
                }
                if (sol < len) {
                  eol = len;
                  slice = data.slice(sol, eol);
                  if (!keepends) {
                    slice = slice.replace(/(\r|\n)/g, "");
                  }
                  final.push(new Sk.builtin.str(slice));
                }
                return new Sk.builtin.list(final);
              },
              $flags: { NamedArgs: ["keepends"], Defaults: [false] },
              $textsig: "($self, /, keepends=False)",
              $doc: "Return a list of the lines in the string, breaking at line boundaries.\n\nLine breaks are not included in the resulting list unless keepends is given and\ntrue."
            },
            strip: {
              $meth: mkStrip(/^\s+|\s+$/g, (regex) => "^[" + regex + "]+|[" + regex + "]+$"),
              $flags: { MinArgs: 0, MaxArgs: 1 },
              $textsig: "($self, chars=None, /)",
              $doc: "Return a copy of the string with leading and trailing whitespace remove.\n\nIf chars is given and not None, remove characters in chars instead."
            },
            swapcase: {
              $meth() {
                const ret = this.v.replace(/[a-z]/gi, (c) => {
                  const lc = c.toLowerCase();
                  return lc === c ? c.toUpperCase() : lc;
                });
                return new Sk.builtin.str(ret);
              },
              $flags: { NoArgs: true },
              $textsig: "($self, /)",
              $doc: "Convert uppercase characters to lowercase and lowercase characters to uppercase."
            },
            // translate: {
            //     $meth: methods.translate,
            //     $flags: {},
            //     $textsig: "($self, table, /)",
            //     $doc:
            //         "Replace each character in the string using the given translation table.\n\n  table\n    Translation table, which must be a mapping of Unicode ordinals to\n    Unicode ordinals, strings, or None.\n\nThe table must implement lookup/indexing via __getitem__, for instance a\ndictionary or list.  If this operation raises LookupError, the character is\nleft untouched.  Characters mapped to None are deleted.",
            // },
            upper: {
              $meth() {
                return new Sk.builtin.str(this.v.toUpperCase());
              },
              $flags: { NoArgs: true },
              $textsig: "($self, /)",
              $doc: "Return a copy of the string converted to uppercase."
            },
            startswith: {
              $meth: mkStartsEndswith("startswith", (substr, i) => substr.indexOf(i) === 0),
              $flags: { MinArgs: 1, MaxArgs: 3 },
              $textsig: null,
              $doc: "S.startswith(prefix[, start[, end]]) -> bool\n\nReturn True if S starts with the specified prefix, False otherwise.\nWith optional start, test S beginning at that position.\nWith optional end, stop comparing S at that position.\nprefix can also be a tuple of strings to try."
            },
            endswith: {
              $meth: mkStartsEndswith(
                "endswith",
                (substr, i) => substr.indexOf(i, substr.length - i.length) !== -1
              ),
              $flags: { MinArgs: 1, MaxArgs: 3 },
              $textsig: null,
              $doc: "S.endswith(suffix[, start[, end]]) -> bool\n\nReturn True if S ends with the specified suffix, False otherwise.\nWith optional start, test S beginning at that position.\nWith optional end, stop comparing S at that position.\nsuffix can also be a tuple of strings to try."
            },
            isascii: {
              $meth() {
                return new Sk.builtin.bool(/^[\x00-\x7F]*$/.test(this.v));
              },
              $flags: { NoArgs: true },
              $textsig: "($self, /)",
              $doc: "Return True if all characters in the string are ASCII, False otherwise.\n\nASCII characters have code points in the range U+0000-U+007F.\nEmpty string is ASCII too."
            },
            islower: {
              $meth: function islower() {
                return new Sk.builtin.bool(
                  this.v.length && /[a-z]/.test(this.v) && !/[A-Z]/.test(this.v)
                );
              },
              $flags: { NoArgs: true },
              $textsig: "($self, /)",
              $doc: "Return True if the string is a lowercase string, False otherwise.\n\nA string is lowercase if all cased characters in the string are lowercase and\nthere is at least one cased character in the string."
            },
            isupper: {
              $meth: function islower() {
                return new Sk.builtin.bool(
                  this.v.length && !/[a-z]/.test(this.v) && /[A-Z]/.test(this.v)
                );
              },
              $flags: { NoArgs: true },
              $textsig: "($self, /)",
              $doc: "Return True if the string is an uppercase string, False otherwise.\n\nA string is uppercase if all cased characters in the string are uppercase and\nthere is at least one cased character in the string."
            },
            istitle: {
              $meth: function istitle() {
                const input = this.v;
                let cased = false;
                let previous_is_cased = false;
                let ch;
                for (let pos = 0; pos < input.length; pos++) {
                  ch = input.charAt(pos);
                  if (!/[a-z]/.test(ch) && /[A-Z]/.test(ch)) {
                    if (previous_is_cased) {
                      return Sk.builtin.bool.false$;
                    }
                    previous_is_cased = true;
                    cased = true;
                  } else if (/[a-z]/.test(ch) && !/[A-Z]/.test(ch)) {
                    if (!previous_is_cased) {
                      return Sk.builtin.bool.false$;
                    }
                    cased = true;
                  } else {
                    previous_is_cased = false;
                  }
                }
                return new Sk.builtin.bool(cased);
              },
              $flags: { NoArgs: true },
              $textsig: "($self, /)",
              $doc: "Return True if the string is a title-cased string, False otherwise.\n\nIn a title-cased string, upper- and title-case characters may only\nfollow uncased characters and lowercase characters only cased ones."
            },
            isspace: {
              $meth: function isspace() {
                return new Sk.builtin.bool(/^\s+$/.test(this.v));
              },
              $flags: { NoArgs: true },
              $textsig: "($self, /)",
              $doc: "Return True if the string is a whitespace string, False otherwise.\n\nA string is whitespace if all characters in the string are whitespace and there\nis at least one character in the string."
            },
            // isdecimal: {
            //     $meth: methods.isdecimal,
            //     $flags: { NoArgs: true },
            //     $textsig: "($self, /)",
            //     $doc:
            //         "Return True if the string is a decimal string, False otherwise.\n\nA string is a decimal string if all characters in the string are decimal and\nthere is at least one character in the string.",
            // },
            isdigit: {
              $meth: function isdigit() {
                return new Sk.builtin.bool(/^\d+$/.test(this.v));
              },
              $flags: { NoArgs: true },
              $textsig: "($self, /)",
              $doc: "Return True if the string is a digit string, False otherwise.\n\nA string is a digit string if all characters in the string are digits and there\nis at least one character in the string."
            },
            isnumeric: {
              $meth: function isnumeric() {
                return new Sk.builtin.bool(this.v.length && !/[^0-9]/.test(this.v));
              },
              $flags: { NoArgs: true },
              $textsig: "($self, /)",
              $doc: "Return True if the string is a numeric string, False otherwise.\n\nA string is numeric if all characters in the string are numeric and there is at\nleast one character in the string."
            },
            isalpha: {
              $meth: function isalpha() {
                return new Sk.builtin.bool(this.v.length && !/[^a-zA-Z]/.test(this.v));
              },
              $flags: { NoArgs: true },
              $textsig: "($self, /)",
              $doc: "Return True if the string is an alphabetic string, False otherwise.\n\nA string is alphabetic if all characters in the string are alphabetic and there\nis at least one character in the string."
            },
            isalnum: {
              $meth: function isalnum() {
                return new Sk.builtin.bool(this.v.length && !/[^a-zA-Z0-9]/.test(this.v));
              },
              $flags: { NoArgs: true },
              $textsig: "($self, /)",
              $doc: "Return True if the string is an alpha-numeric string, False otherwise.\n\nA string is alpha-numeric if all characters in the string are alpha-numeric and\nthere is at least one character in the string."
            },
            isidentifier: {
              $meth: function isidentifier2() {
                return this.$isIdentifier() ? Sk.builtin.bool.true$ : Sk.builtin.bool.false$;
              },
              $flags: { NoArgs: true },
              $textsig: "($self, /)",
              $doc: 'Return True if the string is a valid Python identifier, False otherwise.\n\nUse keyword.iskeyword() to test for reserved identifiers such as "def" and\n"class".'
            },
            // isprintable: {
            //     $meth: methods.isprintable,
            //     $flags: {},
            //     $textsig: "($self, /)",
            //     $doc:
            //         "Return True if the string is printable, False otherwise.\n\nA string is printable if all of its characters are considered printable in\nrepr() or if it is empty.",
            // },
            zfill: {
              $meth: function zfill(len) {
                len = Sk.misceval.asIndexSized(len, Sk.builtin.OverflowError);
                let pad = "";
                const zeroes = len - this.v.length;
                const offset = this.v[0] === "+" || this.v[0] === "-" ? 1 : 0;
                for (let i = 0; i < zeroes; i++) {
                  pad += "0";
                }
                return new Sk.builtin.str(this.v.substr(0, offset) + pad + this.v.substr(offset));
              },
              $flags: { OneArg: true },
              $textsig: "($self, width, /)",
              $doc: "Pad a numeric string with zeros on the left, to fill a field of the given width.\n\nThe string is never truncated."
            },
            format: {
              $meth: Sk.formatting.format,
              $flags: { FastCall: true },
              $textsig: null,
              $doc: "S.format(*args, **kwargs) -> str\n\nReturn a formatted version of S, using substitutions from args and kwargs.\nThe substitutions are identified by braces ('{' and '}')."
            },
            // format_map: {
            //     $meth: methods.format_map,
            //     $flags: {},
            //     $textsig: null,
            //     $doc:
            //         "S.format_map(mapping) -> str\n\nReturn a formatted version of S, using substitutions from mapping.\nThe substitutions are identified by braces ('{' and '}').",
            // },
            __format__: {
              $meth: Sk.formatting.formatString,
              $flags: { OneArg: true },
              $textsig: "($self, format_spec, /)",
              $doc: "Return a formatted version of the string as described by format_spec."
            },
            // __sizeof__: {
            //     $meth: methods.__sizeof__,
            //     $flags: {},
            //     $textsig: "($self, /)",
            //     $doc: "Return the size of the string in memory, in bytes.",
            // },
            __getnewargs__: {
              $meth() {
                return new Sk.builtin.tuple(new Sk.builtin.str(this.v));
              },
              $flags: { NoArgs: true },
              $textsig: null,
              $doc: null
            }
          }
        )
      });
      Sk.exportSymbol("Sk.builtin.str", Sk.builtin.str);
      var re = /^[A-Za-z0-9]+$/;
      function re_escape_(s) {
        let c;
        const ret = [];
        for (let i = 0; i < s.length; i++) {
          c = s.charAt(i);
          if (re.test(c)) {
            ret.push(c);
          } else {
            if (c === "\\000") {
              ret.push("\\000");
            } else {
              ret.push("\\" + c);
            }
          }
        }
        return ret.join("");
      }
      var special_chars = /([.*+?=|\\\/()\[\]\{\}^$])/g;
      var leading_whitespace = /^[\s\xa0]+/;
      function splitPoints(self2, sep, maxsplit) {
        sep = Sk.builtin.checkNone(sep) ? null : self2.get$tgt(sep);
        if (sep !== null && !sep.length) {
          throw new Sk.builtin.ValueError("empty separator");
        }
        let jsstr = self2.v;
        let offset = 0;
        let regex;
        if (sep === null) {
          regex = /[\s\xa0]+/g;
          const len = jsstr.length;
          jsstr = jsstr.replace(leading_whitespace, "");
          offset = len - jsstr.length;
        } else {
          const s = sep.replace(special_chars, "\\$1");
          regex = new RegExp(s, "g");
        }
        const pairs = [];
        let index = 0;
        let splits = 0;
        let match;
        maxsplit = maxsplit < 0 ? Infinity : maxsplit;
        while ((match = regex.exec(jsstr)) != null && splits < maxsplit) {
          if (match.index === regex.lastIndex) {
            break;
          }
          pairs.push(index + offset);
          pairs.push(match.index + offset);
          index = regex.lastIndex;
          splits += 1;
        }
        if (sep !== null || jsstr.length - index) {
          pairs.push(index + offset);
          pairs.push(jsstr.length + offset);
        }
        return pairs;
      }
      function mkStrip(pat, regf) {
        return function strip(chars) {
          let pattern;
          if (chars === void 0 || Sk.builtin.checkNone(chars)) {
            pattern = pat;
          } else if (chars instanceof Sk.builtin.str) {
            const regex = re_escape_(chars.v);
            pattern = new RegExp(regf(regex), "g");
          } else {
            throw new Sk.builtin.TypeError("strip arg must be None or str");
          }
          return new Sk.builtin.str(this.v.replace(pattern, ""));
        };
      }
      function mkPartition(isReversed) {
        return function partition(sep) {
          const sepStr = this.get$tgt(sep);
          const jsstr = this.v;
          let pos;
          if (isReversed) {
            pos = jsstr.lastIndexOf(sepStr);
            if (pos < 0) {
              return new Sk.builtin.tuple([
                new Sk.builtin.str(""),
                new Sk.builtin.str(""),
                new Sk.builtin.str(jsstr)
              ]);
            }
          } else {
            pos = jsstr.indexOf(sepStr);
            if (pos < 0) {
              return new Sk.builtin.tuple([
                new Sk.builtin.str(jsstr),
                new Sk.builtin.str(""),
                new Sk.builtin.str("")
              ]);
            }
          }
          return new Sk.builtin.tuple([
            new Sk.builtin.str(jsstr.substring(0, pos)),
            new Sk.builtin.str(sepStr),
            new Sk.builtin.str(jsstr.substring(pos + sepStr.length))
          ]);
        };
      }
      function mkJust(isRight, isCenter) {
        return function strJustify(len, fillchar) {
          len = Sk.misceval.asIndexSized(len, Sk.builtin.OverflowError);
          if (fillchar === void 0) {
            fillchar = " ";
          } else if (!(fillchar instanceof Sk.builtin.str) || fillchar.sq$length() !== 1) {
            throw new Sk.builtin.TypeError("the fill character must be a str of length 1");
          } else {
            fillchar = fillchar.v;
          }
          const mylen = this.sq$length();
          let newstr;
          if (mylen >= len) {
            return new Sk.builtin.str(this.v);
          } else if (isCenter) {
            newstr = fillchar.repeat(Math.floor((len - mylen) / 2));
            newstr = newstr + this.v + newstr;
            if ((len - mylen) % 2) {
              newstr += fillchar;
            }
            return new Sk.builtin.str(newstr);
          } else {
            newstr = fillchar.repeat(len - mylen);
            return new Sk.builtin.str(isRight ? newstr + this.v : this.v + newstr);
          }
        };
      }
      function indices(self2, start, end) {
        ({ start, end } = Sk.builtin.slice.startEnd$wrt(self2, start, end));
        if (self2.$hasAstralCodePoints()) {
          const tmp = self2.codepoints[start];
          start = tmp === void 0 ? start + self2.v.length - self2.codepoints.length : tmp;
          end = self2.codepoints[end];
          end = end === void 0 ? self2.v.length : end;
        }
        return {
          start,
          end
        };
      }
      function mkFind(isReversed) {
        return function(tgt, start, end) {
          tgt = this.get$tgt(tgt);
          ({ start, end } = indices(this, start, end));
          if (end < start) {
            return -1;
          }
          end -= tgt.length;
          let jsidx = isReversed ? this.v.lastIndexOf(tgt, end) : this.v.indexOf(tgt, start);
          jsidx = jsidx >= start && jsidx <= end ? jsidx : -1;
          let idx;
          if (this.codepoints) {
            const len = this.sq$length();
            idx = -1;
            for (let i = 0; i < len; i++) {
              if (jsidx == this.codepoints[i]) {
                idx = i;
              }
            }
          } else {
            idx = jsidx;
          }
          return idx;
        };
      }
      function mkStartsEndswith(funcname, is_match) {
        return function(tgt, start, end) {
          if (!(tgt instanceof Sk.builtin.str) && !(tgt instanceof Sk.builtin.tuple)) {
            throw new Sk.builtin.TypeError(
              funcname + " first arg must be str or a tuple of str, not " + Sk.abstr.typeName(tgt)
            );
          }
          ({ start, end } = indices(this, start, end));
          if (start > end) {
            return Sk.builtin.bool.false$;
          }
          const substr = this.v.slice(start, end);
          if (tgt instanceof Sk.builtin.tuple) {
            for (let it = Sk.abstr.iter(tgt), i = it.tp$iternext(); i !== void 0; i = it.tp$iternext()) {
              if (!(i instanceof Sk.builtin.str)) {
                throw new Sk.builtin.TypeError(
                  "tuple for " + funcname + " must only contain str, not " + Sk.abstr.typeName(i)
                );
              }
              if (is_match(substr, i.v)) {
                return Sk.builtin.bool.true$;
              }
            }
            return Sk.builtin.bool.false$;
          }
          return new Sk.builtin.bool(is_match(substr, tgt.v));
        };
      }
      Sk.builtin.str.$py2decode = new Sk.builtin.method_descriptor(Sk.builtin.str, {
        $name: "decode",
        $meth(encoding, errors) {
          const pyBytes = new Sk.builtin.bytes(this.v);
          return Sk.builtin.bytes.$decode.call(pyBytes, encoding, errors);
        },
        $flags: { NamedArgs: ["encoding", "errors"] }
      });
      function strBytesRemainder(rhs) {
        var ret;
        var replFunc;
        var index;
        var regex;
        var val;
        const strBytesConstructor = this.sk$builtinBase;
        if (rhs.constructor !== Sk.builtin.tuple && !(rhs instanceof Sk.builtin.dict || rhs instanceof Sk.builtin.mappingproxy)) {
          rhs = new Sk.builtin.tuple([rhs]);
        }
        regex = /%(\([a-zA-Z0-9]+\))?([#0 +\-]+)?(\*|[0-9]+)?(\.(\*|[0-9]+))?[hlL]?([diouxXeEfFgGcrsb%])/g;
        index = 0;
        replFunc = function(substring, mappingKey, conversionFlags, fieldWidth, precision, precbody, conversionType) {
          var result;
          var convName;
          var convValue;
          var base;
          var r;
          var mk;
          var value;
          var handleWidth;
          var formatNumber;
          var alternateForm;
          var precedeWithSign;
          var blankBeforePositive;
          var leftAdjust;
          var zeroPad;
          var i;
          fieldWidth = Sk.builtin.asnum$(fieldWidth);
          precision = Sk.builtin.asnum$(precision);
          if ((mappingKey === void 0 || mappingKey === "") && conversionType != "%") {
            i = index++;
          }
          if (precision === "") {
            precision = void 0;
          }
          zeroPad = false;
          leftAdjust = false;
          blankBeforePositive = false;
          precedeWithSign = false;
          alternateForm = false;
          if (conversionFlags) {
            if (conversionFlags.indexOf("-") !== -1) {
              leftAdjust = true;
            } else if (conversionFlags.indexOf("0") !== -1) {
              zeroPad = true;
            }
            if (conversionFlags.indexOf("+") !== -1) {
              precedeWithSign = true;
            } else if (conversionFlags.indexOf(" ") !== -1) {
              blankBeforePositive = true;
            }
            alternateForm = conversionFlags.indexOf("#") !== -1;
          }
          if (precision) {
            precision = parseInt(precision.substr(1), 10);
          }
          formatNumber = function(n, base2) {
            var precZeroPadded;
            var prefix;
            var didSign;
            var neg;
            var r2;
            var j;
            base2 = Sk.builtin.asnum$(base2);
            neg = false;
            didSign = false;
            if (typeof n === "number") {
              if (n < 0) {
                n = -n;
                neg = true;
              }
              r2 = n.toString(base2);
            } else if (n instanceof Sk.builtin.float_) {
              r2 = n.str$(base2, false);
              if (r2.length > 2 && r2.substr(-2) === ".0") {
                r2 = r2.substr(0, r2.length - 2);
              }
              neg = n.nb$isnegative();
            } else if (n instanceof Sk.builtin.int_) {
              r2 = n.str$(base2, false);
              neg = n.nb$isnegative();
            } else if (n instanceof Sk.builtin.lng) {
              r2 = n.str$(base2, false);
              neg = n.nb$isnegative();
            }
            Sk.asserts.assert(r2 !== void 0, "unhandled number format");
            precZeroPadded = false;
            if (precision) {
              for (j = r2.length; j < precision; ++j) {
                r2 = "0" + r2;
                precZeroPadded = true;
              }
            }
            prefix = "";
            if (neg) {
              prefix = "-";
            } else if (precedeWithSign) {
              prefix = "+" + prefix;
            } else if (blankBeforePositive) {
              prefix = " " + prefix;
            }
            if (alternateForm) {
              if (base2 === 16) {
                prefix += "0x";
              } else if (base2 === 8 && !precZeroPadded && r2 !== "0") {
                prefix += "0";
              }
            }
            return [prefix, r2];
          };
          handleWidth = function(args) {
            var totLen;
            var prefix = args[0];
            var r2 = args[1];
            var j;
            if (fieldWidth) {
              fieldWidth = parseInt(fieldWidth, 10);
              totLen = r2.length + prefix.length;
              if (zeroPad) {
                for (j = totLen; j < fieldWidth; ++j) {
                  r2 = "0" + r2;
                }
              } else if (leftAdjust) {
                for (j = totLen; j < fieldWidth; ++j) {
                  r2 = r2 + " ";
                }
                if (Sk.__future__.python3) {
                  r2 += prefix;
                  prefix = "";
                }
              } else {
                for (j = totLen; j < fieldWidth; ++j) {
                  prefix = " " + prefix;
                }
              }
            }
            return prefix + r2;
          };
          if (rhs.constructor === Sk.builtin.tuple) {
            value = rhs.v[i];
          } else if (rhs.mp$subscript !== void 0 && mappingKey !== void 0) {
            mk = mappingKey.substring(1, mappingKey.length - 1);
            value = rhs.mp$subscript(new strBytesConstructor(mk));
          } else if (rhs.constructor === Sk.builtin.dict || rhs.constructor === Sk.builtin.list) {
            value = rhs;
          } else {
            throw new Sk.builtin.AttributeError(
              rhs.tp$name + " instance has no attribute 'mp$subscript'"
            );
          }
          base = 10;
          if (conversionType === "d" || conversionType === "i") {
            let tmpData = formatNumber(value, base);
            if (tmpData[1] === void 0) {
              throw new Sk.builtin.TypeError(
                "%" + conversionType + " format: a number is required, not " + Sk.abstr.typeName(value)
              );
            }
            let r2 = tmpData[1];
            tmpData[1] = r2.indexOf(".") !== -1 ? parseInt(r2, 10).toString() : r2;
            return handleWidth(tmpData);
          } else if (conversionType === "o") {
            return handleWidth(formatNumber(value, 8));
          } else if (conversionType === "x") {
            return handleWidth(formatNumber(value, 16));
          } else if (conversionType === "X") {
            return handleWidth(formatNumber(value, 16)).toUpperCase();
          } else if (conversionType === "f" || conversionType === "F" || conversionType === "e" || conversionType === "E" || conversionType === "g" || conversionType === "G") {
            convValue = Sk.builtin.asnum$(value);
            if (typeof convValue === "string") {
              convValue = Number(convValue);
            }
            if (convValue === Infinity) {
              return "inf";
            }
            if (convValue === -Infinity) {
              return "-inf";
            }
            if (isNaN(convValue)) {
              return "nan";
            }
            convName = ["toExponential", "toFixed", "toPrecision"]["efg".indexOf(conversionType.toLowerCase())];
            if (precision === void 0 || precision === "") {
              if (conversionType === "e" || conversionType === "E") {
                precision = 6;
              } else if (conversionType === "f" || conversionType === "F") {
                if (Sk.__future__.python3) {
                  precision = 6;
                } else {
                  precision = 7;
                }
              }
            }
            result = convValue[convName](precision);
            if (Sk.builtin.checkFloat(value)) {
              if (convValue === 0 && 1 / convValue === -Infinity) {
                result = "-" + result;
              }
            }
            if (Sk.__future__.python3) {
              if (result.length >= 7 && result.slice(0, 6) == "0.0000") {
                val = parseFloat(result);
                result = val.toExponential();
              }
              if (result.charAt(result.length - 2) == "-") {
                result = result.slice(0, result.length - 1) + "0" + result.charAt(result.length - 1);
              }
            }
            if ("EFG".indexOf(conversionType) !== -1) {
              result = result.toUpperCase();
            }
            return handleWidth(["", result]);
          } else if (conversionType === "c") {
            if (typeof value === "number") {
              return String.fromCharCode(value);
            } else if (value instanceof Sk.builtin.int_) {
              return String.fromCharCode(value.v);
            } else if (value instanceof Sk.builtin.float_) {
              return String.fromCharCode(value.v);
            } else if (value instanceof Sk.builtin.lng) {
              return String.fromCharCode(value.str$(10, false)[0]);
            } else if (value.constructor === Sk.builtin.str) {
              return value.v.substr(0, 1);
            } else {
              throw new Sk.builtin.TypeError("an integer is required");
            }
          } else if (conversionType === "r") {
            r = Sk.builtin.repr(value);
            if (precision) {
              return r.v.substr(0, precision);
            }
            return r.v;
          } else if (conversionType === "s" && strBytesConstructor === Sk.builtin.str) {
            r = new Sk.builtin.str(value);
            r = r.$jsstr();
            if (precision) {
              return r.substr(0, precision);
            }
            if (fieldWidth) {
              r = handleWidth([" ", r]);
            }
            return r;
          } else if (conversionType === "b" || conversionType === "s") {
            if (strBytesConstructor === Sk.builtin.str) {
              throw new Sk.builtin.ValueError("unsupported format character 'b'");
            }
            let func;
            if (!(value instanceof Sk.builtin.bytes) && (func = Sk.abstr.lookupSpecial(value, Sk.builtin.str.$bytes)) === void 0) {
              throw new Sk.builtin.TypeError(
                "%b requires a bytes-like object, or an object that implements __bytes__, not '" + Sk.abstr.typeName(value) + "'"
              );
            }
            if (func !== void 0) {
              value = new Sk.builtin.bytes(value);
            }
            r = value.$jsstr();
            if (precision) {
              return r.substr(0, precision);
            }
            if (fieldWidth) {
              r = handleWidth([" ", r]);
            }
            return r;
          } else if (conversionType === "%") {
            return "%";
          }
        };
        ret = this.$jsstr().replace(regex, replFunc);
        if (rhs instanceof Sk.builtin.tuple && index < rhs.sq$length()) {
          throw new Sk.builtin.TypeError("not all arguments converted during string formatting");
        }
        return new strBytesConstructor(ret);
      }
      var str_iter_ = Sk.abstr.buildIteratorClass("str_iterator", {
        constructor: function str_iter_2(str) {
          this.$index = 0;
          if (str.$hasAstralCodePoints()) {
            this.$seq = str.codepoints;
            this.tp$iternext = () => {
              const i = this.$seq[this.$index];
              if (i === void 0) {
                return void 0;
              }
              return new Sk.builtin.str(str.v.substring(i, this.$seq[++this.$index]));
            };
          } else {
            this.$seq = str.v;
            this.tp$iternext = () => {
              const ch = this.$seq[this.$index++];
              if (ch === void 0) {
                return void 0;
              }
              return new Sk.builtin.str(ch);
            };
          }
        },
        iternext() {
          return this.tp$iternext();
        },
        methods: {
          __length_hint__: Sk.generic.iterLengthHintWithArrayMethodDef
        },
        flags: { sk$unacceptableBase: true }
      });
      var reservedWords_ = {
        abstract: true,
        as: true,
        boolean: true,
        break: true,
        byte: true,
        case: true,
        catch: true,
        char: true,
        class: true,
        continue: true,
        const: true,
        debugger: true,
        default: true,
        delete: true,
        do: true,
        double: true,
        else: true,
        enum: true,
        export: true,
        extends: true,
        false: true,
        final: true,
        finally: true,
        float: true,
        for: true,
        function: true,
        goto: true,
        if: true,
        implements: true,
        import: true,
        in: true,
        instanceof: true,
        int: true,
        interface: true,
        is: true,
        long: true,
        namespace: true,
        native: true,
        new: true,
        null: true,
        package: true,
        private: true,
        protected: true,
        public: true,
        return: true,
        short: true,
        static: true,
        super: true,
        switch: true,
        synchronized: true,
        this: true,
        throw: true,
        throws: true,
        transient: true,
        true: true,
        try: true,
        typeof: true,
        use: true,
        var: true,
        void: true,
        volatile: true,
        while: true,
        with: true,
        // reserved Names
        constructor: true,
        __defineGetter__: true,
        __defineSetter__: true,
        apply: true,
        arguments: true,
        call: true,
        caller: true,
        eval: true,
        hasOwnProperty: true,
        isPrototypeOf: true,
        __lookupGetter__: true,
        __lookupSetter__: true,
        __noSuchMethod__: true,
        propertyIsEnumerable: true,
        prototype: true,
        toSource: true,
        toLocaleString: true,
        toString: true,
        unwatch: true,
        valueOf: true,
        watch: true,
        length: true,
        name: true
      };
      function fixReserved(name) {
        if (reservedWords_[name] === void 0) {
          return name;
        }
        return name + "_$rw$";
      }
      Sk.builtin.str.reservedWords_ = reservedWords_;
    }
  });

  // src/function.js
  var require_function = __commonJS({
    "src/function.js"() {
      Sk.builtin.func = Sk.abstr.buildNativeClass("function", {
        constructor: function func(code, globals, closure, closure2) {
          Sk.asserts.assert(
            this instanceof Sk.builtin.func,
            "builtin func should be called as a class with `new`"
          );
          this.func_code = code;
          this.func_globals = globals || null;
          this.$name = code.co_name && code.co_name.v || code.name || "<native JS>";
          this.$d = Sk.builtin.dict ? new Sk.builtin.dict() : void 0;
          this.$doc = code.co_docstring || Sk.builtin.none.none$;
          this.$module = Sk.globals && Sk.globals["__name__"] || Sk.builtin.none.none$;
          this.$qualname = code.co_qualname && code.co_qualname.v || this.$name;
          if (closure2 !== void 0) {
            for (let k in closure2) {
              closure[k] = closure2[k];
            }
          }
          this.func_closure = closure;
          this.func_annotations = null;
          this.$memoiseFlags();
          this.memoised = code.co_fastcall || null;
          if (code.co_fastcall) {
            this.tp$call = code.bind(this);
          } else {
            this.tp$call = Sk.builtin.func.prototype.tp$call.bind(this);
          }
        },
        slots: {
          tp$getattr: Sk.generic.getAttr,
          tp$descr_get(obj, objtype) {
            if (obj === null) {
              return this;
            }
            return new Sk.builtin.method(this, obj);
          },
          $r() {
            return new Sk.builtin.str("<function " + this.$qualname + ">");
          },
          tp$call(posargs, kw) {
            if (!this.memoised) {
              this.$memoiseFlags();
              this.memoised = true;
            }
            if (this.co_argcount === void 0 && this.co_varnames === void 0 && !this.co_kwargs && !this.func_closure) {
              if (kw && kw.length !== 0) {
                throw new Sk.builtin.TypeError(this.$name + "() takes no keyword arguments");
              }
              return this.func_code.apply(this.func_globals, posargs);
            }
            let args = this.$resolveArgs(posargs, kw);
            if (this.func_closure) {
              args.push(this.func_closure);
            }
            return this.func_code.apply(this.func_globals, args);
          }
        },
        getsets: {
          __name__: {
            $get() {
              return new Sk.builtin.str(this.$name);
            },
            $set(value) {
              if (!Sk.builtin.checkString(value)) {
                throw new Sk.builtin.TypeError("__name__ must be set to a string object");
              }
              this.$name = value.$jsstr();
            }
          },
          __qualname__: {
            $get() {
              return new Sk.builtin.str(this.$qualname);
            },
            $set(value) {
              if (!Sk.builtin.checkString(value)) {
                throw new Sk.builtin.TypeError("__qualname__ must be set to a string object");
              }
              this.$qualname = value.$jsstr();
            }
          },
          __dict__: Sk.generic.getSetDict,
          __annotations__: {
            $get() {
              if (this.func_annotations === null) {
                this.func_annotations = new Sk.builtin.dict([]);
              } else if (Array.isArray(this.func_annotations)) {
                this.func_annotations = Sk.abstr.keywordArrayToPyDict(this.func_annotations);
              }
              return this.func_annotations;
            },
            $set(v) {
              if (v === void 0 || Sk.builtin.checkNone(v)) {
                this.func_annotations = new Sk.builtin.dict([]);
              } else if (v instanceof Sk.builtin.dict) {
                this.func_annotations = v;
              } else {
                throw new Sk.builtin.TypeError("__annotations__ must be set to a dict object");
              }
            }
          },
          __defaults__: {
            $get() {
              return new Sk.builtin.tuple(this.$defaults);
            }
            // technically this is a writable property but we'll leave it as read-only for now
          },
          __doc__: {
            $get() {
              return this.$doc;
            },
            $set(v) {
              this.$doc = v || Sk.builtin.none.none$;
            }
          },
          __module__: {
            $get() {
              return this.$module;
            },
            $set(v) {
              this.$module = v || Sk.builtin.none.none$;
            }
          }
        },
        proto: {
          $memoiseFlags() {
            this.co_varnames = this.func_code.co_varnames;
            this.co_argcount = this.func_code.co_argcount;
            if (this.co_argcount === void 0 && this.co_varnames) {
              this.co_argcount = this.co_argcount = this.co_varnames.length;
            }
            this.co_kwonlyargcount = this.func_code.co_kwonlyargcount || 0;
            this.co_varargs = this.func_code.co_varargs;
            this.co_kwargs = this.func_code.co_kwargs;
            this.$defaults = this.func_code.$defaults || [];
            this.$kwdefs = this.func_code.$kwdefs || [];
          },
          $resolveArgs
        }
      });
      function $resolveArgs(posargs, kw) {
        let co_argcount = this.co_argcount;
        if (co_argcount === void 0) {
          co_argcount = this.co_varnames ? this.co_varnames.length : posargs.length;
        }
        let varnames = this.co_varnames || [];
        let co_kwonlyargcount = this.co_kwonlyargcount || 0;
        let totalArgs = co_argcount + co_kwonlyargcount;
        if (co_kwonlyargcount === 0 && !this.co_kwargs && (!kw || kw.length === 0) && !this.co_varargs) {
          if (posargs.length == co_argcount) {
            return posargs;
          } else if (posargs.length === 0 && this.$defaults && this.$defaults.length === co_argcount) {
            for (let i = 0; i != this.$defaults.length; i++) {
              posargs[i] = this.$defaults[i];
            }
            return posargs;
          }
        }
        let kwargs;
        if (this.co_kwargs) {
          kwargs = [];
        }
        let nposargs = posargs.length;
        let args = posargs.length <= co_argcount ? posargs : posargs.slice(0, co_argcount);
        if (this.co_varargs) {
          let vararg = posargs.length > args.length ? posargs.slice(args.length) : [];
          args[totalArgs] = new Sk.builtin.tuple(vararg);
        } else if (nposargs > co_argcount) {
          throw new Sk.builtin.TypeError(
            this.$name + "() takes " + co_argcount + " positional argument" + (co_argcount == 1 ? "" : "s") + " but " + nposargs + (nposargs == 1 ? " was " : " were ") + " given"
          );
        }
        if (kw) {
          if (this.func_code["no_kw"]) {
            throw new Sk.builtin.TypeError(this.$name + "() takes no keyword arguments");
          }
          for (let i = 0; i < kw.length; i += 2) {
            let name = kw[i];
            let value = kw[i + 1];
            let idx = varnames.indexOf(name);
            if (idx >= 0) {
              if (args[idx] !== void 0) {
                throw new Sk.builtin.TypeError(
                  this.$name + "() got multiple values for argument '" + name + "'"
                );
              }
              args[idx] = value;
            } else if (kwargs) {
              kwargs.push(new Sk.builtin.str(name), value);
            } else {
              throw new Sk.builtin.TypeError(
                this.$name + "() got an unexpected keyword argument '" + name + "'"
              );
            }
          }
        }
        {
          let defaults = this.$defaults || [];
          let i = 0, missing = [], missingUnnamed = false;
          let defaultStart = co_argcount - defaults.length;
          for (; i < defaultStart; i++) {
            if (args[i] === void 0) {
              missing.push(varnames[i]);
              if (varnames[i] === void 0) {
                missingUnnamed = true;
              }
            }
          }
          if (missing.length != 0 && (this.co_argcount || this.co_varnames)) {
            throw new Sk.builtin.TypeError(
              this.$name + "() missing " + missing.length + " required argument" + (missing.length == 1 ? "" : "s") + (missingUnnamed ? "" : ": " + missing.map((x) => "'" + x + "'").join(", "))
            );
          }
          for (; i < co_argcount; i++) {
            if (args[i] === void 0) {
              args[i] = defaults[i - defaultStart];
            }
          }
        }
        if (co_kwonlyargcount > 0) {
          let missing = [];
          let kwdefs = this.$kwdefs;
          for (let i = co_argcount; i < totalArgs; i++) {
            if (args[i] === void 0) {
              if (kwdefs[i - co_argcount] !== void 0) {
                args[i] = kwdefs[i - co_argcount];
              } else {
                missing.push(varnames[i]);
              }
            }
          }
          if (missing.length !== 0) {
            throw new Sk.builtin.TypeError(
              this.$name + "() missing " + missing.length + " required keyword argument" + (missing.length == 1 ? "" : "s") + ": " + missing.join(", ")
            );
          }
        }
        if (this.func_closure) {
          if (varnames) {
            for (let i = args.length; i < varnames.length; i++) {
              args.push(void 0);
            }
          }
        }
        if (kwargs) {
          args.unshift(kwargs);
        }
        return args;
      }
    }
  });

  // src/builtin.js
  var require_builtin = __commonJS({
    "src/builtin.js"() {
      Sk.builtin.asnum$ = function(a) {
        if (a === void 0) {
          return a;
        }
        if (a === null) {
          return a;
        }
        if (typeof a === "number") {
          return a;
        }
        if (a instanceof Sk.builtin.int_) {
          if (typeof a.v === "number") {
            return a.v;
          }
          return a.v.toString();
        }
        if (a instanceof Sk.builtin.float_) {
          return a.v;
        }
        if (a === Sk.builtin.none.none$) {
          return null;
        }
        if (typeof a === "string") {
          return a;
        }
        return a;
      };
      Sk.exportSymbol("Sk.builtin.asnum$", Sk.builtin.asnum$);
      Sk.builtin.assk$ = function(a) {
        if (a % 1 === 0) {
          return new Sk.builtin.int_(a);
        } else {
          return new Sk.builtin.float_(a);
        }
      };
      Sk.exportSymbol("Sk.builtin.assk$", Sk.builtin.assk$);
      Sk.builtin.asnum$nofloat = function(a) {
        var decimal;
        var mantissa;
        var expon;
        if (a === void 0) {
          return a;
        } else if (a === null) {
          return a;
        } else if (typeof a === "number") {
          a = a.toString();
        } else if (a instanceof Sk.builtin.int_) {
          a = a.v.toString();
        } else if (a instanceof Sk.builtin.float_) {
          a = a.v.toString();
        } else if (a === Sk.builtin.none.none$) {
          return null;
        } else {
          return void 0;
        }
        if (a.indexOf(".") < 0 && a.indexOf("e") < 0 && a.indexOf("E") < 0) {
          return a;
        }
        expon = 0;
        if (a.indexOf("e") >= 0) {
          mantissa = a.substr(0, a.indexOf("e"));
          expon = a.substr(a.indexOf("e") + 1);
        } else if (a.indexOf("E") >= 0) {
          mantissa = a.substr(0, a.indexOf("e"));
          expon = a.substr(a.indexOf("E") + 1);
        } else {
          mantissa = a;
        }
        expon = parseInt(expon, 10);
        decimal = mantissa.indexOf(".");
        if (decimal < 0) {
          if (expon >= 0) {
            while (expon-- > 0) {
              mantissa += "0";
            }
            return mantissa;
          } else {
            if (mantissa.length > -expon) {
              return mantissa.substr(0, mantissa.length + expon);
            } else {
              return 0;
            }
          }
        }
        if (decimal === 0) {
          mantissa = mantissa.substr(1);
        } else if (decimal < mantissa.length) {
          mantissa = mantissa.substr(0, decimal) + mantissa.substr(decimal + 1);
        } else {
          mantissa = mantissa.substr(0, decimal);
        }
        decimal = decimal + expon;
        while (decimal > mantissa.length) {
          mantissa += "0";
        }
        if (decimal <= 0) {
          mantissa = 0;
        } else {
          mantissa = mantissa.substr(0, decimal);
        }
        return mantissa;
      };
      Sk.exportSymbol("Sk.builtin.asnum$nofloat", Sk.builtin.asnum$nofloat);
      Sk.builtin.round = function round(number, ndigits) {
        if (number === void 0) {
          throw new Sk.builtin.TypeError("a float is required");
        }
        if (!Sk.__future__.dunder_round) {
          if (!Sk.builtin.checkNumber(number)) {
            throw new Sk.builtin.TypeError("a float is required");
          }
          if (number.round$) {
            return number.round$(ndigits);
          } else {
            throw new Sk.builtin.AttributeError(
              Sk.abstr.typeName(number) + " instance has no attribute '__float__'"
            );
          }
        }
        if (ndigits !== void 0 && !Sk.builtin.checkNone(ndigits) && !Sk.misceval.isIndex(ndigits)) {
          throw new Sk.builtin.TypeError(
            "'" + Sk.abstr.typeName(ndigits) + "' object cannot be interpreted as an index"
          );
        }
        const special = Sk.abstr.lookupSpecial(number, Sk.builtin.str.$round);
        if (special !== void 0) {
          if (ndigits !== void 0) {
            return Sk.misceval.callsimArray(special, [ndigits]);
          } else {
            return Sk.misceval.callsimArray(special, []);
          }
        } else {
          throw new Sk.builtin.TypeError("a float is required");
        }
      };
      Sk.builtin.len = function len(item) {
        let res;
        if (item.sq$length) {
          res = item.sq$length(true);
        } else {
          throw new Sk.builtin.TypeError(
            "object of type '" + Sk.abstr.typeName(item) + "' has no len()"
          );
        }
        return Sk.misceval.chain(res, (r) => {
          return new Sk.builtin.int_(r);
        });
      };
      Sk.builtin.min = function min(args, kwargs) {
        let iter;
        const nargs = args.length;
        if (!nargs) {
          throw new Sk.builtin.TypeError("min expected 1 argument, got 0");
        }
        const [$default, key] = Sk.abstr.copyKeywordsToNamedArgs(
          "min",
          ["default", "key"],
          [],
          kwargs,
          [null, Sk.builtin.none.none$]
        );
        if (nargs > 1 && $default !== null) {
          throw new Sk.builtin.TypeError(
            "Cannot specify a default for min() with multiple positional arguments"
          );
        }
        if (nargs == 1) {
          iter = Sk.abstr.iter(args[0]);
        } else {
          iter = Sk.abstr.iter(new Sk.builtin.tuple(args));
        }
        if (!Sk.builtin.checkNone(key) && !Sk.builtin.checkCallable(key)) {
          throw new Sk.builtin.TypeError("'" + Sk.abstr.typeName(key) + "' object is not callable");
        }
        let lowest;
        return Sk.misceval.chain(
          iter.tp$iternext(true),
          (i) => {
            lowest = i;
            if (lowest === void 0) {
              return;
            }
            if (Sk.builtin.checkNone(key)) {
              return Sk.misceval.iterFor(iter, (i2) => {
                if (Sk.misceval.richCompareBool(i2, lowest, "Lt")) {
                  lowest = i2;
                }
              });
            } else {
              return Sk.misceval.chain(
                Sk.misceval.callsimOrSuspendArray(key, [lowest]),
                (lowest_compare) => Sk.misceval.iterFor(
                  iter,
                  (i2) => Sk.misceval.chain(
                    Sk.misceval.callsimOrSuspendArray(key, [i2]),
                    (i_compare) => {
                      if (Sk.misceval.richCompareBool(i_compare, lowest_compare, "Lt")) {
                        lowest = i2;
                        lowest_compare = i_compare;
                      }
                    }
                  )
                )
              );
            }
          },
          () => {
            if (lowest === void 0) {
              if ($default === null) {
                throw new Sk.builtin.ValueError("min() arg is an empty sequence");
              } else {
                lowest = $default;
              }
            }
            return lowest;
          }
        );
      };
      Sk.builtin.max = function max(args, kwargs) {
        let iter;
        const nargs = args.length;
        if (!nargs) {
          throw new Sk.builtin.TypeError("max expected 1 argument, got 0");
        }
        const [$default, key] = Sk.abstr.copyKeywordsToNamedArgs(
          "max",
          ["default", "key"],
          [],
          kwargs,
          [null, Sk.builtin.none.none$]
        );
        if (nargs > 1 && $default !== null) {
          throw new Sk.builtin.TypeError(
            "Cannot specify a default for max() with multiple positional arguments"
          );
        }
        if (nargs === 1) {
          iter = Sk.abstr.iter(args[0]);
        } else {
          iter = Sk.abstr.iter(new Sk.builtin.tuple(args));
        }
        if (!Sk.builtin.checkNone(key) && !Sk.builtin.checkCallable(key)) {
          throw new Sk.builtin.TypeError("'" + Sk.abstr.typeName(key) + "' object is not callable");
        }
        let highest;
        return Sk.misceval.chain(
          iter.tp$iternext(true),
          (i) => {
            highest = i;
            if (highest === void 0) {
              return;
            }
            if (Sk.builtin.checkNone(key)) {
              return Sk.misceval.iterFor(iter, (i2) => {
                if (Sk.misceval.richCompareBool(i2, highest, "Gt")) {
                  highest = i2;
                }
              });
            } else {
              return Sk.misceval.chain(
                Sk.misceval.callsimOrSuspendArray(key, [highest]),
                (highest_compare) => Sk.misceval.iterFor(
                  iter,
                  (i2) => Sk.misceval.chain(
                    Sk.misceval.callsimOrSuspendArray(key, [i2]),
                    (i_compare) => {
                      if (Sk.misceval.richCompareBool(
                        i_compare,
                        highest_compare,
                        "Gt"
                      )) {
                        highest = i2;
                        highest_compare = i_compare;
                      }
                    }
                  )
                )
              );
            }
          },
          () => {
            if (highest === void 0) {
              if ($default === null) {
                throw new Sk.builtin.ValueError("max() arg is an empty sequence");
              } else {
                highest = $default;
              }
            }
            return highest;
          }
        );
      };
      Sk.builtin.min.co_fastcall = Sk.builtin.max.co_fastcall = 1;
      Sk.builtin.any = function any2(iter) {
        return Sk.misceval.chain(
          Sk.misceval.iterFor(Sk.abstr.iter(iter), function(i) {
            if (Sk.misceval.isTrue(i)) {
              return new Sk.misceval.Break(Sk.builtin.bool.true$);
            }
          }),
          (brValue) => brValue || Sk.builtin.bool.false$
        );
      };
      Sk.builtin.all = function all(iter) {
        return Sk.misceval.chain(
          Sk.misceval.iterFor(Sk.abstr.iter(iter), function(i) {
            if (!Sk.misceval.isTrue(i)) {
              return new Sk.misceval.Break(Sk.builtin.bool.false$);
            }
          }),
          (brValue) => brValue || Sk.builtin.bool.true$
        );
      };
      Sk.builtin.sum = function sum(iter, start) {
        var tot;
        const it = Sk.abstr.iter(iter);
        if (start === void 0) {
          tot = new Sk.builtin.int_(0);
        } else if (Sk.builtin.checkString(start)) {
          throw new Sk.builtin.TypeError("sum() can't sum strings [use ''.join(seq) instead]");
        } else {
          tot = start;
        }
        function fastSumInt() {
          return Sk.misceval.iterFor(it, (i) => {
            if (i.constructor === Sk.builtin.int_) {
              tot = tot.nb$add(i);
            } else if (i.constructor === Sk.builtin.float_) {
              tot = tot.nb$float().nb$add(i);
              return new Sk.misceval.Break("float");
            } else {
              tot = Sk.abstr.numberBinOp(tot, i, "Add");
              return new Sk.misceval.Break("slow");
            }
          });
        }
        function fastSumFloat() {
          return Sk.misceval.iterFor(it, (i) => {
            if (i.constructor === Sk.builtin.float_ || i.constructor === Sk.builtin.int_) {
              tot = tot.nb$add(i);
            } else {
              tot = Sk.abstr.numberBinOp(tot, i, "Add");
              return new Sk.misceval.Break("slow");
            }
          });
        }
        function slowSum() {
          return Sk.misceval.iterFor(it, (i) => {
            tot = Sk.abstr.numberBinOp(tot, i, "Add");
          });
        }
        let sumType;
        if (start === void 0 || start.constructor === Sk.builtin.int_) {
          sumType = fastSumInt();
        } else if (start.constructor === Sk.builtin.float_) {
          sumType = "float";
        } else {
          sumType = "slow";
        }
        return Sk.misceval.chain(
          sumType,
          (sumType2) => {
            if (sumType2 === "float") {
              return fastSumFloat();
            }
            return sumType2;
          },
          (sumType2) => {
            if (sumType2 === "slow") {
              return slowSum();
            }
          },
          () => tot
        );
      };
      Sk.builtin.zip = function zip() {
        var el;
        var tup;
        var done;
        var res;
        var i;
        var iters;
        if (arguments.length === 0) {
          return new Sk.builtin.list([]);
        }
        iters = [];
        for (i = 0; i < arguments.length; i++) {
          if (Sk.builtin.checkIterable(arguments[i])) {
            iters.push(Sk.abstr.iter(arguments[i]));
          } else {
            throw new Sk.builtin.TypeError("argument " + i + " must support iteration");
          }
        }
        res = [];
        done = false;
        while (!done) {
          tup = [];
          for (i = 0; i < arguments.length; i++) {
            el = iters[i].tp$iternext();
            if (el === void 0) {
              done = true;
              break;
            }
            tup.push(el);
          }
          if (!done) {
            res.push(new Sk.builtin.tuple(tup));
          }
        }
        return new Sk.builtin.list(res);
      };
      Sk.builtin.abs = function abs(x) {
        if (x.nb$abs) {
          return x.nb$abs();
        }
        throw new Sk.builtin.TypeError("bad operand type for abs(): '" + Sk.abstr.typeName(x) + "'");
      };
      Sk.builtin.fabs = function fabs(x) {
        return Sk.builtin.abs(x);
      };
      Sk.builtin.ord = function ord(x) {
        if (Sk.builtin.checkString(x)) {
          if ([...x.v].length !== 1 && x.sq$length() !== 1) {
            throw new Sk.builtin.TypeError(
              "ord() expected a character, but string of length " + x.v.length + " found"
            );
          }
          return new Sk.builtin.int_(x.v.codePointAt(0));
        } else if (Sk.builtin.checkBytes(x)) {
          if (x.sq$length() !== 1) {
            throw new Sk.builtin.TypeError(
              "ord() expected a character, but string of length " + x.v.length + " found"
            );
          }
          return new Sk.builtin.int_(x.v[0]);
        }
        throw new Sk.builtin.TypeError(
          "ord() expected a string of length 1, but " + Sk.abstr.typeName(x) + " found"
        );
      };
      Sk.builtin.chr = function chr(x) {
        if (!Sk.builtin.checkInt(x)) {
          throw new Sk.builtin.TypeError("an integer is required");
        }
        x = Sk.builtin.asnum$(x);
        if (Sk.__future__.python3) {
          if (x < 0 || x >= 1114112) {
            throw new Sk.builtin.ValueError("chr() arg not in range(0x110000)");
          }
        } else {
          if (x < 0 || x >= 256) {
            throw new Sk.builtin.ValueError("chr() arg not in range(256)");
          }
        }
        return new Sk.builtin.str(String.fromCodePoint(x));
      };
      Sk.builtin.unichr = function unichr(x) {
        Sk.builtin.pyCheckArgsLen("unichr", arguments.length, 1, 1);
        if (!Sk.builtin.checkInt(x)) {
          throw new Sk.builtin.TypeError("an integer is required");
        }
        x = Sk.builtin.asnum$(x);
        try {
          return new Sk.builtin.str(String.fromCodePoint(x));
        } catch (err) {
          if (err instanceof RangeError) {
            throw new Sk.builtin.ValueError(err.message);
          }
          throw err;
        }
      };
      Sk.builtin.int2str_ = function helper_(x, radix, prefix) {
        let v = x.nb$index();
        let isNegative = false;
        if (typeof v === "number") {
          isNegative = v < 0;
          v = isNegative ? -v : v;
        } else {
          isNegative = JSBI.lessThan(v, JSBI.__ZERO);
          v = isNegative ? JSBI.unaryMinus(v) : v;
        }
        let str = v.toString(radix);
        if (isNegative) {
          str = "-" + prefix + str;
        } else {
          str = prefix + str;
        }
        if (radix !== 2 && !Sk.__future__.python3 && (x instanceof Sk.builtin.lng || JSBI.__isBigInt(v))) {
          str += "L";
        }
        return new Sk.builtin.str(str);
      };
      Sk.builtin.hex = function hex(x) {
        if (!Sk.misceval.isIndex(x)) {
          throw new Sk.builtin.TypeError("hex() argument can't be converted to hex");
        }
        return Sk.builtin.int2str_(x, 16, "0x");
      };
      Sk.builtin.oct = function oct(x) {
        if (!Sk.misceval.isIndex(x)) {
          throw new Sk.builtin.TypeError("oct() argument can't be converted to hex");
        }
        if (Sk.__future__.octal_number_literal) {
          return Sk.builtin.int2str_(x, 8, "0o");
        } else {
          return Sk.builtin.int2str_(x, 8, "0");
        }
      };
      Sk.builtin.bin = function bin(x) {
        if (!Sk.misceval.isIndex(x)) {
          throw new Sk.builtin.TypeError(
            "'" + Sk.abstr.typeName(x) + "' object can't be interpreted as an index"
          );
        }
        return Sk.builtin.int2str_(x, 2, "0b");
      };
      Sk.builtin.dir = function dir(obj) {
        if (obj !== void 0) {
          const obj_dir_func = Sk.abstr.lookupSpecial(obj, Sk.builtin.str.$dir);
          return Sk.misceval.chain(
            Sk.misceval.callsimOrSuspendArray(obj_dir_func, []),
            (dir2) => Sk.builtin.sorted(dir2)
          );
        }
        throw new Sk.builtin.NotImplementedError("skulpt does not yet support dir with no args");
      };
      Sk.builtin.repr = function repr(x) {
        return x.$r();
      };
      Sk.builtin.ascii = function ascii(x) {
        return Sk.misceval.chain(x.$r(), (r) => {
          let ret;
          let i;
          for (i = 0; i < r.v.length; i++) {
            if (r.v.charCodeAt(i) >= 127) {
              ret = r.v.substr(0, i);
              break;
            }
          }
          if (!ret) {
            return r;
          }
          for (; i < r.v.length; i++) {
            let c = r.v.charAt(i);
            let cc = r.v.charCodeAt(i);
            if (cc > 127 && cc <= 255) {
              let ashex = cc.toString(16);
              if (ashex.length < 2) {
                ashex = "0" + ashex;
              }
              ret += "\\x" + ashex;
            } else if (cc > 127 && cc < 55296 || cc >= 57344) {
              ret += "\\u" + ("000" + cc.toString(16)).slice(-4);
            } else if (cc >= 55296) {
              let val = r.v.codePointAt(i);
              i++;
              val = val.toString(16);
              let s = "0000000" + val.toString(16);
              if (val.length > 4) {
                ret += "\\U" + s.slice(-8);
              } else {
                ret += "\\u" + s.slice(-4);
              }
            } else {
              ret += c;
            }
          }
          return new Sk.builtin.str(ret);
        });
      };
      Sk.builtin.open = function open(filename, mode, bufsize, encoding, errors, newline, closedf, opener) {
        if (mode === void 0) {
          mode = new Sk.builtin.str("r");
        }
        if (bufsize === void 0) {
          bufsize = -1;
        }
        if (/\+/.test(mode.v)) {
          throw "todo; haven't implemented read/write mode";
        } else if ((mode.v === "w" || mode.v === "wb" || mode.v === "a" || mode.v === "ab") && !Sk.nonreadopen) {
          throw "todo; haven't implemented non-read opens";
        }
        return new Sk.builtin.file(filename, mode, bufsize, encoding, errors, newline, closedf, opener);
      };
      Sk.builtin.isinstance = function isinstance(obj, type) {
        if (!Sk.builtin.checkClass(type) && !(type instanceof Sk.builtin.tuple)) {
          throw new Sk.builtin.TypeError(
            "isinstance() arg 2 must be a class, type, or tuple of classes and types"
          );
        }
        const act_type = obj.ob$type;
        if (act_type === type) {
          return Sk.builtin.bool.true$;
        }
        if (!(type instanceof Sk.builtin.tuple)) {
          if (act_type.$isSubType(type)) {
            return Sk.builtin.bool.true$;
          }
          const maybe_type = obj.tp$getattr(Sk.builtin.str.$class);
          if (maybe_type == act_type) {
            return Sk.builtin.bool.false$;
          } else if (Sk.builtin.checkClass(maybe_type) && maybe_type.$isSubType(type)) {
            return Sk.builtin.bool.true$;
          }
          return Sk.builtin.bool.false$;
        }
        for (let i = 0; i < type.v.length; ++i) {
          if (Sk.misceval.isTrue(Sk.builtin.isinstance(obj, type.v[i]))) {
            return Sk.builtin.bool.true$;
          }
        }
        return Sk.builtin.bool.false$;
      };
      Sk.builtin.hash = function hash(obj) {
        return new Sk.builtin.int_(Sk.abstr.objectHash(obj));
      };
      Sk.builtin.getattr = function getattr(obj, pyName, default_) {
        if (!Sk.builtin.checkString(pyName)) {
          throw new Sk.builtin.TypeError("attribute name must be string");
        }
        const res = Sk.misceval.tryCatch(
          () => obj.tp$getattr(pyName, true),
          (e) => {
            if (e instanceof Sk.builtin.AttributeError) {
              return void 0;
            } else {
              throw e;
            }
          }
        );
        return Sk.misceval.chain(res, (r) => {
          if (r === void 0) {
            if (default_ !== void 0) {
              return default_;
            }
            throw new Sk.builtin.AttributeError(
              obj.sk$attrError() + " has no attribute " + Sk.misceval.objectRepr(pyName)
            );
          }
          return r;
        });
      };
      Sk.builtin.setattr = function setattr(obj, pyName, value) {
        if (!Sk.builtin.checkString(pyName)) {
          throw new Sk.builtin.TypeError("attribute name must be string");
        }
        return Sk.misceval.chain(obj.tp$setattr(pyName, value, true), () => Sk.builtin.none.none$);
      };
      Sk.builtin.raw_input = function(prompt) {
        var lprompt = prompt ? prompt : "";
        return Sk.misceval.chain(Sk.importModule("sys", false, true), function(sys) {
          if (Sk.inputfunTakesPrompt) {
            return Sk.builtin.file.$readline(sys["$d"]["stdin"], null, lprompt);
          } else {
            return Sk.misceval.chain(
              void 0,
              function() {
                return Sk.misceval.callsimOrSuspendArray(sys["$d"]["stdout"]["write"], [
                  sys["$d"]["stdout"],
                  new Sk.builtin.str(lprompt)
                ]);
              },
              function() {
                return Sk.misceval.callsimOrSuspendArray(sys["$d"]["stdin"]["readline"], [
                  sys["$d"]["stdin"]
                ]);
              }
            );
          }
        });
      };
      Sk.builtin.input = Sk.builtin.raw_input;
      Sk.builtin.jseval = function jseval(evalcode) {
        var result = Sk.global["eval"](Sk.ffi.remapToJs(evalcode));
        try {
          return Sk.ffi.remapToPy(result);
        } catch (err) {
          if (err.constructor === Sk.asserts.AssertionError) {
            return Sk.builtin.none.none$;
          }
          throw err;
        }
      };
      Sk.builtin.jsmillis = function jsmillis() {
        var now = /* @__PURE__ */ new Date();
        return now.valueOf();
      };
      var pyCode = Sk.abstr.buildNativeClass("code", {
        constructor: function code(filename, compiled) {
          this.compiled = compiled;
          this.code = compiled.code;
          this.filename = filename;
        },
        slots: {
          tp$new(args, kwargs) {
            throw new Sk.builtin.NotImplementedError("cannot construct a code object in skulpt");
          },
          $r() {
            return new Sk.builtin.str("<code object <module>, file " + this.filename + ">");
          }
        }
      });
      Sk.builtin.compile = function(source, filename, mode, flags, dont_inherit, optimize) {
        Sk.builtin.pyCheckType("source", "str", Sk.builtin.checkString(source));
        Sk.builtin.pyCheckType("filename", "str", Sk.builtin.checkString(filename));
        Sk.builtin.pyCheckType("mode", "str", Sk.builtin.checkString(mode));
        source = source.$jsstr();
        filename = filename.$jsstr();
        mode = mode.$jsstr();
        return Sk.misceval.chain(
          Sk.compile(source, filename, mode, true, true),
          (co) => new pyCode(filename, co)
        );
      };
      Sk.builtin.eval = function(source, globals, locals) {
        if (Sk.builtin.checkString(source)) {
          source = source.$jsstr();
        } else if (Sk.builtin.checkBytes(source)) {
          throw new Sk.builtin.NotImplementedError("bytes for eval is not yet implemented in skulpt");
        }
        if (typeof source === "string") {
          source = source.trim();
          const parse = Sk.parse("?", source);
          const ast = Sk.astFromParse(parse.cst, "?", parse.flags);
          if (ast.body.length > 1 || !(ast.body[0] instanceof Sk.astnodes.Expr)) {
            throw new Sk.builtin.SyntaxError("invalid syntax");
          }
          source = "__final_res__ = " + source;
        } else if (!(source instanceof pyCode)) {
          throw new Sk.builtin.TypeError("eval() arg 1 must be a string, bytes or code object");
        }
        return Sk.misceval.chain(Sk.builtin.exec(source, globals, locals), (new_locals) => {
          const res = new_locals.__final_res__ || Sk.builtin.none.none$;
          delete new_locals.__final_res__;
          return res;
        });
      };
      Sk.builtin.map = function map(fun, seq) {
        var retval = [];
        var next;
        var nones;
        var args;
        var argnum;
        var i;
        var iterables;
        var combined;
        Sk.builtin.pyCheckArgsLen("map", arguments.length, 2);
        if (arguments.length > 2) {
          combined = [];
          iterables = Array.prototype.slice.apply(arguments).slice(1);
          for (i = 0; i < iterables.length; i++) {
            if (!Sk.builtin.checkIterable(iterables[i])) {
              argnum = parseInt(i, 10) + 2;
              throw new Sk.builtin.TypeError(
                "argument " + argnum + " to map() must support iteration"
              );
            }
            iterables[i] = Sk.abstr.iter(iterables[i]);
          }
          while (true) {
            args = [];
            nones = 0;
            for (i = 0; i < iterables.length; i++) {
              next = iterables[i].tp$iternext();
              if (next === void 0) {
                args.push(Sk.builtin.none.none$);
                nones++;
              } else {
                args.push(next);
              }
            }
            if (nones !== iterables.length) {
              combined.push(args);
            } else {
              break;
            }
          }
          seq = new Sk.builtin.list(combined);
        }
        if (!Sk.builtin.checkIterable(seq)) {
          throw new Sk.builtin.TypeError("'" + Sk.abstr.typeName(seq) + "' object is not iterable");
        }
        return Sk.misceval.chain(
          Sk.misceval.iterFor(Sk.abstr.iter(seq), function(item) {
            if (fun === Sk.builtin.none.none$) {
              if (item instanceof Array) {
                item = new Sk.builtin.tuple(item);
              }
              retval.push(item);
            } else {
              if (!(item instanceof Array)) {
                item = [item];
              }
              return Sk.misceval.chain(
                Sk.misceval.callsimOrSuspendArray(fun, item),
                function(result) {
                  retval.push(result);
                }
              );
            }
          }),
          function() {
            return new Sk.builtin.list(retval);
          }
        );
      };
      Sk.builtin.reduce = function reduce(fun, seq, initializer) {
        var item;
        var accum_value;
        var iter;
        if (!Sk.builtin.checkIterable(seq)) {
          throw new Sk.builtin.TypeError("'" + Sk.abstr.typeName(seq) + "' object is not iterable");
        }
        iter = Sk.abstr.iter(seq);
        if (initializer === void 0) {
          initializer = iter.tp$iternext();
          if (initializer === void 0) {
            throw new Sk.builtin.TypeError("reduce() of empty sequence with no initial value");
          }
        }
        accum_value = initializer;
        for (item = iter.tp$iternext(); item !== void 0; item = iter.tp$iternext()) {
          accum_value = Sk.misceval.callsimArray(fun, [accum_value, item]);
        }
        return accum_value;
      };
      Sk.builtin.sorted = function sorted(iterable, cmp, key, reverse) {
        const lst = Sk.misceval.arrayFromIterable(iterable, true);
        return Sk.misceval.chain(lst, (L) => {
          L = new Sk.builtin.list(L);
          L.list$sort(cmp, key, reverse);
          return L;
        });
      };
      Sk.builtin.filter = function filter(fun, iterable) {
        var result;
        var iter, item;
        var retval;
        var ret;
        var add;
        var ctor;
        Sk.builtin.pyCheckArgsLen("filter", arguments.length, 2, 2);
        if (!Sk.builtin.checkIterable(iterable)) {
          throw new Sk.builtin.TypeError(
            "'" + Sk.abstr.typeName(iterable) + "' object is not iterable"
          );
        }
        ctor = function() {
          return [];
        };
        add = function(iter2, item2) {
          iter2.push(item2);
          return iter2;
        };
        ret = function(iter2) {
          return new Sk.builtin.list(iter2);
        };
        if (iterable.ob$type === Sk.builtin.str) {
          ctor = function() {
            return new Sk.builtin.str("");
          };
          add = function(iter2, item2) {
            return iter2.sq$concat(item2);
          };
          ret = function(iter2) {
            return iter2;
          };
        } else if (iterable.ob$type === Sk.builtin.tuple) {
          ret = function(iter2) {
            return new Sk.builtin.tuple(iter2);
          };
        }
        retval = ctor();
        for (iter = Sk.abstr.iter(iterable), item = iter.tp$iternext(); item !== void 0; item = iter.tp$iternext()) {
          if (fun === Sk.builtin.none.none$) {
            result = new Sk.builtin.bool(item);
          } else {
            result = Sk.misceval.callsimArray(fun, [item]);
          }
          if (Sk.misceval.isTrue(result)) {
            retval = add(retval, item);
          }
        }
        return ret(retval);
      };
      Sk.builtin.hasattr = function hasattr(obj, pyName) {
        if (!Sk.builtin.checkString(pyName)) {
          throw new Sk.builtin.TypeError("hasattr(): attribute name must be string");
        }
        const res = Sk.misceval.tryCatch(
          () => obj.tp$getattr(pyName, true),
          (e) => {
            if (e instanceof Sk.builtin.AttributeError) {
              return void 0;
            } else {
              throw e;
            }
          }
        );
        return Sk.misceval.chain(
          res,
          (val) => val === void 0 ? Sk.builtin.bool.false$ : Sk.builtin.bool.true$
        );
      };
      Sk.builtin.pow = function pow(v, w, z) {
        if (z === void 0 || Sk.builtin.checkNone(z)) {
          return Sk.abstr.numberBinOp(v, w, "Pow");
        }
        if (!(Sk.builtin.checkInt(v) && Sk.builtin.checkInt(w) && Sk.builtin.checkInt(z))) {
          if (Sk.builtin.checkFloat(v) || Sk.builtin.checkComplex(v)) {
            return v.nb$power(w, z);
          }
          throw new Sk.builtin.TypeError(
            "unsupported operand type(s) for ** or pow(): '" + Sk.abstr.typeName(v) + "', '" + Sk.abstr.typeName(w) + "', '" + Sk.abstr.typeName(z) + "'"
          );
        }
        return v.nb$power(w, z);
      };
      Sk.builtin.quit = function quit(msg) {
        var s = new Sk.builtin.str(msg).v;
        throw new Sk.builtin.SystemExit(s);
      };
      Sk.builtin.issubclass = function issubclass(c1, c2) {
        if (!Sk.builtin.checkClass(c1)) {
          throw new Sk.builtin.TypeError("issubclass() arg 1 must be a class");
        }
        let c2_isClass = Sk.builtin.checkClass(c2);
        if (!c2_isClass && !(c2 instanceof Sk.builtin.tuple)) {
          throw new Sk.builtin.TypeError("issubclass() arg 2 must be a class or tuple of classes");
        }
        if (c2_isClass) {
          return c1.$isSubType(c2) ? Sk.builtin.bool.true$ : Sk.builtin.bool.false$;
        }
        for (let i = 0; i < c2.v.length; ++i) {
          if (Sk.misceval.isTrue(Sk.builtin.issubclass(c1, c2.v[i]))) {
            return Sk.builtin.bool.true$;
          }
        }
        return Sk.builtin.bool.false$;
      };
      Sk.builtin.globals = function globals() {
        var i, unmangled;
        var ret = new Sk.builtin.dict([]);
        for (i in Sk["globals"]) {
          unmangled = Sk.unfixReserved(i);
          ret.mp$ass_subscript(new Sk.builtin.str(unmangled), Sk["globals"][i]);
        }
        return ret;
      };
      Sk.builtin.divmod = function divmod(a, b) {
        return Sk.abstr.numberBinOp(a, b, "DivMod");
      };
      Sk.builtin.format = function format(value, format_spec) {
        return Sk.abstr.objectFormat(value, format_spec);
      };
      var idMap = /* @__PURE__ */ new Map();
      var _id = 0;
      Sk.builtin.id = function(obj) {
        const id = idMap.get(obj);
        if (id !== void 0) {
          return new Sk.builtin.int_(id);
        }
        idMap.set(obj, _id);
        return new Sk.builtin.int_(_id++);
      };
      Sk.builtin.bytearray = function bytearray() {
        throw new Sk.builtin.NotImplementedError("bytearray is not yet implemented");
      };
      Sk.builtin.callable = function callable(obj) {
        if (Sk.builtin.checkCallable(obj)) {
          return Sk.builtin.bool.true$;
        }
        return Sk.builtin.bool.false$;
      };
      Sk.builtin.delattr = function delattr(obj, attr) {
        return Sk.builtin.setattr(obj, attr, void 0);
      };
      Sk.builtin.execfile = function execfile() {
        throw new Sk.builtin.NotImplementedError("execfile is not yet implemented");
      };
      Sk.builtin.exec = function exec(code, globals, locals) {
        Sk.builtin.pyCheckArgs("exec", arguments, 1, 3);
        let filename = globals && globals.__file__;
        if (filename !== void 0 && Sk.builtin.checkString(filename)) {
          filename = filename.toString();
        } else if (code instanceof pyCode) {
          filename = code.filename;
        } else {
          filename = "<string>";
        }
        if (Sk.builtin.checkString(code)) {
          code = Sk.compile(code.$jsstr(), filename, "exec", true, true);
        } else if (typeof code === "string") {
          code = Sk.compile(code, filename, "exec", true, true);
        } else if (!(code instanceof pyCode)) {
          throw new Sk.builtin.TypeError("exec() arg 1 must be a string, bytes or code object");
        }
        Sk.asserts.assert(
          globals === void 0 || globals.constructor === Object,
          "internal calls to exec should be called with a javascript object for globals"
        );
        Sk.asserts.assert(
          locals === void 0 || locals.constructor === Object,
          "internal calls to exec should be called with a javascript object for locals"
        );
        let backupGlobals, backupRG, caughtError;
        return Sk.misceval.chain(
          code,
          (co) => {
            if (!Sk.sysmodules.sq$contains(Sk.builtin.str.$sys)) {
              Sk.importModule("sys", false, true);
            }
            return co;
          },
          (co) => {
            backupRG = Sk.retainGlobals;
            Sk.retainGlobals = true;
            if (!globals.__file__) {
              globals.__file__ = Sk.ffi.remapToPy(filename);
            }
            if (!globals.__name__) {
              globals.__name__ = Sk.ffi.remapToPy(filename);
            }
            if (!globals.__package__) {
              globals.__package__ = Sk.builtin.none.none$;
            }
            backupGlobals = Sk.globals;
            Sk.globals = globals;
            caughtError = null;
            return Sk.misceval.tryCatch(
              () => {
                let result = Sk.global["eval"](co.code)(globals, locals);
                while (result instanceof Sk.misceval.Suspension) {
                  if (!result.optional) {
                    return Sk.misceval.promiseToSuspension(
                      Sk.misceval.asyncToPromise(() => result)
                    );
                  }
                  result = result.resume();
                }
                return result;
              },
              (e) => {
                console.error("exec error:", e, locals, globals);
                caughtError = e;
              }
            );
          },
          (new_locals) => {
            Sk.globals = backupGlobals;
            Sk.retainGlobals = backupRG;
            if (caughtError !== null) {
              throw caughtError;
            }
            return new_locals;
          }
        );
      };
      Sk.builtin.help = function help() {
        throw new Sk.builtin.NotImplementedError("help is not yet implemented");
      };
      Sk.builtin.iter = function iter(obj, sentinel) {
        if (arguments.length === 1) {
          return Sk.abstr.iter(obj);
        } else {
          return Sk.abstr.iter(new Sk.builtin.callable_iter_(obj, sentinel));
        }
      };
      Sk.builtin.locals = function locals() {
        throw new Sk.builtin.NotImplementedError("locals is not yet implemented");
      };
      Sk.builtin.memoryview = function memoryview() {
        throw new Sk.builtin.NotImplementedError("memoryview is not yet implemented");
      };
      Sk.builtin.next_ = function next_(iter, default_) {
        if (!iter.tp$iternext) {
          throw new Sk.builtin.TypeError(
            "'" + Sk.abstr.typeName(iter) + "' object is not an iterator"
          );
        }
        return Sk.misceval.chain(iter.tp$iternext(true), (nxt) => {
          if (nxt === void 0) {
            if (default_) {
              return default_;
            }
            const v = iter.gi$ret;
            if (v !== void 0 && v !== Sk.builtin.none.none$) {
              throw new Sk.builtin.StopIteration(v);
            } else {
              throw new Sk.builtin.StopIteration();
            }
          }
          return nxt;
        });
      };
      Sk.builtin.reload = function reload() {
        throw new Sk.builtin.NotImplementedError("reload is not yet implemented");
      };
      Sk.builtin.vars = function vars(obj) {
        if (arguments.length === 1) {
          if (obj.$d) {
            return obj.$d;
          } else {
            throw new Sk.builtin.TypeError("vars() argument must have __dict__ attribute");
          }
        } else {
          throw new Sk.builtin.NotImplementedError("vars() is not yet implemented");
        }
      };
      Sk.builtin.apply_ = function apply_() {
        throw new Sk.builtin.NotImplementedError("apply is not yet implemented");
      };
      Sk.builtin.buffer = function buffer_() {
        throw new Sk.builtin.NotImplementedError("buffer is not yet implemented");
      };
      Sk.builtin.coerce = function coerce() {
        throw new Sk.builtin.NotImplementedError("coerce is not yet implemented");
      };
      Sk.builtin.intern = function intern() {
        throw new Sk.builtin.NotImplementedError("intern is not yet implemented");
      };
    }
  });

  // src/errors.js
  var require_errors = __commonJS({
    "src/errors.js"() {
      var BaseException = Sk.abstr.buildNativeClass("BaseException", {
        constructor: function BaseException2(arg, ...tb) {
          Sk.asserts.assert(
            this instanceof BaseException2,
            "bad call to exception constructor, use 'new'"
          );
          if (typeof arg === "string") {
            arg = new Sk.builtin.str(arg);
          }
          this.args = new Sk.builtin.tuple(arg ? [arg] : []);
          this.traceback = tb.length >= 2 ? [{ filename: tb[0] || "<unknown>", text: tb[1], lineno: tb[2] }] : [];
          this._full_traceback = tb;
          this.feedback = Sk.builtin.none.none$;
          this.__cause__ = Sk.builtin.none.none$;
          this.__context__ = Sk.builtin.none.none$;
          this.__suppress_context__ = Sk.builtin.none.none$;
          this.$d = new Sk.builtin.dict();
        },
        slots: (
          /**@lends {BaseException}*/
          {
            tp$getattr: Sk.generic.getAttr,
            tp$doc: "Common base class for all exceptions",
            tp$new: BaseExc_new,
            tp$init: BaseExc_init,
            $r() {
              let ret = this.tp$name;
              ret += "(" + this.args.v.map((x) => Sk.misceval.objectRepr(x)).join(", ") + ")";
              return new Sk.builtin.str(ret);
            },
            tp$str: BaseExc_str
          }
        ),
        getsets: (
          /**@lends {BaseException}*/
          {
            args: {
              $get() {
                return this.args;
              },
              $set(v) {
                checkDeleting(v, "args");
                this.args = new Sk.builtin.tuple(v);
              }
            },
            __dict__: Sk.generic.getSetDict,
            __cause__: {
              $get: function() {
                return this.__cause__;
              },
              $set: function(v) {
                this.__cause__ = v;
              }
            },
            feedback: {
              $get: function() {
                return this.feedback;
              },
              $set: function(v) {
                this.feedback = v;
              }
            },
            __context__: {
              $get: function() {
                return this.__context__;
              },
              $set: function(v) {
                this.__context__ = v;
              }
            },
            __suppress_context__: {
              $get: function() {
                return this.__suppress_context__;
              },
              $set: function(v) {
                this.__suppress_context__ = v;
              }
            }
          }
        ),
        proto: (
          /**@lends {BaseException}*/
          {
            toString() {
              let ret = this.tp$name;
              ret += ": " + this.tp$str().v;
              if (this.traceback.length !== 0) {
                ret += " on line " + this.traceback[0].lineno;
              } else {
                ret += " at <unknown>";
              }
              if (this.args.v.length > 4) {
                ret += "\n" + this.args.v[4].v + "\n";
                for (let i = 0; i < this.args.v[3]; ++i) {
                  ret += " ";
                }
                ret += "^\n";
              }
              return ret;
            }
          }
        )
      });
      function checkDeleting(v, name) {
        if (v === void 0) {
          throw new Sk.builtin.TypeError(`${name} may not be deleted`);
        }
      }
      function BaseExc_new(args, kws) {
        const instance = new this.constructor();
        if (this.ht$type) {
          BaseException.call(instance);
        }
        instance.args = new Sk.builtin.tuple(args.slice(0));
        return instance;
      }
      function BaseExc_init(args, kws) {
        Sk.abstr.checkNoKwargs(Sk.abstr.typeName(this), kws);
        this.args = new Sk.builtin.tuple(args.slice(0));
      }
      function BaseExc_str() {
        if (this.args.v.length <= 1) {
          return new Sk.builtin.str(this.args.v[0]);
        }
        return this.args.$r();
      }
      function complexExtends(base, name, doc, init, descriptors, str) {
        descriptors || (descriptors = []);
        const flags = init ? {} : { sk$solidBase: false };
        const slots = { tp$init: init || BaseExc_init, tp$doc: doc };
        if (str) {
          slots.tp$str = str;
        }
        return Sk.abstr.buildNativeClass(name, {
          base,
          constructor: function pyExc2(...args) {
            base.apply(this, args);
            descriptors.forEach((getset, i) => {
              this["$" + getset] = Sk.ffi.remapToPy(args[i]);
            });
          },
          slots,
          getsets: Object.fromEntries(
            descriptors.map((getset) => [
              getset,
              {
                $get() {
                  return this["$" + getset] || Sk.builtin.none.none$;
                },
                $set(v) {
                  this["$" + getset] = v || Sk.builtin.none.none$;
                }
              }
            ])
          ),
          flags
        });
      }
      function simpleExtends(base, name, doc) {
        const tp$init = base.prototype.tp$init;
        const slots = { tp$doc: doc, tp$init };
        if (tp$init === BaseExc_init) {
          slots.tp$new = BaseExc_new;
        }
        return Sk.abstr.buildNativeClass(name, {
          base,
          constructor: function pyExc2(...args) {
            base.apply(this, args);
          },
          slots,
          flags: {
            sk$solidBase: false
          }
        });
      }
      var SystemExit = simpleExtends(
        BaseException,
        "SystemExit",
        "Request to exit from the interpreter."
      );
      var KeyboardInterrupt = simpleExtends(
        BaseException,
        "KeyboardInterrupt",
        "Program interrupted by user."
      );
      var GeneratorExit = simpleExtends(
        BaseException,
        "GeneratorExit",
        "Request that a generator exit."
      );
      var Exception = simpleExtends(
        BaseException,
        "Exception",
        "Common base class for all non-exit exceptions."
      );
      var StopIteration = complexExtends(
        Exception,
        "StopIteration",
        "Signal the end from iterator.__next__().",
        function init(args, kws) {
          BaseExc_init.call(this, args, kws);
          this.$value = args[0] || Sk.builtin.none.none$;
        },
        ["value"]
      );
      var StopAsyncIteration = simpleExtends(
        Exception,
        "StopAsyncIteration",
        "Signal the end from iterator.__anext__()."
      );
      var ArithmeticError = simpleExtends(
        Exception,
        "ArithmeticError",
        "Base class for arithmetic errors."
      );
      var FloatingPointError = simpleExtends(
        ArithmeticError,
        "FloatingPointError",
        "Floating point operation failed."
      );
      var OverflowError = simpleExtends(
        ArithmeticError,
        "OverflowError",
        "Result too large to be represented."
      );
      var ZeroDivisionError = simpleExtends(
        ArithmeticError,
        "ZeroDivisionError",
        "Second argument to a division or modulo operation was zero."
      );
      var AssertionError = simpleExtends(Exception, "AssertionError", "Assertion failed.");
      var AttributeError = simpleExtends(Exception, "AttributeError", "Attribute not found.");
      var BufferError = simpleExtends(Exception, "BufferError", "Buffer error.");
      var EOFError = simpleExtends(Exception, "EOFError", "Read beyond end of file.");
      var ImportError = complexExtends(
        Exception,
        "ImportError",
        "Import can't find module, or can't find name in module.",
        function init(args, kws) {
          BaseExc_init.call(this, args);
          const [name, path] = Sk.abstr.copyKeywordsToNamedArgs(
            "ImportError",
            ["name", "path"],
            [],
            kws
          );
          this.$name = name;
          this.$path = path;
          if (args.length === 1) {
            this.$msg = args[0];
          }
        },
        ["msg", "name", "path"],
        function str() {
          if (Sk.builtin.checkString(this.$msg)) {
            return this.$msg;
          }
          return BaseExc_str.call(this);
        }
      );
      var ModuleNotFoundError = simpleExtends(ImportError, "ModuleNotFoundError", "Module not found.");
      var LookupError = simpleExtends(Exception, "LookupError", "Base class for lookup errors.");
      var IndexError = simpleExtends(LookupError, "IndexError", "Sequence index out of range.");
      var KeyError = complexExtends(
        LookupError,
        "KeyError",
        "Mapping key not found.",
        null,
        null,
        function str() {
          if (this.args.v.length === 1) {
            return this.args.v[0].$r();
          }
          return BaseExc_str.call(this);
        }
      );
      var MemoryError = simpleExtends(Exception, "MemoryError", "Out of memory.");
      var NameError = simpleExtends(Exception, "NameError", "Name not found globally.");
      var UnboundLocalError = simpleExtends(
        NameError,
        "UnboundLocalError",
        "Local name referenced but not bound to a value."
      );
      var OSError = complexExtends(
        Exception,
        "OSError",
        "Base class for I/O related errors.",
        function(args, kws) {
          BaseExc_init.call(this, args, kws);
        }
      );
      var FileNotFoundError = simpleExtends(OSError, "FileNotFoundError", "File not found.");
      var TimeoutError = simpleExtends(OSError, "TimeoutError", "Timeout expired.");
      var ReferenceError2 = simpleExtends(
        Exception,
        "ReferenceError",
        "Weak ref proxy used after referent went away."
      );
      var RuntimeError = simpleExtends(Exception, "RuntimeError", "Unspecified run-time error.");
      var NotImplementedError = simpleExtends(
        RuntimeError,
        "NotImplementedError",
        "Method or function hasn't been implemented yet."
      );
      var RecursionError = simpleExtends(RuntimeError, "RecursionError", "Recursion limit exceeded.");
      var SyntaxError2 = complexExtends(
        Exception,
        "SyntaxError",
        "Invalid syntax.",
        function init(args, kws) {
          BaseExc_init.call(this, args, kws);
          if (args.length >= 1) {
            this.$msg = args[0];
          }
          if (args.length === 2) {
            const info = new Sk.builtin.tuple(args[1]).v;
            this.$filename = info[0];
            this.$lineno = info[1];
            if (Array.isArray(info[2].v)) {
              if (Array.isArray(info[2].v[0].v)) {
                this.$offset = info[2].v[0].v[1];
                this.$end_lineno = info[2].v[1].v[0];
                this.$end_offset = info[2].v[1].v[1];
              } else {
                this.$offset = info[2].v[1];
                this.$end_lineno = info[2].v[2];
                this.$end_offset = info[2].v[3];
              }
            } else {
              this.$offset = info[2];
              this.$end_lineno = info[1];
              this.$end_offset = info[2];
            }
            this.$text = info[3];
          }
        },
        [
          "msg",
          "filename",
          "text",
          "lineno",
          "offset",
          "end_lineno",
          "end_offset"
        ],
        function str() {
          return BaseExc_str.call(this);
        }
      );
      var IndentationError2 = simpleExtends(SyntaxError2, "IndentationError", "Improper indentation.");
      var TabError = simpleExtends(
        IndentationError2,
        "TabError",
        "Improper mixture of spaces and tabs."
      );
      var SystemError = simpleExtends(
        Exception,
        "SystemError",
        "Internal error in the Skulpt interpreter."
      );
      var TypeError2 = simpleExtends(Exception, "TypeError", "Inappropriate argument type.");
      var ValueError = simpleExtends(
        Exception,
        "ValueError",
        "Inappropriate argument value (of correct type)."
      );
      var UnicodeError = simpleExtends(ValueError, "UnicodeError", "Unicode related error.");
      var UnicodeDecodeError = simpleExtends(
        UnicodeError,
        "UnicodeDecodeError",
        "Unicode decoding error."
      );
      var UnicodeEncodeError = simpleExtends(
        UnicodeError,
        "UnicodeEncodeError",
        "Unicode encoding error."
      );
      var pyExc = {
        BaseException,
        SystemExit,
        KeyboardInterrupt,
        GeneratorExit,
        Exception,
        StopIteration,
        StopAsyncIteration,
        ArithmeticError,
        FloatingPointError,
        OverflowError,
        ZeroDivisionError,
        AssertionError,
        AttributeError,
        BufferError,
        EOFError,
        ImportError,
        ModuleNotFoundError,
        LookupError,
        IndexError,
        KeyError,
        MemoryError,
        NameError,
        UnboundLocalError,
        OSError,
        IOError: OSError,
        // BlockingIOError,
        // ChildProcessError,
        // ConnectionError,
        // BrokenPipeError,
        // ConnectionAbortedError,
        // ConnectionRefusedError,
        // ConnectionResetError,
        // FileExistsError,
        FileNotFoundError,
        // InterruptedError,
        // IsADirectoryError,
        // NotADirectoryError,
        // PermissionError,
        // ProcessLookupError,
        TimeoutError,
        ReferenceError: ReferenceError2,
        RuntimeError,
        NotImplementedError,
        RecursionError,
        SyntaxError: SyntaxError2,
        IndentationError: IndentationError2,
        TabError,
        SystemError,
        TypeError: TypeError2,
        ValueError,
        UnicodeError,
        UnicodeDecodeError,
        UnicodeEncodeError
        // UnicodeTranslateError,
        // Warning,
        // DeprecationWarning,
        // PendingDeprecationWarning,
        // RuntimeWarning,
        // SyntaxWarning,
        // UserWarning,
        // FutureWarning,
        // ImportWarning,
        // UnicodeWarning,
        // BytesWarning,
        // ResourceWarning,
      };
      Object.assign(Sk.builtin, pyExc);
      Sk.builtin.SuspensionError = simpleExtends(
        Exception,
        "SuspensionError",
        "Unsupported Suspension in code."
      );
      Sk.builtin.ExternalError = Sk.abstr.buildNativeClass("ExternalError", {
        constructor: function ExternalError(...args) {
          this.nativeError = args[0];
          if (!Sk.builtin.checkString(this.nativeError)) {
            args[0] = this.nativeError.toString();
            if (args[0].startsWith("RangeError: Maximum call")) {
              args[0] = "Maximum call stack size exceeded";
              return new RecursionError(...args);
            }
          }
          Exception.apply(this, args);
        },
        base: Exception
      });
      Sk.builtin.frame = function(trace, index = 0) {
        if (!(this instanceof Sk.builtin.frame)) {
          return new Sk.builtin.frame(trace);
        }
        this.trace = trace;
        this.index = index;
        this.__class__ = Sk.builtin.frame;
        return this;
      };
      Sk.abstr.setUpInheritance("frame", Sk.builtin.frame, Sk.builtin.object);
      Sk.builtin.frame.prototype.tp$getattr = function(name) {
        if (name != null && (Sk.builtin.checkString(name) || typeof name === "string")) {
          var _name = name;
          if (Sk.builtin.checkString(name)) {
            _name = Sk.ffi.remapToJs(name);
          }
          let line = this.trace.source;
          if (line == null) {
            if (this.trace.filename != null && this.trace.lineno != null) {
              if (Sk.parse.linecache[this.trace.filename]) {
                line = Sk.parse.linecache[this.trace.filename][this.trace.lineno - 1];
              }
            }
          }
          switch (_name) {
            case "f_back":
              return Sk.builtin.none.none$;
            case "f_builtins":
              return Sk.builtin.none.none$;
            case "f_code":
              return Sk.builtin.none.none$;
            case "f_globals":
              return Sk.builtin.none.none$;
            case "f_lasti":
              return Sk.builtin.none.none$;
            case "f_lineno":
              return Sk.ffi.remapToPy(this.trace.lineno);
            case "f_line":
              return Sk.ffi.remapToPy(line);
            case "f_locals":
              return Sk.builtin.none.none$;
            case "f_trace":
              return Sk.builtin.none.none$;
            case "co_filename":
              return Sk.ffi.remapToPy(this.trace.filename);
            case "co_name":
              return Sk.ffi.remapToPy(this.trace.scope);
          }
        }
        return Sk.builtin.object.prototype.GenericGetAttr(name);
      };
      Sk.builtin.frame.prototype["$r"] = function() {
        return new Sk.builtin.str("<frame object>");
      };
      Sk.exportSymbol("Sk.builtin.frame", Sk.builtin.frame);
      Sk.builtin.traceback = function(trace) {
        if (!(this instanceof Sk.builtin.traceback)) {
          return new Sk.builtin.traceback(trace);
        }
        this.trace = trace;
        const lineno = Array.isArray(trace.lineno) ? trace.lineno[2] : trace.lineno || -1;
        this.tb_lineno = new Sk.builtin.int_(lineno);
        this.tb_frame = new Sk.builtin.frame(trace);
        this.tb_source = new Sk.builtin.str(trace.source || "(Missing Source Code)");
        this.__class__ = Sk.builtin.traceback;
        return this;
      };
      Sk.abstr.setUpInheritance("traceback", Sk.builtin.traceback, Sk.builtin.object);
      Sk.builtin.traceback.fromList = function(traces) {
        var current = Sk.builtin.traceback(traces[0]), first = current;
        for (var i = 1; i < traces.length; i++) {
          current.tb_next = Sk.builtin.traceback(traces[i]);
          current = current.tb_next;
        }
        current.tb_next = Sk.builtin.none.none$;
        return first;
      };
      Sk.builtin.traceback.prototype.tp$getattr = function(name) {
        if (name != null && (Sk.builtin.checkString(name) || typeof name === "string")) {
          var _name = name;
          if (Sk.builtin.checkString(name)) {
            _name = Sk.ffi.remapToJs(name);
          }
          switch (_name) {
            case "tb_lineno":
            case "tb_source":
            case "tb_frame":
            case "tb_next":
              return this[_name];
          }
        }
        return Sk.builtin.object.prototype.GenericGetAttr(name);
      };
      Sk.builtin.traceback.prototype["$r"] = function() {
        return new Sk.builtin.str("<traceback object>");
      };
      Sk.exportSymbol("Sk.builtin.traceback", Sk.builtin.traceback);
      Sk.builtin.getExcInfo = function(e) {
        const v = [e.ob$type || Sk.builtin.none.none$, e, Sk.builtin.none.none$];
        return new Sk.builtin.tuple(v);
      };
    }
  });

  // src/method.js
  var require_method = __commonJS({
    "src/method.js"() {
      Sk.builtin.method = Sk.abstr.buildNativeClass("method", {
        constructor: function method(func, self2) {
          Sk.asserts.assert(
            this instanceof Sk.builtin.method,
            "bad call to method constructor, use 'new'"
          );
          this.im_func = func;
          this.im_self = self2;
          this.im_call = func.tp$call;
        },
        slots: {
          $r() {
            const def_name = "?";
            let name = this.im_func.tp$getattr(Sk.builtin.str.$qualname) || this.im_func.tp$getattr(Sk.builtin.str.$name);
            name = name && name.v || def_name;
            return new Sk.builtin.str(
              "<bound method " + name + " of " + Sk.misceval.objectRepr(this.im_self) + ">"
            );
          },
          tp$hash() {
            const selfhash = Sk.abstr.objectHash(this.im_self);
            const funchash = Sk.abstr.objectHash(this.im_func);
            return selfhash + funchash;
          },
          tp$call(args, kwargs) {
            var im_call = this.im_call;
            if (im_call === void 0) {
              throw new Sk.builtin.TypeError(
                "'" + Sk.abstr.typeName(this.im_func) + "' object is not callable"
              );
            }
            args = [this.im_self, ...args];
            return im_call.call(this.im_func, args, kwargs);
          },
          tp$new(args, kwargs) {
            Sk.abstr.checkNoKwargs("method", kwargs);
            Sk.abstr.checkArgsLen("method", args, 2, 2);
            const func = args[0];
            const self2 = args[1];
            if (!Sk.builtin.checkCallable(func)) {
              throw new Sk.builtin.TypeError("first argument must be callable");
            }
            if (Sk.builtin.checkNone(self2)) {
              throw new Sk.builtin.TypeError("self must not be None");
            }
            return new Sk.builtin.method(func, self2);
          },
          tp$richcompare(other, op) {
            if (op != "Eq" && op != "NotEq" || !(other instanceof Sk.builtin.method)) {
              return Sk.builtin.NotImplemented.NotImplemented$;
            }
            let eq;
            try {
              eq = Sk.misceval.richCompareBool(this.im_self, other.im_self, "Eq", false) && this.im_func == other.im_func;
            } catch (x) {
              eq = false;
            }
            if (op == "Eq") {
              return eq;
            } else {
              return !eq;
            }
          },
          tp$descr_get(obj, obtype) {
            return this;
          },
          tp$getattr(pyName, canSuspend) {
            const descr = Sk.abstr.lookupSpecial(this, pyName);
            if (descr !== void 0) {
              return descr;
            }
            return this.im_func.tp$getattr(pyName, canSuspend);
          }
        },
        getsets: {
          __func__: {
            $get() {
              return this.im_func;
            }
          },
          __self__: {
            $get() {
              return this.im_self;
            }
          },
          __doc__: {
            $get() {
              return this.im_func.tp$getattr(Sk.builtin.str.$doc);
            }
          }
        },
        flags: { sk$unacceptableBase: true }
      });
    }
  });

  // src/misceval.js
  var require_misceval = __commonJS({
    "src/misceval.js"() {
      Sk.misceval = {};
      Sk.misceval.Suspension = function Suspension(resume, child, data) {
        this.$isSuspension = true;
        if (resume !== void 0 && child !== void 0) {
          this.resume = function() {
            return resume(child.resume());
          };
        }
        this.child = child;
        this.optional = child !== void 0 && child.optional;
        if (data === void 0 && child !== void 0) {
          this.data = child.data;
        } else {
          this.data = data;
        }
      };
      Sk.exportSymbol("Sk.misceval.Suspension", Sk.misceval.Suspension);
      Sk.misceval.retryOptionalSuspensionOrThrow = function(susp, message) {
        while (susp instanceof Sk.misceval.Suspension) {
          if (!susp.optional) {
            const err = new Sk.builtin.SuspensionError(
              message || "Cannot call a function that blocks or suspends here"
            );
            let prev_susp = susp;
            const tb = [];
            while (prev_susp != null) {
              if (prev_susp.$lineno) {
                tb.push({
                  filename: prev_susp.$filename,
                  lineno: prev_susp.$lineno,
                  colno: prev_susp.$colno
                });
              }
              prev_susp = prev_susp.child;
            }
            tb.reverse();
            err.traceback.push(...tb);
            throw err;
          }
          susp = susp.resume();
        }
        return susp;
      };
      Sk.exportSymbol(
        "Sk.misceval.retryOptionalSuspensionOrThrow",
        Sk.misceval.retryOptionalSuspensionOrThrow
      );
      Sk.misceval.isIndex = function(o) {
        return o !== null && o !== void 0 && (o.nb$index !== void 0 || typeof o === "number" && Number.isInteger(o));
      };
      Sk.exportSymbol("Sk.misceval.isIndex", Sk.misceval.isIndex);
      function asIndex(index) {
        if (index === null || index === void 0) {
          return;
        } else if (index.sk$int === true) {
          return index.v;
        } else if (index.nb$index !== void 0) {
          return index.nb$index();
        } else if (typeof index === "number" && Number.isInteger(index)) {
          return index;
        }
      }
      function asIndexOrThrow(index, msg) {
        const i = asIndex(index);
        if (i !== void 0) {
          return i;
        }
        msg = msg || "'{tp$name}' object cannot be interpreted as an integer";
        msg = msg.replace("{tp$name}", Sk.abstr.typeName(index));
        throw new Sk.builtin.TypeError(msg);
      }
      Sk.misceval.asIndex = asIndex;
      Sk.misceval.asIndexSized = function(index, Err, msg) {
        const i = asIndexOrThrow(index, msg);
        if (typeof i === "number") {
          return i;
        }
        if (Err == null) {
          return JSBI.lessThan(i, JSBI.__ZERO) ? -Number.MAX_SAFE_INTEGER : Number.MAX_SAFE_INTEGER;
        }
        throw new Err("cannot fit '" + Sk.abstr.typeName(index) + "' into an index-sized integer");
      };
      Sk.misceval.asIndexOrThrow = asIndexOrThrow;
      Sk.misceval.applySlice = function(u, v, w, canSuspend) {
        return Sk.abstr.objectGetItem(u, new Sk.builtin.slice(v, w, null), canSuspend);
      };
      Sk.exportSymbol("Sk.misceval.applySlice", Sk.misceval.applySlice);
      Sk.misceval.assignSlice = function(u, v, w, x, canSuspend) {
        const slice = new Sk.builtin.slice(v, w);
        if (x === null) {
          return Sk.abstr.objectDelItem(u, slice);
        } else {
          return Sk.abstr.objectSetItem(u, slice, x, canSuspend);
        }
      };
      Sk.exportSymbol("Sk.misceval.assignSlice", Sk.misceval.assignSlice);
      Sk.misceval.arrayFromArguments = function(args) {
        var it, i;
        var res;
        var arg;
        if (args.length != 1) {
          return args;
        }
        arg = args[0];
        if (arg instanceof Sk.builtin.set) {
          arg = arg.tp$iter().$obj;
        } else if (arg instanceof Sk.builtin.dict) {
          arg = Sk.builtin.dict.prototype["keys"].func_code(arg);
        }
        if (arg instanceof Sk.builtin.list || arg instanceof Sk.builtin.tuple) {
          return arg.v;
        } else if (Sk.builtin.checkIterable(arg)) {
          res = [];
          for (it = Sk.abstr.iter(arg), i = it.tp$iternext(); i !== void 0; i = it.tp$iternext()) {
            res.push(i);
          }
          return res;
        }
        throw new Sk.builtin.TypeError("'" + Sk.abstr.typeName(arg) + "' object is not iterable");
      };
      Sk.exportSymbol("Sk.misceval.arrayFromArguments", Sk.misceval.arrayFromArguments);
      Sk.misceval.iterator = Sk.abstr.buildIteratorClass("iterator", {
        constructor: function iterator(fn, handlesOwnSuspensions) {
          this.tp$iternext = handlesOwnSuspensions ? fn : function(canSuspend) {
            let x = fn();
            if (canSuspend || !x.$isSuspension) {
              return x;
            } else {
              return Sk.misceval.retryOptionalSuspensionOrThrow(x);
            }
          };
        },
        iternext: function(canSuspend) {
          return this.tp$iternext(canSuspend);
        },
        flags: { sk$unacceptableBase: true }
      });
      Sk.misceval.swappedOp_ = {
        Eq: "Eq",
        NotEq: "NotEq",
        Lt: "GtE",
        LtE: "Gt",
        Gt: "LtE",
        GtE: "Lt",
        Is: "IsNot",
        IsNot: "Is",
        In_: "NotIn",
        NotIn: "In_"
      };
      Sk.misceval.opSymbols = {
        Eq: "==",
        NotEq: "!=",
        Lt: "<",
        LtE: "<=",
        Gt: ">",
        GtE: ">=",
        Is: "is",
        IsNot: "is not",
        In_: "in",
        NotIn: "not in"
      };
      Sk.misceval.richCompareBool = function(v, w, op, canSuspend) {
        Sk.asserts.assert(v.sk$object && w.sk$object, "JS object passed to richCompareBool");
        var ret, swapped_shortcut, shortcut;
        const v_type = v.ob$type;
        const w_type = w.ob$type;
        const w_is_subclass = w_type !== v_type && w_type.sk$baseClass === void 0 && w_type.$isSubType(v_type);
        if (!Sk.__future__.python3 && v_type !== w_type && (op === "GtE" || op === "Gt" || op === "LtE" || op === "Lt")) {
          const numeric_types = [Sk.builtin.float_, Sk.builtin.int_, Sk.builtin.lng, Sk.builtin.bool];
          const sequence_types = [
            Sk.builtin.dict,
            Sk.builtin.enumerate,
            Sk.builtin.filter_,
            Sk.builtin.list,
            Sk.builtin.map_,
            Sk.builtin.str,
            Sk.builtin.tuple,
            Sk.builtin.zip_
          ];
          const v_num_type = numeric_types.indexOf(v_type);
          const v_seq_type = sequence_types.indexOf(v_type);
          const w_num_type = numeric_types.indexOf(w_type);
          const w_seq_type = sequence_types.indexOf(w_type);
          if (v === Sk.builtin.none.none$) {
            switch (op) {
              case "Lt":
                return true;
              case "LtE":
                return true;
              case "Gt":
                return false;
              case "GtE":
                return false;
            }
          }
          if (w === Sk.builtin.none.none$) {
            switch (op) {
              case "Lt":
                return false;
              case "LtE":
                return false;
              case "Gt":
                return true;
              case "GtE":
                return true;
            }
          }
          if (v_num_type !== -1 && w_seq_type !== -1) {
            switch (op) {
              case "Lt":
                return true;
              case "LtE":
                return true;
              case "Gt":
                return false;
              case "GtE":
                return false;
            }
          }
          if (v_seq_type !== -1 && w_num_type !== -1) {
            switch (op) {
              case "Lt":
                return false;
              case "LtE":
                return false;
              case "Gt":
                return true;
              case "GtE":
                return true;
            }
          }
          if (v_seq_type !== -1 && w_seq_type !== -1) {
            switch (op) {
              case "Lt":
                return v_seq_type < w_seq_type;
              case "LtE":
                return v_seq_type <= w_seq_type;
              case "Gt":
                return v_seq_type > w_seq_type;
              case "GtE":
                return v_seq_type >= w_seq_type;
            }
          }
        }
        if (op === "Is") {
          if (v_type === w_type) {
            if (v === w) {
              return true;
            } else if (v_type === Sk.builtin.float_) {
              return v.v === w.v;
            } else if (v_type === Sk.builtin.int_) {
              if (typeof v.v === "number" && typeof v.v === "number") {
                return v.v === w.v;
              }
              return JSBI.equal(JSBI.BigInt(v.v), JSBI.BigInt(w.v));
            }
          }
          return false;
        }
        if (op === "IsNot") {
          if (v_type !== w_type) {
            return true;
          } else if (v_type === Sk.builtin.float_) {
            return v.v !== w.v;
          } else if (v_type === Sk.builtin.int_) {
            if (typeof v.v === "number" && typeof v.v === "number") {
              return v.v !== w.v;
            }
            return JSBI.notEqual(JSBI.BigInt(v.v), JSBI.BigInt(w.v));
          }
          return v !== w;
        }
        if (op === "In") {
          return Sk.misceval.chain(Sk.abstr.sequenceContains(w, v, canSuspend), Sk.misceval.isTrue);
        }
        if (op === "NotIn") {
          return Sk.misceval.chain(Sk.abstr.sequenceContains(w, v, canSuspend), function(x) {
            return !Sk.misceval.isTrue(x);
          });
        }
        var op2shortcut = {
          Eq: "ob$eq",
          NotEq: "ob$ne",
          Gt: "ob$gt",
          GtE: "ob$ge",
          Lt: "ob$lt",
          LtE: "ob$le"
        };
        shortcut = op2shortcut[op];
        if (w_is_subclass) {
          swapped_shortcut = op2shortcut[Sk.misceval.swappedOp_[op]];
          if ((ret = w[swapped_shortcut](v)) !== Sk.builtin.NotImplemented.NotImplemented$) {
            return Sk.misceval.isTrue(ret);
          }
        }
        if ((ret = v[shortcut](w)) !== Sk.builtin.NotImplemented.NotImplemented$) {
          return Sk.misceval.isTrue(ret);
        }
        if (!w_is_subclass) {
          swapped_shortcut = op2shortcut[Sk.misceval.swappedOp_[op]];
          if ((ret = w[swapped_shortcut](v)) !== Sk.builtin.NotImplemented.NotImplemented$) {
            return Sk.misceval.isTrue(ret);
          }
        }
        if (!Sk.__future__.python3) {
          const vcmp = Sk.abstr.lookupSpecial(v, Sk.builtin.str.$cmp);
          if (vcmp) {
            try {
              ret = Sk.misceval.callsimArray(vcmp, [w]);
              if (Sk.builtin.checkNumber(ret)) {
                ret = Sk.builtin.asnum$(ret);
                if (op === "Eq") {
                  return ret === 0;
                } else if (op === "NotEq") {
                  return ret !== 0;
                } else if (op === "Lt") {
                  return ret < 0;
                } else if (op === "Gt") {
                  return ret > 0;
                } else if (op === "LtE") {
                  return ret <= 0;
                } else if (op === "GtE") {
                  return ret >= 0;
                }
              }
              if (ret !== Sk.builtin.NotImplemented.NotImplemented$) {
                throw new Sk.builtin.TypeError("comparison did not return an int");
              }
            } catch (e) {
              throw new Sk.builtin.TypeError("comparison did not return an int");
            }
          }
          const wcmp = Sk.abstr.lookupSpecial(w, Sk.builtin.str.$cmp);
          if (wcmp) {
            try {
              ret = Sk.misceval.callsimArray(wcmp, [v]);
              if (Sk.builtin.checkNumber(ret)) {
                ret = Sk.builtin.asnum$(ret);
                if (op === "Eq") {
                  return ret === 0;
                } else if (op === "NotEq") {
                  return ret !== 0;
                } else if (op === "Lt") {
                  return ret > 0;
                } else if (op === "Gt") {
                  return ret < 0;
                } else if (op === "LtE") {
                  return ret >= 0;
                } else if (op === "GtE") {
                  return ret <= 0;
                }
              }
              if (ret !== Sk.builtin.NotImplemented.NotImplemented$) {
                throw new Sk.builtin.TypeError("comparison did not return an int");
              }
            } catch (e) {
              throw new Sk.builtin.TypeError("comparison did not return an int");
            }
          }
          if (v === Sk.builtin.none.none$ && w === Sk.builtin.none.none$) {
            if (op === "Eq") {
              return v.v === w.v;
            }
            if (op === "NotEq") {
              return v.v !== w.v;
            }
            if (op === "Gt") {
              return v.v > w.v;
            }
            if (op === "GtE") {
              return v.v >= w.v;
            }
            if (op === "Lt") {
              return v.v < w.v;
            }
            if (op === "LtE") {
              return v.v <= w.v;
            }
          }
        }
        if (op === "Eq") {
          return v === w;
        }
        if (op === "NotEq") {
          return v !== w;
        }
        const vname = Sk.abstr.typeName(v);
        const wname = Sk.abstr.typeName(w);
        throw new Sk.builtin.TypeError(
          "'" + Sk.misceval.opSymbols[op] + "' not supported between instances of '" + vname + "' and '" + wname + "'"
        );
      };
      Sk.exportSymbol("Sk.misceval.richCompareBool", Sk.misceval.richCompareBool);
      Sk.misceval.objectRepr = function(obj) {
        Sk.asserts.assert(obj !== void 0, "trying to repr undefined");
        if (obj !== null && obj.$r) {
          return obj.$r().v;
        } else {
          try {
            return new Sk.builtin.str(obj).v;
          } catch (e) {
            if (e instanceof Sk.builtin.TypeError) {
              return "<unknown>";
            } else {
              throw e;
            }
          }
        }
      };
      Sk.exportSymbol("Sk.misceval.objectRepr", Sk.misceval.objectRepr);
      Sk.misceval.opAllowsEquality = function(op) {
        switch (op) {
          case "LtE":
          case "Eq":
          case "GtE":
            return true;
        }
        return false;
      };
      Sk.exportSymbol("Sk.misceval.opAllowsEquality", Sk.misceval.opAllowsEquality);
      Sk.misceval.isTrue = function(x) {
        if (x === true || x === Sk.builtin.bool.true$) {
          return true;
        }
        if (x === false || x === Sk.builtin.bool.false$) {
          return false;
        }
        if (x === null || x === void 0) {
          return false;
        }
        if (x.nb$bool) {
          return x.nb$bool();
        }
        if (x.sq$length) {
          return x.sq$length() !== 0;
        }
        return Boolean(x);
      };
      Sk.exportSymbol("Sk.misceval.isTrue", Sk.misceval.isTrue);
      Sk.misceval.softspace_ = false;
      Sk.misceval.print_ = function(x) {
        var s;
        function isspace(c) {
          return c === "\n" || c === "	" || c === "\r";
        }
        if (Sk.misceval.softspace_) {
          if (x !== "\n") {
            Sk.output(" ");
          }
          Sk.misceval.softspace_ = false;
        }
        s = new Sk.builtin.str(x);
        return Sk.misceval.chain(
          Sk.importModule("sys", false, true),
          function(sys) {
            return Sk.misceval.apply(
              sys["$d"]["stdout"]["write"],
              void 0,
              void 0,
              void 0,
              [sys["$d"]["stdout"], s]
            );
          },
          function() {
            if (s.v.length === 0 || !isspace(s.v[s.v.length - 1]) || s.v[s.v.length - 1] === " ") {
              Sk.misceval.softspace_ = true;
            }
          }
        );
      };
      Sk.exportSymbol("Sk.misceval.print_", Sk.misceval.print_);
      Sk.misceval.loadname = function(name, other) {
        var builtinModuleVersion, bi;
        var v = other[name];
        if (v !== void 0) {
          if (typeof v === "function" && v.sk$object === void 0) {
            return v();
          }
          return v;
        }
        if (other["__builtins__"] !== void 0) {
          builtinModuleVersion = other["__builtins__"].mp$lookup(new Sk.builtin.str(name));
          if (builtinModuleVersion !== void 0) {
            return builtinModuleVersion;
          }
        }
        bi = Sk.builtins[name];
        if (bi !== void 0) {
          return bi;
        }
        throw new Sk.builtin.NameError("name '" + Sk.unfixReserved(name) + "' is not defined");
      };
      Sk.exportSymbol("Sk.misceval.loadname", Sk.misceval.loadname);
      Sk.misceval.call = function(func, kwdict, varargseq, kws, args) {
        args = Array.prototype.slice.call(arguments, 4);
        return Sk.misceval.apply(func, kwdict, varargseq, kws, args);
      };
      Sk.exportSymbol("Sk.misceval.call", Sk.misceval.call);
      Sk.misceval.callAsync = function(suspensionHandlers, func, kwdict, varargseq, kws, args) {
        args = Array.prototype.slice.call(arguments, 5);
        return Sk.misceval.applyAsync(suspensionHandlers, func, kwdict, varargseq, kws, args);
      };
      Sk.exportSymbol("Sk.misceval.callAsync", Sk.misceval.callAsync);
      Sk.misceval.callOrSuspend = function(func, kwdict, varargseq, kws, args) {
        args = Array.prototype.slice.call(arguments, 4);
        return Sk.misceval.applyOrSuspend(func, kwdict, varargseq, kws, args);
      };
      Sk.exportSymbol("Sk.misceval.callOrSuspend", Sk.misceval.callOrSuspend);
      Sk.misceval.callsim = function(func, args) {
        args = Array.prototype.slice.call(arguments, 1);
        return Sk.misceval.apply(func, void 0, void 0, void 0, args);
      };
      Sk.exportSymbol("Sk.misceval.callsim", Sk.misceval.callsim);
      Sk.misceval.callsimArray = function(func, args, kws) {
        args = args || [];
        return Sk.misceval.retryOptionalSuspensionOrThrow(
          Sk.misceval.callsimOrSuspendArray(func, args, kws)
        );
      };
      Sk.exportSymbol("Sk.misceval.callsimArray", Sk.misceval.callsimArray);
      Sk.misceval.callsimAsync = function(suspensionHandlers, func, args) {
        args = Array.prototype.slice.call(arguments, 2);
        return Sk.misceval.applyAsync(suspensionHandlers, func, void 0, void 0, void 0, args);
      };
      Sk.exportSymbol("Sk.misceval.callsimAsync", Sk.misceval.callsimAsync);
      Sk.misceval.callsimOrSuspend = function(func, args) {
        args = Array.prototype.slice.call(arguments, 1);
        return Sk.misceval.applyOrSuspend(func, void 0, void 0, void 0, args);
      };
      Sk.exportSymbol("Sk.misceval.callsimOrSuspend", Sk.misceval.callsimOrSuspend);
      Sk.misceval.callsimOrSuspendArray = function(func, args, kws) {
        args = args || [];
        if (func !== void 0 && func.tp$call) {
          return func.tp$call(args, kws);
        } else {
          return Sk.misceval.applyOrSuspend(func, void 0, void 0, kws, args);
        }
      };
      Sk.exportSymbol("Sk.misceval.callsimOrSuspendArray", Sk.misceval.callsimOrSuspendArray);
      Sk.misceval.apply = function(func, kwdict, varargseq, kws, args) {
        var r = Sk.misceval.applyOrSuspend(func, kwdict, varargseq, kws, args);
        if (r instanceof Sk.misceval.Suspension) {
          return Sk.misceval.retryOptionalSuspensionOrThrow(r);
        } else {
          return r;
        }
      };
      Sk.exportSymbol("Sk.misceval.apply", Sk.misceval.apply);
      Sk.misceval.asyncToPromise = function(suspendablefn, suspHandlers) {
        return new Promise(function(resolve, reject) {
          try {
            var r = suspendablefn();
            (function handleResponse(r2) {
              try {
                var resume = function() {
                  try {
                    handleResponse(r2.resume());
                  } catch (e) {
                    reject(e);
                  }
                };
                var resumeWithData = function resolved(x) {
                  try {
                    r2.data["result"] = x;
                    resume();
                  } catch (e) {
                    reject(e);
                  }
                };
                var resumeWithError = function rejected(e) {
                  try {
                    r2.data["error"] = e;
                    resume();
                  } catch (ex) {
                    reject(ex);
                  }
                };
                while (r2 instanceof Sk.misceval.Suspension) {
                  var handler = suspHandlers && (suspHandlers[r2.data["type"]] || suspHandlers["*"]);
                  if (handler) {
                    var handlerPromise = handler(r2);
                    if (handlerPromise) {
                      handlerPromise.then(handleResponse, reject);
                      return;
                    }
                  }
                  if (r2.data["type"] == "Sk.promise") {
                    r2.data["promise"].then(resumeWithData, resumeWithError);
                    return;
                  } else if (r2.data["type"] == "Sk.yield") {
                    Sk.global["setImmediate"](resume);
                    return;
                  } else if (r2.data["type"] == "Sk.delay") {
                    Sk.global["setImmediate"](resume);
                    return;
                  } else if (r2.optional) {
                    r2 = r2.resume();
                  } else {
                    throw new Sk.builtin.SuspensionError(
                      "Unhandled non-optional suspension of type '" + r2.data["type"] + "'"
                    );
                  }
                }
                resolve(r2);
              } catch (e) {
                reject(e);
              }
            })(r);
          } catch (e) {
            reject(e);
          }
        });
      };
      Sk.exportSymbol("Sk.misceval.asyncToPromise", Sk.misceval.asyncToPromise);
      Sk.misceval.applyAsync = function(suspHandlers, func, kwdict, varargseq, kws, args) {
        return Sk.misceval.asyncToPromise(function() {
          return Sk.misceval.applyOrSuspend(func, kwdict, varargseq, kws, args);
        }, suspHandlers);
      };
      Sk.exportSymbol("Sk.misceval.applyAsync", Sk.misceval.applyAsync);
      Sk.misceval.chain = function(initialValue, chainedFns) {
        var i = 1, value = initialValue, j, fs;
        while (true) {
          if (i == arguments.length) {
            return value;
          }
          if (value && value.$isSuspension) {
            break;
          }
          value = arguments[i](value);
          i++;
        }
        fs = new Array(arguments.length - i);
        for (j = 0; j < arguments.length - i; j++) {
          fs[j] = arguments[i + j];
        }
        j = 0;
        return (function nextStep(r) {
          while (j < fs.length) {
            if (r instanceof Sk.misceval.Suspension) {
              return new Sk.misceval.Suspension(nextStep, r);
            }
            r = fs[j](r);
            j++;
          }
          return r;
        })(value);
      };
      Sk.exportSymbol("Sk.misceval.chain", Sk.misceval.chain);
      Sk.misceval.tryCatch = function(tryFn, catchFn) {
        var r;
        try {
          r = tryFn();
        } catch (e) {
          return catchFn(e);
        }
        if (r instanceof Sk.misceval.Suspension) {
          var susp = new Sk.misceval.Suspension(void 0, r);
          susp.resume = function() {
            return Sk.misceval.tryCatch(r.resume, catchFn);
          };
          return susp;
        } else {
          return r;
        }
      };
      Sk.exportSymbol("Sk.misceval.tryCatch", Sk.misceval.tryCatch);
      Sk.misceval.iterFor = function(iter, forFn, initialValue) {
        var prevValue = initialValue;
        var breakOrIterNext = function(r) {
          prevValue = r;
          return r instanceof Sk.misceval.Break ? r : iter.tp$iternext(true);
        };
        return (function nextStep(i) {
          while (i !== void 0) {
            if (i instanceof Sk.misceval.Suspension) {
              return new Sk.misceval.Suspension(nextStep, i);
            }
            if (i === Sk.misceval.Break || i instanceof Sk.misceval.Break) {
              return i.brValue;
            }
            i = Sk.misceval.chain(forFn(i, prevValue), breakOrIterNext);
          }
          return prevValue;
        })(iter.tp$iternext(true));
      };
      Sk.exportSymbol("Sk.misceval.iterFor", Sk.misceval.iterFor);
      Sk.misceval.iterArray = function(args, forFn, initialValue) {
        Sk.asserts.assert(Array.isArray(args), "iterArgs requires an array");
        let i = 0;
        return Sk.misceval.iterFor({ tp$iternext: () => args[i++] }, forFn, initialValue);
      };
      Sk.misceval.arrayFromIterable = function(iterable, canSuspend) {
        if (iterable === void 0) {
          return [];
        }
        if (iterable.ht$type === void 0 && iterable.sk$asarray !== void 0) {
          return iterable.sk$asarray();
        }
        const L = [];
        const ret = Sk.misceval.chain(
          Sk.misceval.iterFor(Sk.abstr.iter(iterable), (i) => {
            L.push(i);
          }),
          () => L
        );
        return canSuspend ? ret : Sk.misceval.retryOptionalSuspensionOrThrow(ret);
      };
      Sk.misceval.Break = function(brValue) {
        if (!(this instanceof Sk.misceval.Break)) {
          return new Sk.misceval.Break(brValue);
        }
        this.brValue = brValue;
      };
      Sk.exportSymbol("Sk.misceval.Break", Sk.misceval.Break);
      Sk.misceval.applyOrSuspend = function(func, kwdict, varargseq, kws, args) {
        var fcall;
        var it, i;
        if (func == null || func === Sk.builtin.none.none$) {
          throw new Sk.builtin.TypeError("'" + Sk.abstr.typeName(func) + "' object is not callable");
        }
        if (typeof func === "function" && func.tp$call === void 0) {
          func = new Sk.builtin.func(func);
        }
        fcall = func.tp$call;
        if (fcall !== void 0) {
          if (varargseq) {
            for (it = varargseq.tp$iter(), i = it.tp$iternext(); i !== void 0; i = it.tp$iternext()) {
              args.push(i);
            }
          }
          if (kwdict) {
            for (it = Sk.abstr.iter(kwdict), i = it.tp$iternext(); i !== void 0; i = it.tp$iternext()) {
              if (!Sk.builtin.checkString(i)) {
                throw new Sk.builtin.TypeError("Function keywords must be strings");
              }
              kws.push(i.v);
              kws.push(Sk.abstr.objectGetItem(kwdict, i, false));
            }
          }
          return fcall.call(func, args, kws, kwdict);
        }
        fcall = func.__call__;
        if (fcall !== void 0) {
          args.unshift(func);
          return Sk.misceval.apply(fcall, kwdict, varargseq, kws, args);
        }
        throw new Sk.builtin.TypeError("'" + Sk.abstr.typeName(func) + "' object is not callable");
      };
      Sk.exportSymbol("Sk.misceval.applyOrSuspend", Sk.misceval.applyOrSuspend);
      Sk.misceval.promiseToSuspension = function(promise) {
        var suspension = new Sk.misceval.Suspension();
        suspension.resume = function() {
          if (suspension.data["error"]) {
            throw suspension.data["error"];
          }
          return suspension.data["result"];
        };
        suspension.data = {
          type: "Sk.promise",
          promise
        };
        return suspension;
      };
      Sk.exportSymbol("Sk.misceval.promiseToSuspension", Sk.misceval.promiseToSuspension);
      Sk.misceval.buildClass = function(globals, func, name, bases, cell) {
        var klass;
        var meta = Sk.builtin.type;
        var l_cell = cell === void 0 ? {} : cell;
        var locals = {};
        func(globals, locals, l_cell);
        if (globals["__name__"]) {
          locals.__module__ = globals["__name__"];
        }
        var _name = new Sk.builtin.str(name);
        var _bases = new Sk.builtin.tuple(bases);
        var _locals = [];
        var key;
        for (key in locals) {
          if (!locals.hasOwnProperty(key)) {
            continue;
          }
          _locals.push(new Sk.builtin.str(key));
          _locals.push(locals[key]);
        }
        _locals = new Sk.builtin.dict(_locals);
        klass = Sk.misceval.callsimArray(meta, [_name, _bases, _locals]);
        return klass;
      };
      Sk.exportSymbol("Sk.misceval.buildClass", Sk.misceval.buildClass);
      Sk.misceval.handleTraceback = function(err, currLineNo, currColNo, currSource, filename, scopeName) {
        if (err instanceof Sk.builtin.TimeoutError) {
          Sk.execStart = Date.now();
          Sk.execPaused = 0;
        }
        if (!(err instanceof Sk.builtin.BaseException)) {
          err = new Sk.builtin.ExternalError(err);
        }
        Sk.err = err;
        err.traceback.push({
          lineno: currLineNo,
          colno: currColNo,
          source: currSource,
          filename,
          scope: scopeName
        });
        return err;
      };
      Sk.exportSymbol("Sk.misceval.handleTraceback", Sk.misceval.handleTraceback);
      Sk.misceval.startTimer = function() {
        if (typeof Sk.execStart === "undefined") {
          Sk.execStart = Date.now();
          Sk.execPaused = 0;
        }
      };
      Sk.exportSymbol("Sk.misceval.startTimer", Sk.misceval.startTimer);
      Sk.misceval.resetYield = function() {
        if (typeof Sk.lastYield === "undefined") {
          Sk.lastYield = Date.now();
        }
      };
      Sk.exportSymbol("Sk.misceval.resetYield", Sk.misceval.resetYield);
      Sk.misceval.pauseTimer = function() {
        Sk.execPaused = Date.now();
      };
      Sk.exportSymbol("Sk.misceval.pauseTimer", Sk.misceval.pauseTimer);
      Sk.misceval.unpauseTimer = function() {
        Sk.execPaused = Date.now() - Sk.execPaused;
        Sk.execPausedAmount += Sk.execPaused;
      };
      Sk.exportSymbol("Sk.misceval.unpauseTimer", Sk.misceval.unpauseTimer);
      Sk.misceval.timeoutCheck = function(d) {
        if (Sk.execLimit !== null && d - Sk.execStart - Sk.execPausedAmount > Sk.execLimit) {
          let shouldContinue = null;
          if (Sk.timeoutHandler) {
            Sk.misceval.pauseTimer();
            shouldContinue = Sk.timeoutHandler(
              d - Sk.execStart - Sk.execPausedAmount,
              Sk.execLimit
            );
            Sk.misceval.unpauseTimer();
          }
          if (!shouldContinue) {
            throw new Sk.builtin.TimeoutError(Sk.timeoutMsg());
          }
        }
      };
      Sk.exportSymbol("Sk.misceval.timeoutCheck", Sk.misceval.timeoutCheck);
      Sk.misceval.injectSusp = function($child, $blk, $loc, $gbl, $exc, $err, $postfinally, $filename, $lineno, $colno, $source, $tmps) {
        var susp = new Sk.misceval.Suspension();
        susp.child = $child;
        susp.data = susp.child.data;
        susp.$blk = $blk;
        susp.$loc = $loc;
        susp.$gbl = $gbl;
        susp.$exc = $exc;
        susp.$err = $err;
        susp.$postfinally = $postfinally;
        susp.$filename = $filename;
        susp.$lineno = $lineno;
        susp.$colno = $colno;
        susp.source = $source;
        susp.optional = susp.child.optional;
        susp.$tmps = $tmps;
        return susp;
      };
      Sk.exportSymbol("Sk.misceval.injectSusp", Sk.misceval.injectSusp);
      Sk.misceval.errorUL = function(mangled) {
        throw new Sk.builtin.UnboundLocalError(
          "local variable '" + mangled + "' referenced before assignment"
        );
      };
      Sk.exportSymbol("Sk.misceval.errorUL", Sk.misceval.errorUL);
      Sk.misceval.loadattr = function(val, mname) {
        const $ret = val.tp$getattr(mname, true);
        if ($ret === void 0) {
          const error_name = val.sk$type ? "type object '" + val.prototype.tp$name + "'" : "'" + Sk.abstr.typeName(val) + "' object";
          throw new Sk.builtin.AttributeError(
            error_name + " has no attribute '" + mname.$jsstr() + "'"
          );
        }
        return $ret;
      };
      Sk.exportSymbol("Sk.misceval.loadattr", Sk.misceval.loadattr);
    }
  });

  // src/simple_iterators.js
  var require_simple_iterators = __commonJS({
    "src/simple_iterators.js"() {
      Sk.builtin.callable_iter_ = Sk.abstr.buildIteratorClass("callable_iterator", {
        constructor: function callable_iter(callable, sentinel) {
          if (!Sk.builtin.checkCallable(callable)) {
            throw new Sk.builtin.TypeError("iter(v, w): v must be callable");
          }
          this.$callable = callable;
          this.$sentinel = sentinel;
          this.$flag = false;
        },
        iternext(canSuspend) {
          let ret;
          if (this.$flag === true) {
            return void 0;
          }
          if (canSuspend) {
            ret = Sk.misceval.callsimOrSuspendArray(this.$callable, []);
            return Sk.misceval.chain(ret, (r) => {
              if (Sk.misceval.richCompareBool(r, this.$sentinel, "Eq", true)) {
                this.$flag = true;
                return void 0;
              } else {
                return r;
              }
            });
          } else {
            ret = Sk.misceval.callsimArray(this.$callable, []);
            if (Sk.misceval.richCompareBool(ret, this.$sentinel, "Eq", false)) {
              this.$flag = true;
              return void 0;
            } else {
              return ret;
            }
          }
        },
        flags: { sk$unacceptableBase: true }
      });
      Sk.builtin.seq_iter_ = Sk.abstr.buildIteratorClass("iterator", {
        constructor: function seq_iter(seq) {
          this.$index = 0;
          this.$seq = seq;
        },
        iternext(canSuspend) {
          let ret;
          ret = Sk.misceval.tryCatch(
            () => {
              return this.$seq.mp$subscript(new Sk.builtin.int_(this.$index++), canSuspend);
            },
            (e) => {
              if (e instanceof Sk.builtin.IndexError || e instanceof Sk.builtin.StopIteration) {
                this.gi$ret = e.$value || Sk.builtin.none.none$;
                return void 0;
              } else {
                throw e;
              }
            }
          );
          return canSuspend ? ret : Sk.misceval.retryOptionalSuspensionOrThrow(ret);
        },
        methods: {
          __length_hint__: {
            $flags: { NoArgs: true },
            $meth() {
              if (this.$seq.sq$length) {
                return this.$seq.sq$length() - this.$index;
              } else {
                throw new Sk.builtin.NotImplementedError(
                  "len is not implemented for " + Sk.abstr.typeName(this.$seq)
                );
              }
            }
          }
        },
        flags: { sk$unacceptableBase: true }
      });
      Sk.exportSymbol("Sk.builtin.callable_iter_", Sk.builtin.callable_iter_);
    }
  });

  // src/list.js
  var require_list = __commonJS({
    "src/list.js"() {
      Sk.builtin.list = Sk.abstr.buildNativeClass("list", {
        constructor: function list(L) {
          if (L === void 0) {
            L = [];
          } else if (!Array.isArray(L)) {
            L = Sk.misceval.arrayFromIterable(L);
          }
          Sk.asserts.assert(
            this instanceof Sk.builtin.list,
            "bad call to list, use 'new' with an Array of python objects"
          );
          this.v = L;
          this.in$repr = false;
        },
        slots: (
          /** @lends {Sk.builtin.list.prototype}*/
          {
            tp$getattr: Sk.generic.getAttr,
            tp$as_sequence_or_mapping: true,
            tp$hash: Sk.builtin.none.none$,
            tp$doc: "Built-in mutable sequence.\n\nIf no argument is given, the constructor creates a new empty list.\nThe argument must be an iterable if specified.",
            tp$new: Sk.generic.new,
            tp$init(args, kwargs) {
              Sk.abstr.checkNoKwargs("list", kwargs);
              Sk.abstr.checkArgsLen("list", args, 0, 1);
              return Sk.misceval.chain(Sk.misceval.arrayFromIterable(args[0], true), (L) => {
                this.v = L;
              });
            },
            $r() {
              if (this.in$repr) {
                return new Sk.builtin.str("[...]");
              }
              this.in$repr = true;
              const ret = this.v.map((x) => Sk.misceval.objectRepr(x));
              this.in$repr = false;
              return new Sk.builtin.str("[" + ret.join(", ") + "]");
            },
            tp$richcompare: Sk.generic.seqCompare,
            tp$iter() {
              return new list_iter_(this);
            },
            // sequence and mapping slots
            sq$length() {
              return this.v.length;
            },
            sq$concat(other) {
              if (!(other instanceof Sk.builtin.list)) {
                throw new Sk.builtin.TypeError("can only concatenate list to list");
              }
              return new Sk.builtin.list(this.v.concat(other.v));
            },
            sq$contains(item) {
              for (let it = this.tp$iter(), i = it.tp$iternext(); i !== void 0; i = it.tp$iternext()) {
                if (i === item || Sk.misceval.richCompareBool(i, item, "Eq")) {
                  return true;
                }
              }
              return false;
            },
            sq$repeat(n) {
              if (!Sk.misceval.isIndex(n)) {
                throw new Sk.builtin.TypeError(
                  "can't multiply sequence by non-int of type '" + Sk.abstr.typeName(n) + "'"
                );
              }
              n = Sk.misceval.asIndexSized(n, Sk.builtin.OverflowError);
              if (n * this.v.length > Number.MAX_SAFE_INTEGER) {
                throw new Sk.builtin.OverflowError();
              }
              const ret = [];
              for (let i = 0; i < n; i++) {
                for (let j = 0; j < this.v.length; j++) {
                  ret.push(this.v[j]);
                }
              }
              return new Sk.builtin.list(ret);
            },
            mp$subscript(index) {
              if (Sk.misceval.isIndex(index)) {
                let i = Sk.misceval.asIndexSized(index, Sk.builtin.IndexError);
                i = this.list$inRange(i, "list index out of range");
                return this.v[i];
              } else if (index instanceof Sk.builtin.slice) {
                const ret = [];
                index.sssiter$(this.v.length, (i) => {
                  ret.push(this.v[i]);
                });
                return new Sk.builtin.list(ret);
              }
              throw new Sk.builtin.TypeError(
                "list indices must be integers or slices, not " + Sk.abstr.typeName(index)
              );
            },
            mp$ass_subscript(index, value) {
              if (value === void 0) {
                this.del$subscript(index);
              } else {
                this.ass$subscript(index, value);
              }
            },
            sq$inplace_concat(other) {
              if (other === this) {
                this.v.push(...this.v);
                return this;
              }
              return Sk.misceval.chain(
                Sk.misceval.iterFor(Sk.abstr.iter(other), (i) => {
                  this.v.push(i);
                }),
                () => this
              );
            },
            sq$inplace_repeat(n) {
              if (!Sk.misceval.isIndex(n)) {
                throw new Sk.builtin.TypeError(
                  "can't multiply sequence by non-int of type '" + Sk.abstr.typeName(n) + "'"
                );
              }
              n = Sk.misceval.asIndexSized(n, Sk.builtin.OverflowError);
              const len = this.v.length;
              if (n <= 0) {
                this.v.length = 0;
              } else if (n * len > Number.MAX_SAFE_INTEGER) {
                throw new Sk.builtin.OverflowError();
              }
              for (let i = 1; i < n; i++) {
                for (let j = 0; j < len; j++) {
                  this.v.push(this.v[j]);
                }
              }
              return this;
            }
          }
        ),
        methods: (
          /** @lends {Sk.builtin.list.prototype}*/
          {
            __reversed__: {
              $meth() {
                return new reverselist_iter_(this);
              },
              $flags: { NoArgs: true },
              $textsig: "($self, /)",
              $doc: "Return a reverse iterator over the list."
            },
            clear: {
              $meth() {
                this.v.length = 0;
                return Sk.builtin.none.none$;
              },
              $flags: { NoArgs: true },
              $textsig: "($self, /)",
              $doc: "Remove all items from list."
            },
            copy: {
              $meth() {
                return new Sk.builtin.list(this.v.slice(0));
              },
              $flags: { NoArgs: true },
              $textsig: "($self, /)",
              $doc: "Return a shallow copy of the list."
            },
            append: {
              $meth(item) {
                this.v.push(item);
                return Sk.builtin.none.none$;
              },
              $flags: { OneArg: true },
              $textsig: "($self, object, /)",
              $doc: "Append object to the end of the list."
            },
            insert: {
              $meth(i, x) {
                i = Sk.misceval.asIndexSized(i, Sk.builtin.OverflowError);
                const { start } = Sk.builtin.slice.startEnd$wrt(this, i);
                this.v.splice(start, 0, x);
                return Sk.builtin.none.none$;
              },
              $flags: { MinArgs: 2, MaxArgs: 2 },
              $textsig: "($self, index, object, /)",
              $doc: "Insert object before index."
            },
            extend: {
              $meth(iterable) {
                if (iterable === this) {
                  this.v = this.v.concat(this.v);
                  return Sk.builtin.none.none$;
                }
                return Sk.misceval.chain(
                  // TODONEW: Check for performance issue, optimize with concat
                  Sk.misceval.iterFor(Sk.abstr.iter(iterable), (i) => {
                    this.v.push(i);
                  }),
                  () => Sk.builtin.none.none$
                );
              },
              $flags: { OneArg: true },
              $textsig: "($self, iterable, /)",
              $doc: "Extend list by appending elements from the iterable."
            },
            pop: {
              $meth(i) {
                if (i === void 0) {
                  i = this.v.length - 1;
                } else {
                  i = Sk.misceval.asIndexSized(i, Sk.builtin.OverflowError);
                }
                i = this.list$inRange(i, "pop index out of range");
                const res = this.v[i];
                this.v.splice(i, 1);
                return res;
              },
              $flags: { MinArgs: 0, MaxArgs: 1 },
              $textsig: "($self, index=-1, /)",
              $doc: "Remove and return item at index (default last).\n\nRaises IndexError if list is empty or index is out of range."
            },
            remove: {
              $meth(item) {
                const i = this.list$indexOf(item);
                if (i === -1) {
                  throw new Sk.builtin.ValueError("list.remove(x): x not in list");
                }
                this.v.splice(i, 1);
                return Sk.builtin.none.none$;
              },
              $flags: { OneArg: true },
              $textsig: "($self, value, /)",
              $doc: "Remove first occurrence of value.\n\nRaises ValueError if the value is not present."
            },
            sort: {
              $meth(args, kwargs) {
                if (args.length) {
                  throw new Sk.builtin.TypeError("sort() takes no positional arguments");
                }
                const [key, reverse] = Sk.abstr.copyKeywordsToNamedArgs(
                  "sort",
                  ["key", "reverse"],
                  args,
                  kwargs,
                  [Sk.builtin.none.none$, Sk.builtin.bool.false$]
                );
                return this.list$sort(void 0, key, reverse);
              },
              $flags: { FastCall: true },
              $textsig: "($self, /, *, key=None, reverse=False)",
              $doc: "Stable sort *IN PLACE*."
            },
            index: {
              $meth(value, start, stop) {
                if (start !== void 0 && !Sk.misceval.isIndex(start) || stop !== void 0 && !Sk.misceval.isIndex(stop)) {
                  throw new Sk.builtin.TypeError(
                    "slice indices must be integers or have an __index__ method"
                  );
                }
                const i = this.list$indexOf(value, start, stop);
                if (i === -1) {
                  throw new Sk.builtin.ValueError(
                    Sk.misceval.objectRepr(value) + " is not in list"
                  );
                }
                return new Sk.builtin.int_(i);
              },
              $flags: { MinArgs: 1, MaxArgs: 3 },
              $textsig: "($self, value, start=0, stop=sys.maxsize, /)",
              $doc: "Return first index of value.\n\nRaises ValueError if the value is not present."
            },
            count: {
              $meth(item) {
                let count = 0;
                const len = this.v.length;
                for (let i = 0; i < len; i++) {
                  if (this.v[i] === item || Sk.misceval.richCompareBool(this.v[i], item, "Eq")) {
                    count += 1;
                  }
                }
                return new Sk.builtin.int_(count);
              },
              $flags: { OneArg: true },
              $textsig: "($self, value, /)",
              $doc: "Return number of occurrences of value."
            },
            reverse: {
              $meth() {
                this.list$reverse();
                return Sk.builtin.none.none$;
              },
              $flags: { NoArgs: true },
              $textsig: "($self, /)",
              $doc: "Reverse *IN PLACE*."
            }
          }
        ),
        classmethods: Sk.generic.classGetItem,
        proto: (
          /** @lends {Sk.builtin.list.prototype}*/
          {
            sk$asarray() {
              return this.v.slice(0);
            },
            list$sort,
            list$inRange(i, msg) {
              if (i < 0) {
                i += this.v.length;
              }
              if (i >= 0 && i < this.v.length) {
                return i;
              }
              throw new Sk.builtin.IndexError(msg);
            },
            list$indexOf(item, start, end) {
              ({ start, end } = Sk.builtin.slice.startEnd$wrt(this, start, end));
              for (let i = start; i < end && i < this.v.length; i++) {
                if (this.v[i] === item || Sk.misceval.richCompareBool(this.v[i], item, "Eq")) {
                  return i;
                }
              }
              return -1;
            },
            list$reverse() {
              this.v.reverse();
            },
            ass$subscript(index, value) {
              if (Sk.misceval.isIndex(index)) {
                this.ass$index(index, value);
              } else if (index instanceof Sk.builtin.slice) {
                const { start, stop, step } = index.slice$indices(this.v.length);
                if (step === 1) {
                  this.ass$slice(start, stop, value);
                } else {
                  this.ass$ext_slice(index, value);
                }
              } else {
                throw new Sk.builtin.TypeError(
                  "list indices must be integers or slices, not " + Sk.abstr.typeName(index)
                );
              }
            },
            ass$index(index, value) {
              let i = Sk.misceval.asIndexSized(index, Sk.builtin.IndexError);
              i = this.list$inRange(i, "list assignment index out of range");
              this.v[i] = value;
            },
            ass$slice(start, stop, iterable) {
              if (!Sk.builtin.checkIterable(iterable)) {
                throw new Sk.builtin.TypeError("can only assign an iterable");
              }
              const vals = Sk.misceval.arrayFromIterable(iterable);
              this.v.splice(start, stop - start, ...vals);
            },
            ass$ext_slice(slice, iterable) {
              const indices = [];
              slice.sssiter$(this.v.length, (i) => {
                indices.push(i);
              });
              if (!Sk.builtin.checkIterable(iterable)) {
                throw new Sk.builtin.TypeError("must assign iterable to extended slice");
              }
              const vals = Sk.misceval.arrayFromIterable(iterable);
              if (indices.length !== vals.length) {
                throw new Sk.builtin.ValueError(
                  "attempt to assign sequence of size " + vals.length + " to extended slice of size " + indices.length
                );
              }
              for (let i = 0; i < indices.length; i++) {
                this.v.splice(indices[i], 1, vals[i]);
              }
            },
            del$subscript(index) {
              if (Sk.misceval.isIndex(index)) {
                this.del$index(index);
              } else if (index instanceof Sk.builtin.slice) {
                const { start, stop, step } = index.slice$indices(this.v.length);
                if (step === 1) {
                  this.del$slice(start, stop);
                } else {
                  this.del$ext_slice(index, step > 0 ? 1 : 0);
                }
              } else {
                throw new Sk.builtin.TypeError(
                  "list indices must be integers, not " + Sk.abstr.typeName(index)
                );
              }
            },
            del$index(index) {
              let i = Sk.misceval.asIndexSized(index, Sk.builtin.IndexError);
              i = this.list$inRange(i, "list assignment index out of range");
              this.v.splice(i, 1);
            },
            del$slice(start, stop) {
              this.v.splice(start, stop - start);
            },
            del$ext_slice(slice, offdir) {
              let dec = 0;
              slice.sssiter$(this.v.length, (i) => {
                this.v.splice(i - dec, 1);
                dec += offdir;
              });
            }
          }
        )
      });
      Sk.exportSymbol("Sk.builtin.list", Sk.builtin.list);
      function list$sort(cmp, key, reverse) {
        const has_key = key != null && key !== Sk.builtin.none.none$;
        const has_cmp = cmp != null && cmp !== Sk.builtin.none.none$;
        let rev, item;
        if (reverse === void 0) {
          rev = false;
        } else if (!Sk.builtin.checkInt(reverse)) {
          throw new Sk.builtin.TypeError("an integer is required");
        } else {
          rev = Sk.misceval.isTrue(reverse);
        }
        const timsort = new Sk.builtin.timSort(this);
        this.v = [];
        const zero = new Sk.builtin.int_(0);
        if (has_key) {
          if (has_cmp) {
            timsort.lt = function(a, b) {
              var res = Sk.misceval.callsimArray(cmp, [a[0], b[0]]);
              return Sk.misceval.richCompareBool(res, zero, "Lt");
            };
          } else {
            timsort.lt = function(a, b) {
              return Sk.misceval.richCompareBool(a[0], b[0], "Lt");
            };
          }
          for (let i = 0; i < timsort.listlength; i++) {
            item = timsort.list.v[i];
            const keyvalue = Sk.misceval.callsimArray(key, [item]);
            timsort.list.v[i] = [keyvalue, item];
          }
        } else if (has_cmp) {
          timsort.lt = function(a, b) {
            var res = Sk.misceval.callsimArray(cmp, [a, b]);
            return Sk.misceval.richCompareBool(res, zero, "Lt");
          };
        }
        if (rev) {
          timsort.list.list$reverse();
        }
        timsort.sort();
        if (rev) {
          timsort.list.list$reverse();
        }
        if (has_key) {
          for (let j = 0; j < timsort.listlength; j++) {
            item = timsort.list.v[j][1];
            timsort.list.v[j] = item;
          }
        }
        const mucked = this.sq$length() > 0;
        this.v = timsort.list.v;
        if (mucked) {
          throw new Sk.builtin.ValueError("list modified during sort");
        }
        return Sk.builtin.none.none$;
      }
      Sk.builtin.list.py2$methods = {
        sort: {
          $name: "sort",
          $meth(args, kwargs) {
            const [cmp, key, reverse] = Sk.abstr.copyKeywordsToNamedArgs(
              "sort",
              ["cmp", "key", "reverse"],
              args,
              kwargs,
              [Sk.builtin.none.none$, Sk.builtin.none.none$, Sk.builtin.bool.false$]
            );
            return this.list$sort(cmp, key, reverse);
          },
          $flags: {
            FastCall: true
            // named args might be better here but one of the args is pyFalse
            // and bool class does not exist yet. So use FastCall instead.
          },
          $textsig: "($self, cmp=None, key=None, reverse=False)",
          $doc: "Stable sort *IN PLACE*."
        }
      };
      var list_iter_ = Sk.abstr.buildIteratorClass("list_iterator", {
        constructor: function list_iter_2(lst) {
          this.$index = 0;
          this.$seq = lst.v;
        },
        iternext: Sk.generic.iterNextWithArray,
        methods: {
          __length_hint__: Sk.generic.iterLengthHintWithArrayMethodDef
        },
        flags: { sk$unacceptableBase: true }
      });
      var reverselist_iter_ = Sk.abstr.buildIteratorClass("list_reverseiterator", {
        constructor: function reverselist_iter_2(lst) {
          this.$index = lst.v.length - 1;
          this.$seq = lst.v;
        },
        iternext() {
          const item = this.$seq[this.$index--];
          if (item === void 0) {
            this.tp$iternext = () => void 0;
            return void 0;
          }
          return item;
        },
        methods: {
          __length_hint__: Sk.generic.iterReverseLengthHintMethodDef
        },
        flags: { sk$unacceptableBase: true }
      });
    }
  });

  // node_modules/fastestsmallesttextencoderdecoder/EncoderDecoderTogether.min.js
  var require_EncoderDecoderTogether_min = __commonJS({
    "node_modules/fastestsmallesttextencoderdecoder/EncoderDecoderTogether.min.js"(exports) {
      "use strict";
      (function(r) {
        function x() {
        }
        function y() {
        }
        var z = String.fromCharCode, v = {}.toString, A = v.call(r.SharedArrayBuffer), B = v(), q = r.Uint8Array, t = q || Array, w = q ? ArrayBuffer : t, C = w.isView || function(g) {
          return g && "length" in g;
        }, D = v.call(w.prototype);
        w = y.prototype;
        var E = r.TextEncoder, a = new (q ? Uint16Array : t)(32);
        x.prototype.decode = function(g) {
          if (!C(g)) {
            var l = v.call(g);
            if (l !== D && l !== A && l !== B) throw TypeError("Failed to execute 'decode' on 'TextDecoder': The provided value is not of type '(ArrayBuffer or ArrayBufferView)'");
            g = q ? new t(g) : g || [];
          }
          for (var f = l = "", b = 0, c = g.length | 0, u = c - 32 | 0, e, d, h = 0, p = 0, m, k = 0, n = -1; b < c; ) {
            for (e = b <= u ? 32 : c - b | 0; k < e; b = b + 1 | 0, k = k + 1 | 0) {
              d = g[b] & 255;
              switch (d >> 4) {
                case 15:
                  m = g[b = b + 1 | 0] & 255;
                  if (2 !== m >> 6 || 247 < d) {
                    b = b - 1 | 0;
                    break;
                  }
                  h = (d & 7) << 6 | m & 63;
                  p = 5;
                  d = 256;
                case 14:
                  m = g[b = b + 1 | 0] & 255, h <<= 6, h |= (d & 15) << 6 | m & 63, p = 2 === m >> 6 ? p + 4 | 0 : 24, d = d + 256 & 768;
                case 13:
                case 12:
                  m = g[b = b + 1 | 0] & 255, h <<= 6, h |= (d & 31) << 6 | m & 63, p = p + 7 | 0, b < c && 2 === m >> 6 && h >> p && 1114112 > h ? (d = h, h = h - 65536 | 0, 0 <= h && (n = (h >> 10) + 55296 | 0, d = (h & 1023) + 56320 | 0, 31 > k ? (a[k] = n, k = k + 1 | 0, n = -1) : (m = n, n = d, d = m))) : (d >>= 8, b = b - d - 1 | 0, d = 65533), h = p = 0, e = b <= u ? 32 : c - b | 0;
                default:
                  a[k] = d;
                  continue;
                case 11:
                case 10:
                case 9:
                case 8:
              }
              a[k] = 65533;
            }
            f += z(a[0], a[1], a[2], a[3], a[4], a[5], a[6], a[7], a[8], a[9], a[10], a[11], a[12], a[13], a[14], a[15], a[16], a[17], a[18], a[19], a[20], a[21], a[22], a[23], a[24], a[25], a[26], a[27], a[28], a[29], a[30], a[31]);
            32 > k && (f = f.slice(0, k - 32 | 0));
            if (b < c) {
              if (a[0] = n, k = ~n >>> 31, n = -1, f.length < l.length) continue;
            } else -1 !== n && (f += z(n));
            l += f;
            f = "";
          }
          return l;
        };
        w.encode = function(g) {
          g = void 0 === g ? "" : "" + g;
          var l = g.length | 0, f = new t((l << 1) + 8 | 0), b, c = 0, u = !q;
          for (b = 0; b < l; b = b + 1 | 0, c = c + 1 | 0) {
            var e = g.charCodeAt(b) | 0;
            if (127 >= e) f[c] = e;
            else {
              if (2047 >= e) f[c] = 192 | e >> 6;
              else {
                a: {
                  if (55296 <= e) if (56319 >= e) {
                    var d = g.charCodeAt(b = b + 1 | 0) | 0;
                    if (56320 <= d && 57343 >= d) {
                      e = (e << 10) + d - 56613888 | 0;
                      if (65535 < e) {
                        f[c] = 240 | e >> 18;
                        f[c = c + 1 | 0] = 128 | e >> 12 & 63;
                        f[c = c + 1 | 0] = 128 | e >> 6 & 63;
                        f[c = c + 1 | 0] = 128 | e & 63;
                        continue;
                      }
                      break a;
                    }
                    e = 65533;
                  } else 57343 >= e && (e = 65533);
                  !u && b << 1 < c && b << 1 < (c - 7 | 0) && (u = true, d = new t(3 * l), d.set(f), f = d);
                }
                f[c] = 224 | e >> 12;
                f[c = c + 1 | 0] = 128 | e >> 6 & 63;
              }
              f[c = c + 1 | 0] = 128 | e & 63;
            }
          }
          return q ? f.subarray(0, c) : f.slice(0, c);
        };
        E || (r.TextDecoder = x, r.TextEncoder = y);
      })("undefined" == typeof global ? "undefined" == typeof self ? exports : self : global);
    }
  });

  // src/bytes.js
  var require_bytes = __commonJS({
    "src/bytes.js"() {
      require_EncoderDecoderTogether_min();
      var supportedEncodings = {
        utf: "utf-8",
        utf8: "utf-8",
        utf_8: "utf-8",
        ascii: "ascii",
        latin_1: "latin1",
        latin1: "latin1"
      };
      var space_reg = /\s+/g;
      var underscore_hyphen_reg = /[_-]+/g;
      function normalizeEncoding(encoding) {
        const normalized = encoding.replace(space_reg, "").replace(underscore_hyphen_reg, "_").toLowerCase();
        const supported = supportedEncodings[normalized];
        if (supported === void 0) {
          return encoding;
        } else {
          return supported;
        }
      }
      var Encoder = new TextEncoder();
      var Decoder = new TextDecoder();
      var Latin1Decoder = new TextDecoder("latin1");
      var Latin1Encoder = new TextEncoder("latin1");
      Sk.builtin.bytes = Sk.abstr.buildNativeClass("bytes", {
        constructor: function bytes(source) {
          if (!(this instanceof Sk.builtin.bytes)) {
            throw new TypeError("bytes is a constructor use 'new'");
          }
          if (source === void 0) {
            this.v = new Uint8Array();
          } else if (source instanceof Uint8Array) {
            this.v = source;
          } else if (source instanceof Uint8ClampedArray) {
            this.v = new Uint8Array(source);
          } else if (Array.isArray(source)) {
            Sk.asserts.assert(
              source.every((x) => x >= 0 && x <= 255),
              "bad internal call to bytes with array"
            );
            this.v = new Uint8Array(source);
          } else if (typeof source === "string") {
            let cc;
            const uint8 = new Uint8Array(source.length);
            const len = source.length;
            for (let i = 0; i < len; i++) {
              cc = source.charCodeAt(i);
              if (cc > 255) {
                throw new Sk.builtin.UnicodeDecodeError(
                  "invalid string at index " + i + " (possibly contains a unicode character)"
                );
              }
              uint8[i] = cc;
            }
            this.v = uint8;
          } else if (typeof source === "number") {
            this.v = new Uint8Array(source);
          } else {
            throw new TypeError(
              `bad internal argument to bytes constructor (got '${typeof source}': ${source})`
            );
          }
        },
        slots: (
          /**@lends {Sk.builtin.bytes.prototype} */
          {
            tp$getattr: Sk.generic.getAttr,
            tp$doc: "bytes(iterable_of_ints) -> bytes\nbytes(string, encoding[, errors]) -> bytes\nbytes(bytes_or_buffer) -> immutable copy of bytes_or_buffer\nbytes(int) -> bytes object of size given by the parameter initialized with null bytes\nbytes() -> empty bytes object\n\nConstruct an immutable array of bytes from:\n  - an iterable yielding integers in range(256)\n  - a text string encoded using the specified encoding\n  - any object implementing the buffer API.\n  - an integer",
            tp$new(args, kwargs) {
              if (this !== Sk.builtin.bytes.prototype) {
                return this.$subtype_new(args, kwargs);
              }
              kwargs = kwargs || [];
              let source, pySource, dunderBytes, encoding, errors;
              if (args.length <= 1 && +kwargs.length === 0) {
                pySource = args[0];
              } else {
                [pySource, encoding, errors] = Sk.abstr.copyKeywordsToNamedArgs(
                  "bytes",
                  [null, "pySource", "errors"],
                  args,
                  kwargs
                );
                ({ encoding, errors } = checkGetEncodingErrors("bytes", encoding, errors));
                if (!Sk.builtin.checkString(pySource)) {
                  throw new Sk.builtin.TypeError("encoding or errors without a string argument");
                }
                return strEncode(pySource, encoding, errors);
              }
              if (pySource === void 0) {
                return new Sk.builtin.bytes();
              } else if ((dunderBytes = Sk.abstr.lookupSpecial(pySource, Sk.builtin.str.$bytes)) !== void 0) {
                const ret = Sk.misceval.callsimOrSuspendArray(dunderBytes, []);
                return Sk.misceval.chain(ret, (bytesSource) => {
                  if (!Sk.builtin.checkBytes(bytesSource)) {
                    throw new Sk.builtin.TypeError(
                      "__bytes__ returned non-bytes (type " + Sk.abstr.typeName(bytesSource) + ")"
                    );
                  }
                  return bytesSource;
                });
              } else if (Sk.misceval.isIndex(pySource)) {
                source = Sk.misceval.asIndexSized(pySource, Sk.builtin.OverflowError);
                if (source < 0) {
                  throw new Sk.builtin.ValueError("negative count");
                }
                return new Sk.builtin.bytes(source);
              } else if (Sk.builtin.checkBytes(pySource)) {
                return new Sk.builtin.bytes(pySource.v);
              } else if (Sk.builtin.checkString(pySource)) {
                throw new Sk.builtin.TypeError("string argument without an encoding");
              } else if (Sk.builtin.checkIterable(pySource)) {
                let source2 = [];
                let r = Sk.misceval.iterFor(Sk.abstr.iter(pySource), (byte) => {
                  const n = Sk.misceval.asIndexSized(byte);
                  if (n < 0 || n > 255) {
                    throw new Sk.builtin.ValueError("bytes must be in range(0, 256)");
                  }
                  source2.push(n);
                });
                return Sk.misceval.chain(r, () => new Sk.builtin.bytes(source2));
              }
              throw new Sk.builtin.TypeError(
                "cannot convert '" + Sk.abstr.typeName(pySource) + "' object into bytes"
              );
            },
            $r() {
              return bytesToString(this);
            },
            tp$str() {
              return this.$r();
            },
            tp$iter() {
              return new bytes_iter_(this);
            },
            tp$richcompare(other, op) {
              if (this === other && Sk.misceval.opAllowsEquality(op)) {
                return true;
              } else if (!(other instanceof Sk.builtin.bytes)) {
                return Sk.builtin.NotImplemented.NotImplemented$;
              }
              const v = this.v;
              const w = other.v;
              if (v.length !== w.length && (op === "Eq" || op === "NotEq")) {
                return op !== "Eq";
              }
              let i;
              const min_len = Math.min(v.length, w.length);
              for (i = 0; i < min_len; i++) {
                if (v[i] !== w[i]) {
                  break;
                }
              }
              switch (op) {
                case "Lt":
                  return i === min_len && v.length < w.length || v[i] < w[i];
                case "LtE":
                  return i === min_len && v.length <= w.length || v[i] <= w[i];
                case "Eq":
                  return i === min_len;
                case "NotEq":
                  return i < min_len;
                case "Gt":
                  return i === min_len && v.length > w.length || v[i] > w[i];
                case "GtE":
                  return i === min_len && v.length >= w.length || v[i] >= w[i];
              }
            },
            tp$hash() {
              return new Sk.builtin.str(this.$jsstr()).tp$hash();
            },
            tp$as_sequence_or_mapping: true,
            mp$subscript(index) {
              if (Sk.misceval.isIndex(index)) {
                let i = Sk.misceval.asIndexSized(index, Sk.builtin.IndexError);
                if (i !== void 0) {
                  if (i < 0) {
                    i = this.v.length + i;
                  }
                  if (i < 0 || i >= this.v.length) {
                    throw new Sk.builtin.IndexError("index out of range");
                  }
                  return new Sk.builtin.int_(this.v[i]);
                }
              } else if (index instanceof Sk.builtin.slice) {
                const ret = [];
                index.sssiter$(this.v.length, (i) => {
                  ret.push(this.v[i]);
                });
                return new Sk.builtin.bytes(new Uint8Array(ret));
              }
              throw new Sk.builtin.TypeError(
                "byte indices must be integers or slices, not " + Sk.abstr.typeName(index)
              );
            },
            sq$length() {
              return this.v.length;
            },
            sq$concat(other) {
              if (!(other instanceof Sk.builtin.bytes) && !(other instanceof Sk.builtin.array)) {
                throw new Sk.builtin.TypeError(
                  "can't concat " + Sk.abstr.typeName(other) + " to bytes"
                );
              }
              const ret = new Uint8Array(this.v.length + other.v.length);
              let i;
              for (i = 0; i < this.v.length; i++) {
                ret[i] = this.v[i];
              }
              for (let j = 0; j < other.v.length; j++, i++) {
                ret[i] = other.v[j];
              }
              return new Sk.builtin.bytes(ret);
            },
            sq$repeat(n) {
              if (!Sk.misceval.isIndex(n)) {
                throw new Sk.builtin.TypeError(
                  "can't multiply sequence by non-int of type '" + Sk.abstr.typeName(n) + "'"
                );
              }
              n = Sk.misceval.asIndexSized(n, Sk.builtin.OverflowError);
              const len = n * this.v.length;
              if (len > Number.MAX_SAFE_INTEGER) {
                throw new Sk.builtin.OverflowError();
              } else if (n <= 0) {
                return new Sk.builtin.bytes();
              }
              const ret = new Uint8Array(len);
              let j = 0;
              while (j < len) {
                for (let i = 0; i < this.v.length; i++) {
                  ret[j++] = this.v[i];
                }
              }
              return new Sk.builtin.bytes(ret);
            },
            sq$contains(tgt) {
              return this.find$left(tgt) !== -1;
            },
            tp$as_number: true,
            nb$remainder: Sk.builtin.str.prototype.nb$remainder
          }
        ),
        proto: {
          $jsstr() {
            let ret = "";
            for (let i = 0; i < this.v.length; i++) {
              ret += String.fromCharCode(this.v[i]);
            }
            return ret;
          },
          get$tgt(tgt) {
            if (tgt instanceof Sk.builtin.bytes) {
              return tgt.v;
            }
            tgt = Sk.misceval.asIndexOrThrow(
              tgt,
              "argument should be integer or bytes-like object, not {tp$name}"
            );
            if (tgt < 0 || tgt > 255) {
              throw new Sk.builtin.ValueError("bytes must be in range(0, 256)");
            }
            return tgt;
          },
          get$raw(tgt) {
            if (tgt instanceof Sk.builtin.bytes) {
              return tgt.v;
            }
            throw new Sk.builtin.TypeError(
              "a bytes-like object is required, not '" + Sk.abstr.typeName(tgt) + "'"
            );
          },
          get$splitArgs: checkSepMaxSplit,
          find$left: mkFind(false),
          find$right: mkFind(true),
          find$subleft: function findSubLeft(uint8, start, end) {
            end = end - uint8.length + 1;
            let i = start;
            while (i < end) {
              if (uint8.every((val, j) => val === this.v[i + j])) {
                return i;
              }
              i++;
            }
            return -1;
          },
          find$subright(uint8, start, end) {
            let i = end - uint8.length;
            while (i >= start) {
              if (uint8.every((val, j) => val === this.v[i + j])) {
                return i;
              }
              i--;
            }
            return -1;
          },
          $subtype_new(args, kwargs) {
            const instance = new this.constructor();
            const bytes_instance = Sk.builtin.bytes.prototype.tp$new(args, kwargs);
            instance.v = bytes_instance.v;
            return instance;
          },
          sk$asarray() {
            const ret = [];
            this.v.forEach((x) => {
              ret.push(new Sk.builtin.int_(x));
            });
            return ret;
          },
          valueOf() {
            return this.v;
          }
        },
        flags: {
          str$encode: strEncode,
          $decode: bytesDecode,
          check$encodeArgs: checkGetEncodingErrors
        },
        methods: {
          __getnewargs__: {
            $meth() {
              return new Sk.builtin.tuple(new Sk.builtin.bytes(this.v));
            },
            $flags: { NoArgs: true },
            $textsig: null,
            $doc: null
          },
          capitalize: {
            $meth() {
              const len = this.v.length;
              if (len === 0) {
                return new Sk.builtin.bytes(this.v);
              }
              const final = new Uint8Array(len);
              let val = this.v[0];
              final[0] = islower(val) ? val - 32 : val;
              for (let i = 1; i < len; i++) {
                val = this.v[i];
                final[i] = isupper(val) ? val + 32 : val;
              }
              return new Sk.builtin.bytes(final);
            },
            $flags: { NoArgs: true },
            $textsig: null,
            $doc: "B.capitalize() -> copy of B\n\nReturn a copy of B with only its first character capitalized (ASCII)\nand the rest lower-cased."
          },
          center: {
            $meth: mkJust("center", false, true),
            $flags: { MinArgs: 1, MaxArgs: 2 },
            $textsig: null,
            $doc: "B.center(width[, fillchar]) -> copy of B\n\nReturn B centered in a string of length width.  Padding is\ndone using the specified fill character (default is a space)."
          },
          count: {
            $meth(tgt, start, end) {
              tgt = this.get$tgt(tgt);
              ({ start, end } = Sk.builtin.slice.startEnd$wrt(this, start, end));
              let count = 0;
              if (typeof tgt === "number") {
                for (let i = start; i < end; i++) {
                  if (this.v[i] === tgt) {
                    count++;
                  }
                }
              } else {
                const upto = end - tgt.length + 1;
                for (let i = start; i < upto; i++) {
                  if (tgt.every((val, j) => val === this.v[i + j])) {
                    count++;
                    i += tgt.length - 1;
                  }
                }
              }
              return new Sk.builtin.int_(count);
            },
            $flags: { MinArgs: 1, MaxArgs: 3 },
            $textsig: null,
            $doc: "B.count(sub[, start[, end]]) -> int\n\nReturn the number of non-overlapping occurrences of subsection sub in\nbytes B[start:end].  Optional arguments start and end are interpreted\nas in slice notation."
          },
          decode: {
            $meth: bytesDecode,
            $flags: { NamedArgs: ["encoding", "errors"] },
            $textsig: "($self, /, encoding='utf-8', errors='strict')",
            $doc: "Decode the bytes using the codec registered for encoding.\n\n  encoding\n    The encoding with which to decode the bytes.\n  errors\n    The error handling scheme to use for the handling of decoding errors.\n    The default is 'strict' meaning that decoding errors raise a\n    UnicodeDecodeError. Other possible values are 'ignore' and 'replace'\n    as well as any other name registered with codecs.register_error that\n    can handle UnicodeDecodeErrors."
          },
          endswith: {
            $meth: mkStartsEndsWith("endswith", (subarray, tgt) => {
              const start = subarray.length - tgt.length;
              return start >= 0 && tgt.every((val, i) => val === subarray[start + i]);
            }),
            $flags: { MinArgs: 1, MaxArgs: 3 },
            $textsig: null,
            $doc: "B.endswith(suffix[, start[, end]]) -> bool\n\nReturn True if B ends with the specified suffix, False otherwise.\nWith optional start, test B beginning at that position.\nWith optional end, stop comparing B at that position.\nsuffix can also be a tuple of bytes to try."
          },
          expandtabs: {
            $meth(tabsize2) {
              tabsize2 = Sk.misceval.asIndexSized(
                tabsize2,
                Sk.builtin.OverflowError,
                "an integer is required (got type {tp$nam})"
              );
              const final = [];
              let linepos = 0;
              for (let i = 0; i < this.v.length; i++) {
                const val = this.v[i];
                if (val === 9) {
                  const inc = tabsize2 - linepos % tabsize2;
                  final.push(...new Array(inc).fill(32));
                  linepos += inc;
                } else if (val === 10 || val === 13) {
                  final.push(val);
                  linepos = 0;
                } else {
                  final.push(val);
                  linepos++;
                }
              }
              return new Sk.builtin.bytes(new Uint8Array(final));
            },
            $flags: { NamedArgs: ["tabsize"], Defaults: [8] },
            $textsig: null,
            $doc: "B.expandtabs(tabsize=8) -> copy of B\n\nReturn a copy of B where all tab characters are expanded using spaces.\nIf tabsize is not given, a tab size of 8 characters is assumed."
          },
          find: {
            $meth: function find(tgt, start, end) {
              return new Sk.builtin.int_(this.find$left(tgt, start, end));
            },
            $flags: { MinArgs: 1, MaxArgs: 3 },
            $textsig: null,
            $doc: "B.find(sub[, start[, end]]) -> int\n\nReturn the lowest index in B where subsection sub is found,\nsuch that sub is contained within B[start,end].  Optional\narguments start and end are interpreted as in slice notation.\n\nReturn -1 on failure."
          },
          hex: {
            $meth() {
              let final = "";
              for (let i = 0; i < this.v.length; i++) {
                final += this.v[i].toString(16).padStart(2, "0");
              }
              return new Sk.builtin.str(final);
            },
            $flags: { NoArgs: true },
            $textsig: null,
            $doc: "B.hex() -> string\n\nCreate a string of hexadecimal numbers from a bytes object.\nExample: b'\\xb9\\x01\\xef'.hex() -> 'b901ef'."
          },
          index: {
            $meth: function index(tgt, start, end) {
              const val = this.find$left(tgt, start, end);
              if (val === -1) {
                throw new Sk.builtin.ValueError("subsection not found");
              } else {
                return new Sk.builtin.int_(val);
              }
            },
            $flags: { MinArgs: 1, MaxArgs: 3 },
            $textsig: null,
            $doc: "B.index(sub[, start[, end]]) -> int\n\nReturn the lowest index in B where subsection sub is found,\nsuch that sub is contained within B[start,end].  Optional\narguments start and end are interpreted as in slice notation.\n\nRaises ValueError when the subsection is not found."
          },
          isalnum: {
            $meth: mkIsAll((val) => isdigit(val) || islower(val) || isupper(val)),
            $flags: { NoArgs: true },
            $textsig: null,
            $doc: "B.isalnum() -> bool\n\nReturn True if all characters in B are alphanumeric\nand there is at least one character in B, False otherwise."
          },
          isalpha: {
            $meth: mkIsAll((val) => val >= 65 && val <= 90 || val >= 97 && val <= 122),
            $flags: { NoArgs: true },
            $textsig: null,
            $doc: "B.isalpha() -> bool\n\nReturn True if all characters in B are alphabetic\nand there is at least one character in B, False otherwise."
          },
          isascii: {
            $meth: mkIsAll((val) => val >= 0 && val <= 127, true),
            $flags: { NoArgs: true },
            $textsig: null,
            $doc: "B.isascii() -> bool\n\nReturn True if B is empty or all characters in B are ASCII,\nFalse otherwise."
          },
          isdigit: {
            $meth: mkIsAll(isdigit),
            $flags: { NoArgs: true },
            $textsig: null,
            $doc: "B.isdigit() -> bool\n\nReturn True if all characters in B are digits\nand there is at least one character in B, False otherwise."
          },
          islower: {
            $meth: makeIsUpperLower(islower, isupper),
            $flags: { NoArgs: true },
            $textsig: null,
            $doc: "B.islower() -> bool\n\nReturn True if all cased characters in B are lowercase and there is\nat least one cased character in B, False otherwise."
          },
          isspace: {
            $meth: mkIsAll(isspace),
            $flags: { NoArgs: true },
            $textsig: null,
            $doc: "B.isspace() -> bool\n\nReturn True if all characters in B are whitespace\nand there is at least one character in B, False otherwise."
          },
          istitle: {
            $meth: function istitle() {
              let inword = false;
              let cased = false;
              for (let i = 0; i < this.v.length; i++) {
                const val = this.v[i];
                if (isupper(val)) {
                  if (inword) {
                    return Sk.builtin.bool.false$;
                  }
                  inword = true;
                  cased = true;
                } else if (islower(val)) {
                  if (!inword) {
                    return Sk.builtin.bool.false$;
                  }
                  cased = true;
                } else {
                  inword = false;
                }
              }
              return cased ? Sk.builtin.bool.true$ : Sk.builtin.bool.false$;
            },
            $flags: { NoArgs: true },
            $textsig: null,
            $doc: "B.istitle() -> bool\n\nReturn True if B is a titlecased string and there is at least one\ncharacter in B, i.e. uppercase characters may only follow uncased\ncharacters and lowercase characters only cased ones. Return False\notherwise."
          },
          isupper: {
            $meth: makeIsUpperLower(isupper, islower),
            $flags: { NoArgs: true },
            $textsig: null,
            $doc: "B.isupper() -> bool\n\nReturn True if all cased characters in B are uppercase and there is\nat least one cased character in B, False otherwise."
          },
          join: {
            $meth(iterable) {
              const final = [];
              let i = 0;
              return Sk.misceval.chain(
                Sk.misceval.iterFor(Sk.abstr.iter(iterable), (item) => {
                  if (!(item instanceof Sk.builtin.bytes)) {
                    throw new Sk.builtin.TypeError(
                      "sequence item " + i + ": expected a bytes-like object, " + Sk.abstr.typeName(item) + " found"
                    );
                  }
                  i++;
                  if (final.length) {
                    final.push(...this.v);
                  }
                  final.push(...item.v);
                }),
                () => new Sk.builtin.bytes(new Uint8Array(final))
              );
            },
            $flags: { OneArg: true },
            $textsig: "($self, iterable_of_bytes, /)",
            $doc: "Concatenate any number of bytes objects.\n\nThe bytes whose method is called is inserted in between each pair.\n\nThe result is returned as a new bytes object.\n\nExample: b'.'.join([b'ab', b'pq', b'rs']) -> b'ab.pq.rs'."
          },
          ljust: {
            $meth: mkJust("ljust", false, false),
            $flags: { MinArgs: 1, MaxArgs: 2 },
            $textsig: null,
            $doc: "B.ljust(width[, fillchar]) -> copy of B\n\nReturn B left justified in a string of length width. Padding is\ndone using the specified fill character (default is a space)."
          },
          lower: {
            $meth: mkCaseSwitch((val) => isupper(val) ? val + 32 : val),
            $flags: { NoArgs: true },
            $textsig: null,
            $doc: "B.lower() -> copy of B\n\nReturn a copy of B with all ASCII characters converted to lowercase."
          },
          lstrip: {
            $meth: mkStrip(true, false),
            $flags: { MinArgs: 0, MaxArgs: 1 },
            $textsig: "($self, bytes=None, /)",
            $doc: "Strip leading bytes contained in the argument.\n\nIf the argument is omitted or None, strip leading  ASCII whitespace."
          },
          partition: {
            $meth: mkPartition(false),
            $flags: { OneArg: true },
            $textsig: "($self, sep, /)",
            $doc: "Partition the bytes into three parts using the given separator.\n\nThis will search for the separator sep in the bytes. If the separator is found,\nreturns a 3-tuple containing the part before the separator, the separator\nitself, and the part after it.\n\nIf the separator is not found, returns a 3-tuple containing the original bytes\nobject and two empty bytes objects."
          },
          replace: {
            $meth(oldB, newB, count) {
              oldB = this.get$raw(oldB);
              newB = this.get$raw(newB);
              count = count === void 0 ? -1 : Sk.misceval.asIndexSized(count, Sk.builtin.OverflowError);
              count = count < 0 ? Infinity : count;
              const final = [];
              let found = 0, i = 0;
              while (i < this.v.length && found < count) {
                const next = this.find$subleft(oldB, i, this.v.length);
                if (next === -1) {
                  break;
                }
                for (let j = i; j < next; j++) {
                  final.push(this.v[j]);
                }
                final.push(...newB);
                i = next + oldB.length;
                found++;
              }
              for (i; i < this.v.length; i++) {
                final.push(this.v[i]);
              }
              return new Sk.builtin.bytes(new Uint8Array(final));
            },
            $flags: { MinArgs: 2, MaxArgs: 3 },
            $textsig: "($self, old, new, count=-1, /)",
            $doc: "Return a copy with all occurrences of substring old replaced by new.\n\n  count\n    Maximum number of occurrences to replace.\n    -1 (the default value) means replace all occurrences.\n\nIf the optional argument count is given, only the first count occurrences are\nreplaced."
          },
          rfind: {
            $meth(tgt, start, end) {
              return new Sk.builtin.int_(this.find$right(tgt, start, end));
            },
            $flags: { MinArgs: 1, MaxArgs: 3 },
            $textsig: null,
            $doc: "B.rfind(sub[, start[, end]]) -> int\n\nReturn the highest index in B where subsection sub is found,\nsuch that sub is contained within B[start,end].  Optional\narguments start and end are interpreted as in slice notation.\n\nReturn -1 on failure."
          },
          rindex: {
            $meth: function rindex(tgt, start, end) {
              const val = this.find$right(tgt, start, end);
              if (val === -1) {
                throw new Sk.builtin.ValueError("subsection not found");
              } else {
                return new Sk.builtin.int_(val);
              }
            },
            $flags: { MinArgs: 1, MaxArgs: 3 },
            $textsig: null,
            $doc: "B.rindex(sub[, start[, end]]) -> int\n\nReturn the highest index in B where subsection sub is found,\nsuch that sub is contained within B[start,end].  Optional\narguments start and end are interpreted as in slice notation.\n\nRaise ValueError when the subsection is not found."
          },
          rjust: {
            $meth: mkJust("rjust", true, false),
            $flags: { MinArgs: 1, MaxArgs: 2 },
            $textsig: null,
            $doc: "B.rjust(width[, fillchar]) -> copy of B\n\nReturn B right justified in a string of length width. Padding is\ndone using the specified fill character (default is a space)"
          },
          rpartition: {
            $meth: mkPartition(true),
            $flags: { OneArg: true },
            $textsig: "($self, sep, /)",
            $doc: "Partition the bytes into three parts using the given separator.\n\nThis will search for the separator sep in the bytes, starting at the end. If\nthe separator is found, returns a 3-tuple containing the part before the\nseparator, the separator itself, and the part after it.\n\nIf the separator is not found, returns a 3-tuple containing two empty bytes\nobjects and the original bytes object."
          },
          rsplit: {
            $meth: function rSplit(sep, maxsplit) {
              ({ sep, maxsplit } = this.get$splitArgs(sep, maxsplit));
              const result = [];
              let splits = 0, i = this.v.length;
              if (sep !== null) {
                while (i >= 0 && splits < maxsplit) {
                  const next = this.find$subright(sep, 0, i);
                  if (next === -1) {
                    break;
                  }
                  result.push(new Sk.builtin.bytes(this.v.subarray(next + sep.length, i)));
                  i = next;
                  splits++;
                }
                result.push(new Sk.builtin.bytes(this.v.subarray(0, i)));
              } else {
                i--;
                while (splits < maxsplit) {
                  while (isspace(this.v[i])) {
                    i--;
                  }
                  if (i < 0) {
                    break;
                  }
                  const index = i + 1;
                  i--;
                  while (i >= 0 && !isspace(this.v[i])) {
                    i--;
                  }
                  result.push(new Sk.builtin.bytes(this.v.subarray(i + 1, index)));
                  splits++;
                }
                if (i >= 0) {
                  while (isspace(this.v[i])) {
                    i--;
                  }
                  if (i >= 0) {
                    result.push(new Sk.builtin.bytes(this.v.subarray(0, i + 1)));
                  }
                }
              }
              return new Sk.builtin.list(result.reverse());
            },
            $flags: { NamedArgs: ["sep", "maxsplit"], Defaults: [Sk.builtin.none.none$, -1] },
            $textsig: "($self, /, sep=None, maxsplit=-1)",
            $doc: "Return a list of the sections in the bytes, using sep as the delimiter.\n\n  sep\n    The delimiter according which to split the bytes.\n    None (the default value) means split on ASCII whitespace characters\n    (space, tab, return, newline, formfeed, vertical tab).\n  maxsplit\n    Maximum number of splits to do.\n    -1 (the default value) means no limit.\n\nSplitting is done starting at the end of the bytes and working to the front."
          },
          rstrip: {
            $meth: mkStrip(false, true),
            $flags: { MinArgs: 0, MaxArgs: 1 },
            $textsig: "($self, bytes=None, /)",
            $doc: "Strip trailing bytes contained in the argument.\n\nIf the argument is omitted or None, strip trailing ASCII whitespace."
          },
          split: {
            $meth: function Split(sep, maxsplit) {
              ({ sep, maxsplit } = this.get$splitArgs(sep, maxsplit));
              const result = [];
              const mylen = this.v.length;
              let splits = 0, i = 0;
              if (sep !== null) {
                while (i < mylen && splits < maxsplit) {
                  const next = this.find$subleft(sep, i, mylen);
                  if (next === -1) {
                    break;
                  }
                  result.push(new Sk.builtin.bytes(this.v.subarray(i, next)));
                  i = next + sep.length;
                  splits++;
                }
                result.push(new Sk.builtin.bytes(this.v.subarray(i, mylen)));
              } else {
                while (splits < maxsplit) {
                  while (isspace(this.v[i])) {
                    i++;
                  }
                  if (i === mylen) {
                    break;
                  }
                  const index = i;
                  i++;
                  while (i < mylen && !isspace(this.v[i])) {
                    i++;
                  }
                  result.push(new Sk.builtin.bytes(this.v.subarray(index, i)));
                  splits++;
                }
                if (i < mylen) {
                  while (isspace(this.v[i])) {
                    i++;
                  }
                  if (i < mylen) {
                    result.push(new Sk.builtin.bytes(this.v.subarray(i, mylen)));
                  }
                }
              }
              return new Sk.builtin.list(result);
            },
            $flags: { NamedArgs: ["sep", "maxsplit"], Defaults: [Sk.builtin.none.none$, -1] },
            $textsig: "($self, /, sep=None, maxsplit=-1)",
            $doc: "Return a list of the sections in the bytes, using sep as the delimiter.\n\n  sep\n    The delimiter according which to split the bytes.\n    None (the default value) means split on ASCII whitespace characters\n    (space, tab, return, newline, formfeed, vertical tab).\n  maxsplit\n    Maximum number of splits to do.\n    -1 (the default value) means no limit."
          },
          splitlines: {
            $meth(keepends) {
              keepends = Sk.misceval.isTrue(keepends);
              const final = [];
              let sol = 0;
              let eol;
              let i = 0;
              const len = this.v.length;
              while (i < len) {
                const val = this.v[i];
                if (val === 13) {
                  const rn = this.v[i + 1] === 10;
                  if (keepends) {
                    eol = rn ? i + 2 : i + 1;
                  } else {
                    eol = i;
                  }
                  final.push(new Sk.builtin.bytes(this.v.subarray(sol, eol)));
                  i = sol = rn ? i + 2 : i + 1;
                } else if (val === 10) {
                  eol = keepends ? i + 1 : i;
                  final.push(new Sk.builtin.bytes(this.v.subarray(sol, eol)));
                  i = sol = i + 1;
                } else {
                  i++;
                }
              }
              if (sol < len) {
                final.push(new Sk.builtin.bytes(this.v.subarray(sol, len)));
              }
              return new Sk.builtin.list(final);
            },
            $flags: { NamedArgs: ["keepends"], Defaults: [false] },
            $textsig: "($self, /, keepends=False)",
            $doc: "Return a list of the lines in the bytes, breaking at line boundaries.\n\nLine breaks are not included in the resulting list unless keepends is given and\ntrue."
          },
          startswith: {
            $meth: mkStartsEndsWith(
              "startswith",
              (subarray, tgt) => tgt.length <= subarray.length && tgt.every((val, i) => val === subarray[i])
            ),
            $flags: { MinArgs: 1, MaxArgs: 3 },
            $textsig: null,
            $doc: "B.startswith(prefix[, start[, end]]) -> bool\n\nReturn True if B starts with the specified prefix, False otherwise.\nWith optional start, test B beginning at that position.\nWith optional end, stop comparing B at that position.\nprefix can also be a tuple of bytes to try."
          },
          strip: {
            $meth: mkStrip(true, true),
            $flags: { MinArgs: 0, MaxArgs: 1 },
            $textsig: "($self, bytes=None, /)",
            $doc: "Strip leading and trailing bytes contained in the argument.\n\nIf the argument is omitted or None, strip leading and trailing ASCII whitespace."
          },
          swapcase: {
            $meth: mkCaseSwitch((val) => isupper(val) ? val + 32 : islower(val) ? val - 32 : val),
            $flags: { NoArgs: true },
            $textsig: null,
            $doc: "B.swapcase() -> copy of B\n\nReturn a copy of B with uppercase ASCII characters converted\nto lowercase ASCII and vice versa."
          },
          title: {
            $meth() {
              const len = this.v.length;
              const final = new Uint8Array(len);
              let inword = false;
              for (let i = 0; i < len; i++) {
                const val = this.v[i];
                if (isupper(val)) {
                  final[i] = inword ? val + 32 : val;
                  inword = true;
                } else if (islower(val)) {
                  final[i] = inword ? val : val - 32;
                  inword = true;
                } else {
                  final[i] = val;
                  inword = false;
                }
              }
              return new Sk.builtin.bytes(final);
            },
            $flags: { NoArgs: true },
            $textsig: null,
            $doc: "B.title() -> copy of B\n\nReturn a titlecased version of B, i.e. ASCII words start with uppercase\ncharacters, all remaining cased characters have lowercase."
          },
          // translate: {
          //     $meth() {
          //         throw new Sk.builtin.NotImplementedError("translate() bytes method not implemented in Skulpt");
          //     },
          //     $flags: { NoArgs: true },
          //     $textsig: "($self, table, /, delete=b'')",
          //     $doc:
          //         "Return a copy with each character mapped by the given translation table.\n\n  table\n    Translation table, which must be a bytes object of length 256.\n\nAll characters occurring in the optional argument delete are removed.\nThe remaining characters are mapped through the given translation table.",
          // },
          upper: {
            $meth: mkCaseSwitch((val) => islower(val) ? val - 32 : val),
            $flags: { NoArgs: true },
            $textsig: null,
            $doc: "B.upper() -> copy of B\n\nReturn a copy of B with all ASCII characters converted to uppercase."
          },
          zfill: {
            $meth(width) {
              width = Sk.misceval.asIndexSized(width, Sk.builtin.IndexError);
              const fill_len = width - this.v.length;
              if (fill_len <= 0) {
                return new Sk.builtin.bytes(this.v);
              }
              const final = new Uint8Array(width);
              let i = 0, j;
              if (this.v[0] === 43 || this.v[0] === 45) {
                final[0] = this.v[0];
                i++;
              }
              final.fill(48, i, i + fill_len);
              for (j = i, i = i + fill_len; i < width; i++, j++) {
                final[i] = this.v[j];
              }
              return new Sk.builtin.bytes(final);
            },
            $flags: { OneArg: true },
            $textsig: null,
            $doc: "B.zfill(width) -> copy of B\n\nPad a numeric string B with zeros on the left, to fill a field\nof the specified width.  B is never truncated."
          }
        },
        classmethods: {
          fromhex: {
            $meth: fromhex,
            $flags: { OneArg: true },
            $textsig: "($type, string, /)",
            $doc: "Create a bytes object from a string of hexadecimal numbers.\n\nSpaces between two numbers are accepted.\nExample: bytes.fromhex('B9 01EF') -> b'\\\\xb9\\\\x01\\\\xef'."
          }
        }
      });
      Sk.builtin.bytearray = Sk.abstr.buildNativeClass("bytearray", {
        constructor: function bytearray(source) {
          if (!(this instanceof Sk.builtin.bytearray)) {
            throw new TypeError("bytearray is a constructor use 'new'");
          }
          if (source === void 0) {
            this.v = new Uint8Array();
          } else if (source instanceof Uint8Array) {
            this.v = source;
          } else if (source instanceof Uint8ClampedArray) {
            this.v = new Uint8Array(source);
          } else if (Array.isArray(source)) {
            Sk.asserts.assert(
              source.every((x) => x >= 0 && x <= 255),
              "bad internal call to bytearray with array"
            );
            this.v = new Uint8Array(source);
          } else if (typeof source === "string") {
            let cc;
            const uint8 = new Uint8Array(source.length);
            const len = source.length;
            for (let i = 0; i < len; i++) {
              cc = source.charCodeAt(i);
              if (cc > 255) {
                throw new Sk.builtin.UnicodeDecodeError(
                  "invalid string at index " + i + " (possibly contains a unicode character)"
                );
              }
              uint8[i] = cc;
            }
            this.v = uint8;
          } else if (typeof source === "number") {
            this.v = new Uint8Array(source);
          } else {
            throw new TypeError(
              `bad internal argument to bytearray constructor (got '${typeof source}': ${source})`
            );
          }
        },
        slots: (
          /**@lends {Sk.builtin.bytearray.prototype} */
          {
            tp$getattr: Sk.generic.getAttr,
            tp$setattr: Sk.generic.setAttr,
            tp$doc: "bytearray([source[, encoding[, errors]]]) -> bytearray\n\nReturn a new array of bytes. The bytearray class is a mutable\nsequence of integers in the range 0 <= x < 256. It has most of\nthe usual methods of mutable sequences, described in Mutable\nSequence Types, as well as most methods that the bytes type has,\nsee Bytes and Byte Array Methods.",
            tp$new(args, kwargs) {
              if (this !== Sk.builtin.bytearray.prototype) {
                return this.$subtype_new(args, kwargs);
              }
              kwargs = kwargs || [];
              let source, pySource, dunderBytes, encoding, errors;
              if (args.length <= 1 && +kwargs.length === 0) {
                pySource = args[0];
              } else {
                [pySource, encoding, errors] = Sk.abstr.copyKeywordsToNamedArgs(
                  "bytearray",
                  [null, "pySource", "errors"],
                  args,
                  kwargs
                );
                ({ encoding, errors } = checkGetEncodingErrors("bytearray", encoding, errors));
                if (!Sk.builtin.checkString(pySource)) {
                  throw new Sk.builtin.TypeError("encoding or errors without a string argument");
                }
                return bytesToBytearray(strEncode(pySource, encoding, errors));
              }
              if (pySource === void 0) {
                return new Sk.builtin.bytearray();
              } else if ((dunderBytes = Sk.abstr.lookupSpecial(pySource, Sk.builtin.str.$bytes)) !== void 0) {
                const ret = Sk.misceval.callsimOrSuspendArray(dunderBytes, []);
                return Sk.misceval.chain(ret, (bytesSource) => {
                  if (!Sk.builtin.checkBytes(bytesSource)) {
                    throw new Sk.builtin.TypeError(
                      "__bytes__ returned non-bytes (type " + Sk.abstr.typeName(bytesSource) + ")"
                    );
                  }
                  return bytesToBytearray(bytesSource);
                });
              } else if (Sk.misceval.isIndex(pySource)) {
                source = Sk.misceval.asIndexSized(pySource, Sk.builtin.OverflowError);
                if (source < 0) {
                  throw new Sk.builtin.ValueError("negative count");
                }
                return new Sk.builtin.bytearray(source);
              } else if (Sk.builtin.checkBytes(pySource)) {
                return new Sk.builtin.bytearray(pySource.v);
              } else if (Sk.builtin.checkString(pySource)) {
                throw new Sk.builtin.TypeError("string argument without an encoding");
              } else if (Sk.builtin.checkIterable(pySource)) {
                let source2 = [];
                let r = Sk.misceval.iterFor(Sk.abstr.iter(pySource), (byte) => {
                  const n = Sk.misceval.asIndexSized(byte);
                  if (n < 0 || n > 255) {
                    throw new Sk.builtin.ValueError("bytes must be in range(0, 256)");
                  }
                  source2.push(n);
                });
                return Sk.misceval.chain(r, () => new Sk.builtin.bytearray(source2));
              }
              throw new Sk.builtin.TypeError(
                "cannot convert '" + Sk.abstr.typeName(pySource) + "' object into bytes"
              );
            },
            $r() {
              return bytesToString(this);
            },
            tp$str() {
              return this.$r();
            },
            tp$iter() {
              return new bytes_iter_(this);
            },
            tp$richcompare(other, op) {
              if (this === other && Sk.misceval.opAllowsEquality(op)) {
                return true;
              } else if (!(other instanceof Sk.builtin.bytearray)) {
                return Sk.builtin.NotImplemented.NotImplemented$;
              }
              const v = this.v;
              const w = other.v;
              if (v.length !== w.length && (op === "Eq" || op === "NotEq")) {
                return op !== "Eq";
              }
              let i;
              const min_len = Math.min(v.length, w.length);
              for (i = 0; i < min_len; i++) {
                if (v[i] !== w[i]) {
                  break;
                }
              }
              switch (op) {
                case "Lt":
                  return i === min_len && v.length < w.length || v[i] < w[i];
                case "LtE":
                  return i === min_len && v.length <= w.length || v[i] <= w[i];
                case "Eq":
                  return i === min_len;
                case "NotEq":
                  return i < min_len;
                case "Gt":
                  return i === min_len && v.length > w.length || v[i] > w[i];
                case "GtE":
                  return i === min_len && v.length >= w.length || v[i] >= w[i];
              }
            },
            tp$hash() {
              throw new Sk.builtin.TypeError("unhashable type: 'bytearray'");
            },
            tp$as_sequence_or_mapping: true,
            mp$subscript(index) {
              if (Sk.misceval.isIndex(index)) {
                let i = Sk.misceval.asIndexSized(index, Sk.builtin.IndexError);
                if (i !== void 0) {
                  if (i < 0) {
                    i = this.v.length + i;
                  }
                  if (i < 0 || i >= this.v.length) {
                    throw new Sk.builtin.IndexError("index out of range");
                  }
                  return new Sk.builtin.int_(this.v[i]);
                }
              } else if (index instanceof Sk.builtin.slice) {
                const ret = [];
                index.sssiter$(this.v.length, (i) => {
                  ret.push(this.v[i]);
                });
                return new Sk.builtin.bytearray(new Uint8Array(ret));
              }
              throw new Sk.builtin.TypeError(
                "byte indices must be integers or slices, not " + Sk.abstr.typeName(index)
              );
            },
            mp$ass_subscript(index, value) {
              if (Sk.misceval.isIndex(index)) {
                this.ass$index(index, value);
              } else if (index instanceof Sk.builtin.slice) {
                const { start, stop, step } = index.slice$indices(this.v.length);
                if (step === 1) {
                  this.ass$slice(start, stop, value);
                } else {
                  this.ass$ext_slice(index, value);
                }
              } else {
                throw new Sk.builtin.TypeError(
                  "list indices must be integers or slices, not " + Sk.abstr.typeName(index)
                );
              }
            },
            ass$index(index, value) {
              let i = Sk.misceval.asIndexSized(index, Sk.builtin.IndexError);
              i = this.list$inRange(i, "bytearray assignment index out of range");
              this.v[i] = value;
            },
            ass$slice(start, stop, iterable) {
              if (!Sk.builtin.checkIterable(iterable)) {
                throw new Sk.builtin.TypeError("can only assign an iterable");
              }
              const vals = Sk.misceval.arrayFromIterable(iterable).map((v) => v.v);
              const oldLength = this.v.length;
              let target = this.v;
              if (vals.length > oldLength) {
                target = new Uint8Array(vals.length);
                target.set(this.v);
              }
              target.set(vals, start);
              this.v = target;
            },
            ass$ext_slice(slice, iterable) {
              const indices = [];
              slice.sssiter$(this.v.length, (i) => {
                indices.push(i);
              });
              if (!Sk.builtin.checkIterable(iterable)) {
                throw new Sk.builtin.TypeError("must assign iterable to extended slice");
              }
              const vals = Sk.misceval.arrayFromIterable(iterable);
              if (indices.length !== vals.length) {
                throw new Sk.builtin.ValueError(
                  "attempt to assign sequence of size " + vals.length + " to extended slice of size " + indices.length
                );
              }
              for (let i = 0; i < indices.length; i++) {
                this.v[indices[i]] = vals[i];
              }
            },
            sq$length() {
              return this.v.length;
            },
            sq$concat(other) {
              if (!(other instanceof Sk.builtin.bytes) && !(other instanceof Sk.builtin.array)) {
                throw new Sk.builtin.TypeError(
                  "can't concat " + Sk.abstr.typeName(other) + " to bytearray"
                );
              }
              const ret = new Uint8Array(this.v.length + other.v.length);
              let i;
              for (i = 0; i < this.v.length; i++) {
                ret[i] = this.v[i];
              }
              for (let j = 0; j < other.v.length; j++, i++) {
                ret[i] = other.v[j];
              }
              return new Sk.builtin.bytearray(ret);
            },
            sq$contains(tgt) {
              return this.find$left(tgt) !== -1;
            },
            tp$as_number: true,
            nb$remainder: Sk.builtin.str.prototype.nb$remainder
          }
        ),
        proto: {
          $jsstr() {
            let ret = "";
            for (let i = 0; i < this.v.length; i++) {
              ret += String.fromCharCode(this.v[i]);
            }
            return ret;
          },
          get$tgt(tgt) {
            if (tgt instanceof Sk.builtin.bytearray || tgt instanceof Sk.builtin.bytes) {
              return tgt.v;
            }
            tgt = Sk.misceval.asIndexOrThrow(
              tgt,
              "argument should be integer or bytes-like object, not {tp$name}"
            );
            if (tgt < 0 || tgt > 255) {
              throw new Sk.builtin.ValueError("bytes must be in range(0, 256)");
            }
            return tgt;
          },
          get$raw(tgt) {
            if (tgt instanceof Sk.builtin.bytearray || tgt instanceof Sk.builtin.bytes) {
              return tgt.v;
            }
            throw new Sk.builtin.TypeError(
              "a bytes-like object is required, not '" + Sk.abstr.typeName(tgt) + "'"
            );
          },
          get$splitArgs: checkSepMaxSplit,
          find$left: mkFind(false),
          find$right: mkFind(true),
          find$subleft: function findSubLeft(uint8, start, end) {
            end = end - uint8.length + 1;
            let i = start;
            while (i < end) {
              if (uint8.every((val, j) => val === this.v[i + j])) {
                return i;
              }
              i++;
            }
            return -1;
          },
          find$subright(uint8, start, end) {
            let i = end - uint8.length;
            while (i >= start) {
              if (uint8.every((val, j) => val === this.v[i + j])) {
                return i;
              }
              i--;
            }
            return -1;
          },
          $subtype_new(args, kwargs) {
            const instance = new this.constructor();
            const bytes_instance = Sk.builtin.bytearray.prototype.tp$new(args, kwargs);
            instance.v = bytes_instance.v;
            return instance;
          },
          sk$asarray() {
            const ret = [];
            this.v.forEach((x) => {
              ret.push(new Sk.builtin.int_(x));
            });
            return ret;
          },
          valueOf() {
            return this.v;
          },
          append(value) {
            const v = Sk.misceval.asIndexSized(value);
            if (v < 0 || v > 255) {
              throw new Sk.builtin.ValueError("byte must be in range(0, 256)");
            }
            const new_v = new Uint8Array(this.v.length + 1);
            new_v.set(this.v);
            new_v[this.v.length] = v;
            this.v = new_v;
          },
          extend(iterable) {
            const to_extend = [];
            Sk.misceval.iterFor(Sk.abstr.iter(iterable), (value) => {
              const v = Sk.misceval.asIndexSized(value);
              if (v < 0 || v > 255) {
                throw new Sk.builtin.ValueError("byte must be in range(0, 256)");
              }
              to_extend.push(v);
            });
            const new_v = new Uint8Array(this.v.length + to_extend.length);
            new_v.set(this.v);
            new_v.set(to_extend, this.v.length);
            this.v = new_v;
          },
          pop(index) {
            const len = this.v.length;
            if (len === 0) {
              throw new Sk.builtin.IndexError("pop from empty bytearray");
            }
            index = index === void 0 ? len - 1 : Sk.misceval.asIndexSized(index);
            if (index < 0) {
              index += len;
            }
            if (index < 0 || index >= len) {
              throw new Sk.builtin.IndexError("pop index out of range");
            }
            const value = this.v[index];
            const new_v = new Uint8Array(len - 1);
            new_v.set(this.v.subarray(0, index));
            new_v.set(this.v.subarray(index + 1), index);
            this.v = new_v;
            return new Sk.builtin.int_(value);
          },
          clear() {
            this.v = new Uint8Array();
          }
        },
        flags: {
          str$encode: strEncode,
          $decode: bytesDecode,
          check$encodeArgs: checkGetEncodingErrors
        },
        methods: {
          __getnewargs__: {
            $meth() {
              return new Sk.builtin.tuple(new Sk.builtin.bytearray(this.v));
            },
            $flags: { NoArgs: true },
            $textsig: null,
            $doc: null
          },
          decode: {
            $meth: bytesDecode,
            $flags: { NamedArgs: ["encoding", "errors"] },
            $textsig: "($self, /, encoding='utf-8', errors='strict')",
            $doc: "Decode the bytes using the codec registered for encoding.\n\n  encoding\n    The encoding with which to decode the bytes.\n  errors\n    The error handling scheme to use for the handling of decoding errors.\n    The default is 'strict' meaning that decoding errors raise a\n    UnicodeDecodeError. Other possible values are 'ignore' and 'replace'\n    as well as any other name registered with codecs.register_error that\n    can handle UnicodeDecodeErrors."
          },
          append: {
            $meth(value) {
              this.append(value);
              return Sk.builtin.none.none$;
            },
            $flags: { OneArg: true },
            $doc: "Append a single byte to the end of the bytearray."
          },
          extend: {
            $meth(iterable) {
              this.extend(iterable);
              return Sk.builtin.none.none$;
            },
            $flags: { OneArg: true },
            $doc: "Extend bytearray with bytes from an iterable."
          },
          pop: {
            $meth(index) {
              return this.pop(index);
            },
            $flags: { MinArgs: 0, MaxArgs: 1 },
            $doc: "Remove and return a single byte from the bytearray."
          },
          clear: {
            $meth() {
              this.clear();
              return Sk.builtin.none.none$;
            },
            $flags: { NoArgs: true },
            $doc: "Remove all elements from the bytearray."
          }
          // Implement other mutable methods (e.g., remove, insert, etc.)
        },
        classmethods: {
          fromhex: {
            $meth: fromhex,
            $flags: { OneArg: true },
            $textsig: "($type, string, /)",
            $doc: "Create a bytes object from a string of hexadecimal numbers.\n\nSpaces between two numbers are accepted.\nExample: bytes.fromhex('B9 01EF') -> b'\\\\xb9\\\\x01\\\\xef'."
          }
        }
      });
      function checkGetEncodingErrors(funcname, encoding, errors) {
        if (encoding === void 0) {
          encoding = "utf-8";
        } else if (!Sk.builtin.checkString(encoding)) {
          throw new Sk.builtin.TypeError(
            funcname + "() argument " + ("bytesstr".includes(funcname) ? 2 : 1) + " must be str not " + Sk.abstr.typeName(encoding)
          );
        } else {
          encoding = encoding.$jsstr();
        }
        if (errors === void 0) {
          errors = "strict";
        } else if (!Sk.builtin.checkString(errors)) {
          throw new Sk.builtin.TypeError(
            funcname + "() argument " + ("bytesstr".includes(funcname) ? 3 : 2) + " must be str not " + Sk.abstr.typeName(errors)
          );
        } else {
          errors = errors.$jsstr();
        }
        return { encoding, errors };
      }
      function strEncode(pyStr, encoding, errors) {
        const source = pyStr.$jsstr();
        encoding = normalizeEncoding(encoding);
        if (!(errors === "strict" || errors === "ignore" || errors === "replace")) {
          throw new Sk.builtin.NotImplementedError(
            "'" + errors + "' error handling not implemented in Skulpt"
          );
        }
        let uint8;
        if (encoding === "ascii") {
          uint8 = encodeAscii(source, errors);
        } else if (encoding === "utf-8") {
          uint8 = Encoder.encode(source);
        } else if (encoding === "latin1") {
          uint8 = Latin1Encoder.encode(source);
        } else {
          throw new Sk.builtin.LookupError("unknown encoding: " + encoding);
        }
        return new Sk.builtin.bytes(uint8);
      }
      function encodeAscii(source, errors) {
        const data = [];
        for (let i in source) {
          const val = source.charCodeAt(i);
          if (val > 127) {
            if (errors === "strict") {
              const hexval = makehexform(val);
              throw new Sk.builtin.UnicodeEncodeError(
                "'ascii' codec can't encode character '" + hexval + "' in position " + i + ": ordinal not in range(128)"
              );
            } else if (errors === "replace") {
              data.push(63);
            }
          } else {
            data.push(val);
          }
        }
        return new Uint8Array(data);
      }
      function makehexform(num) {
        var leading;
        if (num <= 265) {
          leading = "\\x";
        } else {
          leading = "\\u";
        }
        num = num.toString(16);
        if (num.length === 3) {
          num = num.slice(1, 3);
        }
        if (num.length === 1) {
          num = leading + "0" + num;
        } else {
          num = leading + num;
        }
        return num;
      }
      function decodeAscii(source, errors) {
        let final = "";
        for (let i = 0; i < source.length; i++) {
          const val = source[i];
          if (val > 127) {
            if (errors === "strict") {
              throw new Sk.builtin.UnicodeDecodeError(
                "'ascii' codec can't decode byte 0x" + val.toString(16) + " in position " + i + ": ordinal not in range(128)"
              );
            } else if (errors === "replace") {
              final += String.fromCharCode(65533);
            }
          } else {
            final += String.fromCharCode(val);
          }
        }
        return final;
      }
      function decodeUtf(source, errors) {
        const string = Decoder.decode(source);
        if (errors === "replace") {
          return string;
        } else if (errors === "strict") {
          const i = string.indexOf("\uFFFD");
          if (i === -1) {
            return string;
          }
          throw new Sk.builtin.UnicodeDecodeError(
            "'utf-8' codec can't decode byte 0x" + source[i].toString(16) + " in position " + i + ": invalid start byte"
          );
        }
        return string.replace(//g, "");
      }
      function decodeLatin1(source, errors) {
        const string = Latin1Decoder.decode(source);
        if (errors === "replace") {
          return string;
        } else if (errors === "strict") {
          const i = string.indexOf("\uFFFD");
          if (i === -1) {
            return string;
          }
          throw new Sk.builtin.UnicodeDecodeError(
            "'latin1' codec can't decode byte 0x" + source[i].toString(16) + " in position " + i + ": invalid start byte"
          );
        }
      }
      function bytesDecode(encoding, errors) {
        ({ encoding, errors } = checkGetEncodingErrors("decode", encoding, errors));
        encoding = normalizeEncoding(encoding);
        if (!(errors === "strict" || errors === "ignore" || errors === "replace")) {
          throw new Sk.builtin.NotImplementedError(
            "'" + errors + "' error handling not implemented in Skulpt"
          );
        }
        let jsstr;
        if (encoding === "ascii") {
          jsstr = decodeAscii(this.v, errors);
        } else if (encoding === "utf-8") {
          jsstr = decodeUtf(this.v, errors);
        } else if (encoding === "latin1") {
          jsstr = decodeLatin1(this.v, errors);
        } else {
          throw new Sk.builtin.LookupError("unknown encoding: " + encoding);
        }
        return new Sk.builtin.str(jsstr);
      }
      function mkStartsEndsWith(funcname, is_match) {
        return function(prefix, start, end) {
          if (!(prefix instanceof Sk.builtin.bytes || prefix instanceof Sk.builtin.tuple)) {
            throw new Sk.builtin.TypeError(
              funcname + " first arg must be bytes or a tuple of bytes, not " + Sk.abstr.typeName(prefix)
            );
          }
          ({ start, end } = Sk.builtin.slice.startEnd$wrt(this, start, end));
          if (end < start) {
            return Sk.builtin.bool.false$;
          }
          const slice = this.v.subarray(start, end);
          if (prefix instanceof Sk.builtin.tuple) {
            for (let iter = Sk.abstr.iter(prefix), item = iter.tp$iternext(); item !== void 0; item = iter.tp$iternext()) {
              item = this.get$raw(item);
              if (is_match(slice, item)) {
                return Sk.builtin.bool.true$;
              }
            }
            return Sk.builtin.bool.false$;
          } else {
            return is_match(slice, prefix.v) ? Sk.builtin.bool.true$ : Sk.builtin.bool.false$;
          }
        };
      }
      function mkFind(isReversed) {
        return function find(tgt, start, end) {
          tgt = this.get$tgt(tgt);
          ({ start, end } = Sk.builtin.slice.startEnd$wrt(this, start, end));
          if (end < start) {
            return -1;
          }
          let idx;
          if (typeof tgt === "number") {
            idx = isReversed ? this.v.lastIndexOf(tgt, end - 1) : this.v.indexOf(tgt, start);
            return idx >= start && idx < end ? idx : -1;
          }
          if (isReversed) {
            return this.find$subright(tgt, start, end);
          } else {
            return this.find$subleft(tgt, start, end);
          }
        };
      }
      function mkPartition(isReversed) {
        return function partition(sep) {
          sep = this.get$raw(sep);
          let pos;
          if (isReversed) {
            pos = this.find$subright(sep, 0, this.v.length);
            if (pos < 0) {
              return new Sk.builtin.tuple([new Sk.builtin.bytes(), new Sk.builtin.bytes(), this]);
            }
          } else {
            pos = this.find$subleft(sep, 0, this.v.length);
            if (pos < 0) {
              return new Sk.builtin.tuple([this, new Sk.builtin.bytes(), new Sk.builtin.bytes()]);
            }
          }
          return new Sk.builtin.tuple([
            new Sk.builtin.bytes(this.v.subarray(0, pos)),
            new Sk.builtin.bytes(sep),
            new Sk.builtin.bytes(this.v.subarray(pos + sep.length))
          ]);
        };
      }
      function mkStrip(isLeft, isRight) {
        return function stripBytes(chars) {
          let strip_chrs;
          if (chars === void 0 || chars === Sk.builtin.none.none$) {
            strip_chrs = new Uint8Array([9, 10, 11, 12, 13, 32, 133]);
          } else {
            strip_chrs = this.get$raw(chars);
          }
          let start = 0, end = this.v.length;
          if (isLeft) {
            while (start < end && strip_chrs.includes(this.v[start])) {
              start++;
            }
          }
          if (isRight) {
            while (end > start && strip_chrs.includes(this.v[end - 1])) {
              end--;
            }
          }
          const final = new Uint8Array(end - start);
          for (let i = 0; i < final.length; i++) {
            final[i] = this.v[i + start];
          }
          return new Sk.builtin.bytes(final);
        };
      }
      function mkJust(funcname, isRight, isCenter) {
        return function justify(width, fillbyte) {
          if (fillbyte === void 0) {
            fillbyte = 32;
          } else if (!(fillbyte instanceof Sk.builtin.bytes) || fillbyte.v.length != 1) {
            throw new Sk.builtin.TypeError(
              funcname + "() argument 2 must be a byte string of length 1, not " + Sk.abstr.typeName(fillbyte)
            );
          } else {
            fillbyte = fillbyte.v[0];
          }
          const mylen = this.v.length;
          width = Sk.misceval.asIndexSized(width, Sk.builtin.OverflowError);
          if (width <= mylen) {
            return new Sk.builtin.bytes(this.v);
          }
          const final = new Uint8Array(width);
          let fill1, fill2;
          if (isCenter) {
            fill1 = Math.floor((width - mylen) / 2);
            fill2 = (width - mylen) % 2 ? fill1 + 1 : fill1;
          } else if (isRight) {
            fill1 = width - mylen;
            fill2 = 0;
          } else {
            fill1 = 0;
            fill2 = width - mylen;
          }
          final.fill(fillbyte, 0, fill1);
          for (let i = 0; i < mylen; i++) {
            final[i + fill1] = this.v[i];
          }
          final.fill(fillbyte, width - fill2);
          return new Sk.builtin.bytes(final);
        };
      }
      function isspace(val) {
        return val >= 9 && val <= 13 || val === 32;
      }
      function islower(val) {
        return val >= 97 && val <= 122;
      }
      function isupper(val) {
        return val >= 65 && val <= 90;
      }
      function isdigit(val) {
        return val >= 48 && val <= 57;
      }
      function checkSepMaxSplit(sep, maxsplit) {
        maxsplit = Sk.misceval.asIndexSized(maxsplit, Sk.builtin.OverflowError);
        maxsplit = maxsplit < 0 ? Infinity : maxsplit;
        sep = Sk.builtin.checkNone(sep) ? null : this.get$raw(sep);
        if (sep !== null && !sep.length) {
          throw new Sk.builtin.ValueError("empty separator");
        }
        return { sep, maxsplit };
      }
      function mkIsAll(passTest, passesZero) {
        return function isAll() {
          if (this.v.length === 0) {
            return passesZero ? Sk.builtin.bool.true$ : Sk.builtin.bool.false$;
          }
          return this.v.every((val) => passTest(val)) ? Sk.builtin.bool.true$ : Sk.builtin.bool.false$;
        };
      }
      function makeIsUpperLower(passTest, failTest) {
        return function() {
          let flag = false;
          for (let i = 0; i < this.v.length; i++) {
            if (failTest(this.v[i])) {
              return Sk.builtin.bool.false$;
            }
            if (!flag && passTest(this.v[i])) {
              flag = true;
            }
          }
          return flag ? Sk.builtin.bool.true$ : Sk.builtin.bool.false$;
        };
      }
      function mkCaseSwitch(switchCase) {
        return function lowerUpperSwapCase() {
          const final = new Uint8Array(this.v.length);
          for (let i = 0; i < this.v.length; i++) {
            final[i] = switchCase(this.v[i]);
          }
          return new Sk.builtin.bytes(final);
        };
      }
      function fromhex(string) {
        if (!Sk.builtin.checkString(string)) {
          throw new Sk.builtin.TypeError(
            "fromhex() argument must be str, not " + Sk.abstr.typeName(string)
          );
        }
        string = string.$jsstr();
        const spaces = /\s+/g;
        const ishex = /^[abcdefABCDEF0123456789]{2}$/;
        const final = [];
        let index = 0;
        function pushOrThrow(upto) {
          for (let i = index; i < upto; i += 2) {
            let s = string.substr(i, 2);
            if (!ishex.test(s)) {
              throw new Sk.builtin.ValueError(
                "non-hexadecimal number found in fromhex() arg at position " + (i + 1)
              );
            }
            final.push(parseInt(s, 16));
          }
        }
        let match;
        while ((match = spaces.exec(string)) !== null) {
          pushOrThrow(match.index);
          index = spaces.lastIndex;
        }
        pushOrThrow(string.length);
        return new this(final);
      }
      var bytes_iter_ = Sk.abstr.buildIteratorClass("bytes_iterator", {
        constructor: function bytes_iter_2(bytes) {
          this.$index = 0;
          this.$seq = bytes.v;
        },
        iternext() {
          const next = this.$seq[this.$index++];
          if (next === void 0) {
            return void 0;
          }
          return new Sk.builtin.int_(next);
        },
        methods: {
          __length_hint__: Sk.generic.iterLengthHintWithArrayMethodDef
        },
        flags: { sk$unacceptableBase: true }
      });
      var bytesToBytearray = function(bytes) {
        return new Sk.builtin.bytearray(bytes.v);
      };
      var bytesToString = function(bytes) {
        let num;
        let quote = "'";
        const hasdbl = bytes.v.indexOf(34) !== -1;
        let ret = "";
        for (let i = 0; i < bytes.v.length; i++) {
          num = bytes.v[i];
          if (num < 9 || num > 10 && num < 13 || num > 13 && num < 32 || num > 126) {
            ret += makehexform(num);
          } else if (num === 9 || num === 10 || num === 13 || num === 39 || num === 92) {
            switch (num) {
              case 9:
                ret += "\\t";
                break;
              case 10:
                ret += "\\n";
                break;
              case 13:
                ret += "\\r";
                break;
              case 39:
                if (hasdbl) {
                  ret += "\\'";
                } else {
                  ret += "'";
                  quote = '"';
                }
                break;
              case 92:
                ret += "\\\\";
                break;
            }
          } else {
            ret += String.fromCharCode(num);
          }
        }
        ret = "b" + quote + ret + quote;
        return new Sk.builtin.str(ret);
      };
      Sk.exportSymbol("Sk.builtin.bytes", Sk.builtin.bytes);
      Sk.exportSymbol("Sk.builtin.bytearray", Sk.builtin.bytearray);
    }
  });

  // src/tuple.js
  var require_tuple = __commonJS({
    "src/tuple.js"() {
      Sk.builtin.tuple = Sk.abstr.buildNativeClass("tuple", {
        constructor: function tuple(L) {
          if (L === void 0) {
            L = [];
          } else if (!Array.isArray(L)) {
            L = Sk.misceval.arrayFromIterable(L);
          }
          Sk.asserts.assert(
            this instanceof Sk.builtin.tuple,
            "bad call to tuple, use 'new' with an Array of python objects"
          );
          this.v = L;
          this.in$repr = false;
        },
        slots: (
          /**@lends {Sk.builtin.tuple.prototype}*/
          {
            tp$getattr: Sk.generic.getAttr,
            tp$as_sequence_or_mapping: true,
            tp$doc: "Built-in immutable sequence.\n\nIf no argument is given, the constructor returns an empty tuple.\nIf iterable is specified the tuple is initialized from iterable's items.\n\nIf the argument is a tuple, the return value is the same object.",
            $r() {
              if (this.in$repr) {
                return new Sk.builtin.str("(...)");
              }
              this.in$repr = true;
              let ret = this.v.map((x) => Sk.misceval.objectRepr(x));
              this.in$repr = false;
              ret = ret.join(", ");
              if (this.v.length === 1) {
                ret += ",";
              }
              return new Sk.builtin.str("(" + ret + ")");
            },
            /**
             * @param {Array} args
             * @param {Array=} kwargs
             * @ignore
             */
            tp$new(args, kwargs) {
              if (this !== Sk.builtin.tuple.prototype) {
                return this.$subtype_new(args, kwargs);
              }
              Sk.abstr.checkNoKwargs("tuple", kwargs);
              Sk.abstr.checkArgsLen("tuple", args, 0, 1);
              const arg = args[0];
              if (arg === void 0) {
                return new Sk.builtin.tuple([]);
              }
              if (arg.constructor === Sk.builtin.tuple) {
                return arg;
              }
              return Sk.misceval.chain(
                Sk.misceval.arrayFromIterable(arg, true),
                (L) => new Sk.builtin.tuple(L)
              );
            },
            tp$hash() {
              let y, x = 3430008, mult = 1000003;
              const len = this.v.length;
              for (let i = 0; i < len; ++i) {
                y = Sk.abstr.objectHash(this.v[i]);
                if (y === -1) {
                  return -1;
                }
                x = (x ^ y) * mult;
                mult += 82520 + len + len;
              }
              x += 97531;
              if (x === -1) {
                x = -2;
              }
              return x | 0;
            },
            tp$richcompare: Sk.generic.seqCompare,
            tp$iter() {
              return new tuple_iter_(this);
            },
            // sequence and mapping slots
            mp$subscript(index) {
              if (Sk.misceval.isIndex(index)) {
                let i = Sk.misceval.asIndexSized(index);
                if (i < 0) {
                  i = this.v.length + i;
                }
                if (i < 0 || i >= this.v.length) {
                  throw new Sk.builtin.IndexError("tuple index out of range");
                }
                return this.v[i];
              } else if (index instanceof Sk.builtin.slice) {
                const ret = [];
                index.sssiter$(this.v.length, (i) => {
                  ret.push(this.v[i]);
                });
                return new Sk.builtin.tuple(ret);
              }
              throw new Sk.builtin.TypeError(
                "tuple indices must be integers or slices, not " + Sk.abstr.typeName(index)
              );
            },
            sq$length() {
              return this.v.length;
            },
            sq$repeat(n) {
              n = Sk.misceval.asIndexSized(n, Sk.builtin.OverflowError);
              if (n === 1 && this.constructor === Sk.builtin.tuple) {
                return this;
              }
              const ret = [];
              for (let i = 0; i < n; i++) {
                for (let j = 0; j < this.v.length; j++) {
                  ret.push(this.v[j]);
                }
              }
              return new Sk.builtin.tuple(ret);
            },
            sq$concat(other) {
              if (!(other instanceof Sk.builtin.tuple)) {
                throw new Sk.builtin.TypeError(
                  "can only concatenate tuple (not '" + Sk.abstr.typeName(other) + "') to tuple"
                );
              }
              return new Sk.builtin.tuple(this.v.concat(other.v));
            },
            sq$contains(ob) {
              for (let it = this.tp$iter(), i = it.tp$iternext(); i !== void 0; i = it.tp$iternext()) {
                if (i === ob || Sk.misceval.richCompareBool(i, ob, "Eq")) {
                  return true;
                }
              }
              return false;
            }
          }
        ),
        proto: (
          /**@lends {Sk.builtin.tuple.prototype}*/
          {
            $subtype_new(args, kwargs) {
              const instance = new this.constructor();
              const tuple = Sk.builtin.tuple.prototype.tp$new(args);
              instance.v = tuple.v;
              return instance;
            },
            sk$asarray() {
              return this.v.slice(0);
            }
          }
        ),
        methods: (
          /**@lends {Sk.builtin.tuple.prototype}*/
          {
            __getnewargs__: {
              $meth() {
                return new Sk.builtin.tuple(this.v.slice(0));
              },
              $flags: { NoArgs: true },
              $textsig: "($self, /)",
              $doc: null
            },
            index: (
              /**@lends {Sk.builtin.type.prototype}*/
              {
                $meth(item, start, end) {
                  if (start !== void 0 && !Sk.misceval.isIndex(start) || end !== void 0 && !Sk.misceval.isIndex(end)) {
                    throw new Sk.builtin.TypeError(
                      "slice indices must be integers or have an __index__ method"
                    );
                  }
                  ({ start, end } = Sk.builtin.slice.startEnd$wrt(this, start, end));
                  const obj = this.v;
                  for (let i = start; i < end; i++) {
                    if (obj[i] === item || Sk.misceval.richCompareBool(obj[i], item, "Eq")) {
                      return new Sk.builtin.int_(i);
                    }
                  }
                  throw new Sk.builtin.ValueError("tuple.index(x): x not in tuple");
                },
                $flags: { MinArgs: 1, MaxArgs: 3 },
                $textsig: "($self, value, start=0, stop=sys.maxsize, /)",
                $doc: "Return first index of value.\n\nRaises ValueError if the value is not present."
              }
            ),
            count: {
              $meth(item) {
                const len = this.v.length;
                const obj = this.v;
                let count = 0;
                for (let i = 0; i < len; ++i) {
                  if (obj[i] === item || Sk.misceval.richCompareBool(obj[i], item, "Eq")) {
                    count += 1;
                  }
                }
                return new Sk.builtin.int_(count);
              },
              $flags: { OneArg: true },
              $textsig: "($self, value, /)",
              $doc: "Return number of occurrences of value."
            }
          }
        ),
        classmethods: Sk.generic.classGetItem
      });
      Sk.exportSymbol("Sk.builtin.tuple", Sk.builtin.tuple);
      var tuple_iter_ = Sk.abstr.buildIteratorClass("tuple_iterator", {
        constructor: function tuple_iter_2(tuple) {
          this.$index = 0;
          this.$seq = tuple.sk$asarray();
        },
        iternext: Sk.generic.iterNextWithArray,
        methods: {
          __length_hint__: Sk.generic.iterLengthHintWithArrayMethodDef
        },
        flags: { sk$unacceptableBase: true }
      });
    }
  });

  // src/dict.js
  var require_dict = __commonJS({
    "src/dict.js"() {
      Sk.builtin.dict = Sk.abstr.buildNativeClass("dict", {
        constructor: function dict(L) {
          if (L === void 0) {
            L = [];
          }
          Sk.asserts.assert(
            Array.isArray(L) && L.length % 2 === 0 && this instanceof Sk.builtin.dict,
            "bad call to dict constructor"
          );
          this.size = 0;
          this.entries = /* @__PURE__ */ Object.create(null);
          this.buckets = {};
          for (let i = 0; i < L.length; i += 2) {
            this.set$item(L[i], L[i + 1]);
          }
          this.in$repr = false;
          this.$version = 0;
        },
        slots: (
          /**@lends {Sk.builtin.dict.prototype}*/
          {
            tp$getattr: Sk.generic.getAttr,
            tp$as_sequence_or_mapping: true,
            tp$as_number: true,
            tp$hash: Sk.builtin.none.none$,
            tp$doc: "dict() -> new empty dictionary\ndict(mapping) -> new dictionary initialized from a mapping object's\n    (key, value) pairs\ndict(iterable) -> new dictionary initialized as if via:\n    d = {}\n    for k, v in iterable:\n        d[k] = v\ndict(**kwargs) -> new dictionary initialized with the name=value pairs\n    in the keyword argument list.  For example:  dict(one=1, two=2)",
            $r() {
              if (this.in$repr) {
                return new Sk.builtin.str("{...}");
              }
              this.in$repr = true;
              const ret = this.$items().map(
                ([key, val]) => Sk.misceval.objectRepr(key) + ": " + Sk.misceval.objectRepr(val)
              );
              this.in$repr = false;
              return new Sk.builtin.str("{" + ret.join(", ") + "}");
            },
            tp$new: Sk.generic.new,
            tp$init(args, kwargs) {
              return this.update$common(args, kwargs, "dict");
            },
            tp$iter() {
              return new dict_iter_(this);
            },
            tp$richcompare(other, op) {
              let res;
              if (!(other instanceof Sk.builtin.dict) || op !== "Eq" && op !== "NotEq") {
                return Sk.builtin.NotImplemented.NotImplemented$;
              }
              if (other === this) {
                res = true;
              } else if (this.size !== other.size) {
                res = false;
              } else {
                let otherv;
                res = this.$items().every(([key, val]) => {
                  otherv = other.mp$lookup(key);
                  return otherv !== void 0 && (otherv === val || Sk.misceval.richCompareBool(val, otherv, "Eq"));
                });
              }
              return op === "Eq" ? res : !res;
            },
            // as number slot
            nb$or(other) {
              if (!(other instanceof Sk.builtin.dict)) {
                return Sk.builtin.NotImplemented.NotImplemented$;
              }
              const dict = this.dict$copy();
              dict.dict$merge(other);
              return dict;
            },
            nb$reflected_or(other) {
              if (!(other instanceof Sk.builtin.dict)) {
                return Sk.builtin.NotImplemented.NotImplemented$;
              }
              const dict = other.dict$copy();
              dict.dict$merge(this);
              return dict;
            },
            nb$inplace_or(other) {
              return Sk.misceval.chain(this.update$onearg(other), () => this);
            },
            // sequence or mapping slots
            sq$length() {
              return this.get$size();
            },
            sq$contains(ob) {
              return this.mp$lookup(ob) !== void 0;
            },
            mp$subscript(key, canSuspend) {
              const res = this.mp$lookup(key);
              if (res !== void 0) {
                return res;
              }
              let missing = Sk.abstr.lookupSpecial(this, Sk.builtin.str.$missing);
              if (missing !== void 0) {
                const ret = Sk.misceval.callsimOrSuspendArray(missing, [key]);
                return canSuspend ? ret : Sk.misceval.retryOptionalSuspensionOrThrow(ret);
              }
              throw new Sk.builtin.KeyError(key);
            },
            mp$ass_subscript(key, value) {
              if (value === void 0) {
                const item = this.pop$item(key);
                if (item === void 0) {
                  throw new Sk.builtin.KeyError(key);
                }
              } else {
                this.set$item(key, value);
              }
            }
          }
        ),
        methods: (
          /**@lends {Sk.builtin.dict.prototype}*/
          {
            __reversed__: {
              $meth() {
                return new dict_reverse_iter_(this);
              },
              $flags: { NoArgs: true },
              $textsig: null,
              $doc: "Return a reverse iterator over the dict keys."
            },
            get: {
              $meth(key, d) {
                return this.mp$lookup(key) || d || Sk.builtin.none.none$;
              },
              $flags: { MinArgs: 1, MaxArgs: 2 },
              $textsig: "($self, key, default=None, /)",
              $doc: "Return the value for key if key is in the dictionary, else default."
            },
            setdefault: {
              $meth(key, default_) {
                let item;
                const hash = getHash(key);
                item = typeof hash === "string" ? this.entries[hash] : this.get$bucket_item(key, hash);
                if (item !== void 0) {
                  return item[1];
                }
                default_ = default_ || Sk.builtin.none.none$;
                if (typeof hash === "string") {
                  this.entries[hash] = [key, default_];
                } else {
                  this.set$bucket_item(key, default_, hash);
                }
                this.size++;
                this.$version++;
                return default_;
              },
              $flags: { MinArgs: 1, MaxArgs: 2 },
              $textsig: "($self, key, default=None, /)",
              $doc: "Insert key with a value of default if key is not in the dictionary.\n\nReturn the value for key if key is in the dictionary, else default."
            },
            pop: {
              $meth(key, d) {
                const item = this.pop$item(key);
                if (item !== void 0) {
                  return item[1];
                }
                if (d !== void 0) {
                  return d;
                }
                throw new Sk.builtin.KeyError(key);
              },
              $flags: { MinArgs: 1, MaxArgs: 2 },
              $textsig: null,
              $doc: "D.pop(k[,d]) -> v, remove specified key and return the corresponding value.\nIf key is not found, d is returned if given, otherwise KeyError is raised"
            },
            popitem: {
              $meth() {
                const size = this.get$size();
                if (size === 0) {
                  throw new Sk.builtin.KeyError("popitem(): dictionary is empty");
                }
                const [key, val] = this.$items()[size - 1];
                this.pop$item(key);
                return new Sk.builtin.tuple([key, val]);
              },
              $flags: { NoArgs: true },
              $textsig: null,
              $doc: "D.popitem() -> (k, v), remove and return some (key, value) pair as a\n2-tuple; but raise KeyError if D is empty."
            },
            keys: {
              $meth() {
                return new dict_keys(this);
              },
              $flags: { NoArgs: true },
              $textsig: null,
              $doc: "D.keys() -> a set-like object providing a view on D's keys"
            },
            items: {
              $meth() {
                return new dict_items(this);
              },
              $flags: { NoArgs: true },
              $textsig: null,
              $doc: "D.items() -> a set-like object providing a view on D's items"
            },
            values: {
              $meth() {
                return new dict_values(this);
              },
              $flags: { NoArgs: true },
              $textsig: null,
              $doc: "D.values() -> an object providing a view on D's values"
            },
            update: {
              $meth(args, kwargs) {
                return Sk.misceval.chain(
                  this.update$common(args, kwargs, "update"),
                  () => Sk.builtin.none.none$
                );
              },
              $flags: { FastCall: true },
              $textsig: null,
              $doc: "D.update([E, ]**F) -> None.  Update D from dict/iterable E and F.\nIf E is present and has a .keys() method, then does:  for k in E: D[k] = E[k]\nIf E is present and lacks a .keys() method, then does:  for k, v in E: D[k] = v\nIn either case, this is followed by: for k in F:  D[k] = F[k]"
            },
            clear: {
              $meth() {
                this.size = 0;
                this.$version++;
                this.entries = /* @__PURE__ */ Object.create(null);
                this.buckets = {};
              },
              $flags: { NoArgs: true },
              $textsig: null,
              $doc: "D.clear() -> None.  Remove all items from D."
            },
            copy: {
              $meth() {
                return this.dict$copy();
              },
              $flags: { NoArgs: true },
              $textsig: null,
              $doc: "D.copy() -> a shallow copy of D"
            }
          }
        ),
        classmethods: (
          /**@lends {Sk.builtin.dict.prototype}*/
          Object.assign(
            {
              fromkeys: {
                $meth: function fromkeys(seq, value) {
                  value = value || Sk.builtin.none.none$;
                  let dict = this === Sk.builtin.dict ? new this() : this.tp$call([], []);
                  return Sk.misceval.chain(
                    dict,
                    (d) => {
                      dict = d;
                      return Sk.misceval.iterFor(Sk.abstr.iter(seq), (key) => {
                        return dict.mp$ass_subscript(key, value, true);
                      });
                    },
                    () => dict
                  );
                },
                $flags: { MinArgs: 1, MaxArgs: 2 },
                $textsig: "($type, iterable, value=None, /)",
                $doc: "Create a new dictionary with keys from iterable and values set to value."
              }
            },
            Sk.generic.classGetItem
          )
        ),
        proto: (
          /**@lends {Sk.builtin.dict.prototype}*/
          {
            quick$lookup,
            mp$lookup,
            get$size() {
              return this.size;
            },
            sk$asarray() {
              return Object.values(this.entries).map((item) => item[0]);
            },
            update$common,
            update$onearg(arg) {
              if (arg instanceof Sk.builtin.dict || Sk.abstr.lookupSpecial(arg, Sk.builtin.str.$keys) !== void 0) {
                return this.dict$merge(arg);
              } else {
                return this.dict$merge_seq(arg);
              }
            },
            dict$copy() {
              const newCopy = new Sk.builtin.dict([]);
              newCopy.size = this.size;
              const entries = Object.entries(this.entries);
              for (let i in entries) {
                const key = entries[i][0];
                const item = entries[i][1];
                newCopy.entries[key] = [item[0], item[1]];
              }
              let bucket, this_bucket;
              for (let i in this.buckets) {
                this_bucket = this.buckets[i];
                newCopy.buckets[i] = bucket = [];
                for (let j = 0; j < this_bucket.length; j++) {
                  bucket.push(newCopy.entries["#" + i + "_" + j]);
                }
              }
              return newCopy;
            },
            $items() {
              return Object.values(this.entries);
            },
            set$item,
            get$bucket_item,
            pop$bucket_item,
            set$bucket_item,
            pop$item,
            dict$merge,
            dict$merge_seq
          }
        )
      });
      function getHash(key) {
        let key_hash = key.$savedKeyHash;
        if (key_hash !== void 0) {
          return key_hash;
        }
        key_hash = Sk.abstr.objectHash(key);
        return key_hash;
      }
      function quick$lookup(pyName) {
        var key_hash = pyName.$savedKeyHash;
        var item = this.entries[key_hash];
        if (item !== void 0) {
          return item[1];
        }
        return;
      }
      function get$bucket_item(key, hash_value) {
        const bucket = this.buckets[hash_value];
        if (bucket === void 0) {
          return;
        }
        let item;
        for (let i = 0; i < bucket.length; i++) {
          item = bucket[i];
          if (item === void 0) {
            continue;
          }
          if (item[0] === key || Sk.misceval.richCompareBool(key, item[0], "Eq")) {
            return item;
          }
        }
        return;
      }
      function pop$bucket_item(key, hash_value) {
        const bucket = this.buckets[hash_value];
        let bucket_key, item;
        if (bucket === void 0) {
          return void 0;
        }
        for (let i = 0; i < bucket.length; i++) {
          item = bucket[i];
          if (item === void 0) {
            continue;
          }
          if (item[0] === key || Sk.misceval.richCompareBool(key, item[0], "Eq")) {
            const key_hash = "#" + hash_value + "_" + i;
            delete this.entries[key_hash];
            bucket[i] = void 0;
            if (bucket.every((x) => x === void 0)) {
              delete this.buckets[hash_value];
            }
            return item;
          }
        }
        return;
      }
      function set$bucket_item(key, value, hash_value) {
        let key_hash, bucket = this.buckets[hash_value];
        const item = [key, value];
        if (bucket === void 0) {
          this.buckets[hash_value] = [item];
          key_hash = "#" + hash_value + "_0";
        } else {
          const free_slot_idx = bucket.indexOf(void 0);
          if (free_slot_idx !== -1) {
            key_hash = "#" + hash_value + "_" + free_slot_idx;
            bucket[free_slot_idx] = item;
          } else {
            key_hash = "#" + hash_value + "_" + bucket.length;
            bucket.push(item);
          }
        }
        this.entries[key_hash] = item;
      }
      function mp$lookup(key) {
        let item;
        const hash = getHash(key);
        if (typeof hash === "string") {
          item = this.entries[hash];
        } else {
          item = this.get$bucket_item(key, hash);
        }
        if (item !== void 0) {
          return item[1];
        }
        return void 0;
      }
      function dict$merge(b) {
        if (b.tp$iter === Sk.builtin.dict.prototype.tp$iter) {
          const keys = b.tp$iter();
          for (let key = keys.tp$iternext(); key !== void 0; key = keys.tp$iternext()) {
            const v = b.mp$subscript(key);
            this.set$item(key, v);
          }
        } else {
          const keyfunc = Sk.abstr.lookupSpecial(b, Sk.builtin.str.$keys);
          if (keyfunc === void 0) {
            throw new Sk.builtin.TypeError(
              "'" + Sk.abstr.typeName(b) + "' object is not a mapping"
            );
          }
          return Sk.misceval.chain(
            Sk.misceval.callsimOrSuspendArray(keyfunc),
            (keys) => Sk.misceval.iterFor(
              Sk.abstr.iter(keys),
              (key) => Sk.misceval.chain(Sk.abstr.objectGetItem(b, key, true), (v) => {
                this.set$item(key, v);
              })
            )
          );
        }
      }
      function update$common(args, kwargs, func_name) {
        Sk.abstr.checkArgsLen(func_name, args, 0, 1);
        const arg = args[0];
        let ret;
        if (arg !== void 0) {
          ret = this.update$onearg(arg);
        }
        return Sk.misceval.chain(ret, () => {
          if (kwargs) {
            for (let i = 0; i < kwargs.length; i += 2) {
              this.set$item(new Sk.builtin.str(kwargs[i]), kwargs[i + 1]);
            }
          }
          return;
        });
      }
      function dict$merge_seq(arg) {
        let idx = 0;
        return Sk.misceval.iterFor(Sk.abstr.iter(arg), (i) => {
          if (!Sk.builtin.checkIterable(i)) {
            throw new Sk.builtin.TypeError(
              "cannot convert dictionary update sequence element #" + idx + " to a sequence"
            );
          }
          const seq = Sk.misceval.arrayFromIterable(i);
          if (seq.length !== 2) {
            throw new Sk.builtin.ValueError(
              "dictionary update sequence element #" + idx + " has length " + seq.length + "; 2 is required"
            );
          }
          this.set$item(seq[0], seq[1]);
          idx++;
        });
      }
      function set$item(key, value) {
        const hash = getHash(key);
        let item;
        if (typeof hash === "string") {
          item = this.entries[hash];
          if (item === void 0) {
            this.entries[hash] = [key, value];
            this.size++;
            this.$version++;
          } else {
            item[1] = value;
          }
        } else {
          item = this.get$bucket_item(key, hash);
          if (item === void 0) {
            this.set$bucket_item(key, value, hash);
            this.size++;
            this.$version++;
          } else {
            item[1] = value;
          }
        }
      }
      function pop$item(key) {
        const hash = getHash(key);
        let item;
        if (typeof hash === "string") {
          item = this.entries[hash];
          delete this.entries[hash];
        } else {
          item = this.pop$bucket_item(key, hash);
        }
        if (item !== void 0) {
          this.size--;
          this.$version++;
          return item;
        }
        return void 0;
      }
      function as_set(self2) {
        return new Sk.builtin.set(Sk.misceval.arrayFromIterable(self2));
      }
      function checkAnyView(view) {
        return view instanceof dict_keys || view instanceof dict_items;
      }
      function all_contained_in(self2, other) {
        for (let it = Sk.abstr.iter(self2), i = it.tp$iternext(); i !== void 0; i = it.tp$iternext()) {
          if (!Sk.abstr.sequenceContains(other, i)) {
            return false;
          }
        }
        return true;
      }
      var dict_view_slots = {
        tp$getattr: Sk.generic.getAttr,
        tp$as_number: true,
        tp$as_sequence_or_mapping: true,
        tp$hash: Sk.builtin.none.none$,
        $r() {
          if (this.in$repr) {
            return new Sk.builtin.str("...");
          }
          this.in$repr = true;
          let ret = Sk.misceval.arrayFromIterable(this);
          ret = ret.map((x) => Sk.misceval.objectRepr(x));
          this.in$repr = false;
          return new Sk.builtin.str(Sk.abstr.typeName(this) + "([" + ret.join(", ") + "])");
        },
        tp$richcompare(other, op) {
          if (!(Sk.builtin.checkAnySet(other) || checkAnyView(other))) {
            return Sk.builtin.NotImplemented.NotImplemented$;
          }
          const len_self = this.sq$length();
          const len_other = other.sq$length();
          switch (op) {
            case "NotEq":
            case "Eq":
              let res;
              if (this === other) {
                res = true;
              } else if (len_self === len_other) {
                res = all_contained_in(this, other);
              }
              return op === "NotEq" ? !res : res;
            case "Lt":
              return len_self < len_other && all_contained_in(this, other);
            case "LtE":
              return len_self <= len_other && all_contained_in(this, other);
            case "Gt":
              return len_self > len_other && all_contained_in(other, this);
            case "GtE":
              return len_self >= len_other && all_contained_in(other, this);
          }
        },
        nb$subtract(other) {
          const set = as_set(this);
          return set.difference.$meth.call(set, other);
        },
        nb$and(other) {
          const set = as_set(this);
          return set.intersection.$meth.call(set, other);
        },
        nb$or(other) {
          const set = as_set(this);
          return set.union.$meth.call(set, other);
        },
        nb$xor(other) {
          const set = as_set(this);
          return set.symmetric_difference.$meth.call(set, other);
        },
        sq$length() {
          return this.dict.get$size();
        }
      };
      function buildDictView(typename, slots, reverse_method) {
        const options = {
          constructor: function dict_view(dict) {
            if (arguments.length !== 1) {
              throw new Sk.builtin.TypeError(
                "cannot create '" + Sk.abstr.typeName(this) + "' instances"
              );
            }
            this.dict = dict;
            this.in$repr = false;
          }
        };
        options.slots = Object.assign(slots, dict_view_slots);
        options.methods = {
          isdisjoint: {
            $meth(other) {
              const set = as_set(this);
              return set.isdisjoint.$meth.call(set, other);
            },
            $flags: { OneArg: true },
            $textsig: null,
            $doc: "Return True if the view and the given iterable have a null intersection."
          },
          __reversed__: {
            $meth: reverse_method,
            $flags: { NoArgs: true },
            $textsig: null,
            $doc: "Return a reverse iterator over the dict keys."
          }
        };
        options.flags = {
          sk$acceptable_as_base: false
        };
        if (typename === "dict_values") {
          delete options.slots.tp$as_number;
          delete options.slots.tp$richcompare;
        }
        return Sk.abstr.buildNativeClass(typename, options);
      }
      var dict_keys = buildDictView(
        "dict_keys",
        {
          sq$contains(key) {
            return this.dict.mp$lookup(key) !== void 0;
          },
          tp$iter() {
            return new dict_iter_(this.dict);
          }
        },
        function __reverse__() {
          return new dict_reverse_iter_(this.dict);
        }
      );
      var dict_values = buildDictView(
        "dict_values",
        {
          tp$iter() {
            return new dict_valueiter_(this.dict);
          }
        },
        function __reverse__() {
          return new dict_reverse_valueiter_(this.dict);
        }
      );
      var dict_items = buildDictView(
        "dict_items",
        {
          sq$contains(item) {
            if (!(item instanceof Sk.builtin.tuple && item.sq$length() === 2)) {
              return false;
            }
            const key = item.mp$subscript(new Sk.builtin.int_(0));
            const value = item.mp$subscript(new Sk.builtin.int_(1));
            const found = this.dict.mp$lookup(key);
            if (found === void 0) {
              return false;
            }
            return found === value || Sk.misceval.richCompareBool(found, value, "Eq");
          },
          tp$iter() {
            return new dict_itemiter_(this.dict);
          }
        },
        function __reverse__() {
          return new dict_reverse_itemiter_(this.dict);
        }
      );
      function buildDictIterClass(typename, iternext, reversed) {
        return Sk.abstr.buildIteratorClass(typename, {
          constructor: function dict_iter_constructor(dict) {
            this.$index = 0;
            this.$orig = dict;
            this.tp$iternext = () => {
              this.$seq = dict.$items();
              this.$version = dict.$version;
              if (reversed) {
                this.$seq = this.$seq.reverse();
              }
              this.tp$iternext = this.constructor.prototype.tp$iternext;
              return this.tp$iternext();
            };
          },
          iternext,
          methods: {
            __length_hint__: Sk.generic.iterLengthHintWithArrayMethodDef
          },
          flags: { sk$unacceptableBase: true },
          proto: { next$item: itemIterNextCheckSize }
        });
      }
      function itemIterNextCheckSize() {
        if (this.$version !== this.$orig.$version) {
          if (this.$seq.length !== this.$orig.get$size()) {
            throw new Sk.builtin.RuntimeError("dict changed size during iteration");
          }
          throw new Sk.builtin.RuntimeError("dictionary keys changed during iteration");
        }
        return this.$seq[this.$index++];
      }
      var dict_iter_ = buildDictIterClass("dict_keyiterator", function() {
        const item = this.next$item();
        return item && item[0];
      });
      var dict_itemiter_ = buildDictIterClass("dict_itemiterator", function() {
        const item = this.next$item();
        return item && new Sk.builtin.tuple([item[0], item[1]]);
      });
      var dict_valueiter_ = buildDictIterClass("dict_valueiterator", function() {
        const item = this.next$item();
        return item && item[1];
      });
      var dict_reverse_iter_ = buildDictIterClass(
        "dict_reversekeyiterator",
        dict_iter_.prototype.tp$iternext,
        true
      );
      var dict_reverse_itemiter_ = buildDictIterClass(
        "dict_reverseitemiterator",
        dict_itemiter_.prototype.tp$iternext,
        true
      );
      var dict_reverse_valueiter_ = buildDictIterClass(
        "dict_reversevalueiterator",
        dict_valueiter_.prototype.tp$iternext,
        true
      );
      Sk.builtin.dict.py2$methods = {
        has_key: {
          $name: "has_key",
          $flags: { OneArg: true },
          $meth(k) {
            return new Sk.builtin.bool(this.sq$contains(k));
          },
          $doc: "D.has_key(k) -> True if D has a key k, else False"
        },
        keys: {
          $name: "keys",
          $meth() {
            return new Sk.builtin.list(this.sk$asarray());
          },
          $flags: { NoArgs: true },
          $textsig: null,
          $doc: "D.keys() -> a set-like object providing a view on D's keys"
        },
        items: {
          $name: "items",
          $meth() {
            return new Sk.builtin.list(
              this.$items().map(([key, val]) => new Sk.builtin.tuple([key, val]))
            );
          },
          $flags: { NoArgs: true },
          $textsig: null,
          $doc: "D.items() -> a set-like object providing a view on D's items"
        },
        values: {
          $name: "values",
          $meth() {
            return new Sk.builtin.list(this.$items().map(([_, val]) => val));
          },
          $flags: { NoArgs: true },
          $textsig: null,
          $doc: "D.values() -> an object providing a view on D's values"
        }
      };
    }
  });

  // src/dictviews.js
  var require_dictviews = __commonJS({
    "src/dictviews.js"() {
      var dict$views = {
        KEYS: "dict_keys",
        VALUES: "dict_values",
        ITEMS: "dict_items"
      };
      function buildDictView(typename) {
        const dict_view_options = {};
        dict_view_options.constructor = function(dict) {
          this.dict = dict;
        };
        dict_view_options.slots = {
          tp$getattr: Sk.generic.getAttr,
          tp$as_number: true,
          tp$as_sequence_or_mapping: true,
          tp$hash: Sk.builtin.none.none$,
          $r: function() {
            if (this.$entered_repr !== void 0) {
              return new Sk.builtin.str("...");
            }
            this.$entered_repr = true;
            const L = Sk.misceval.arrayFromIterable(this);
            const res = Sk.misceval.objectRepr(new Sk.builtin.list(L));
            this.$entered_repr = void 0;
            return new Sk.builtin.str(Sk.abstr.typeName(this) + "(" + res + ")");
          },
          tp$richcompare: function() {
            return Sk.builtin.NotImplemented.NotImplemented$;
          },
          tp$iter: function() {
            if (this.tp$name === dict$views.KEYS) {
              return new Sk.builtin.dict_iter_(this.dict);
            } else if (this.tp$name === dict$views.VALUES) {
              return new Sk.builtin.dict_valueiter_(this.dict);
            } else if (this.tp$name === dict$views.ITEMS) {
              return new Sk.builtin.dict_itemiter_(this.dict);
            }
          },
          nb$subtract: function() {
            return Sk.builtin.NotImplemented.NotImplemented$;
          },
          nb$and: function() {
            return Sk.builtin.NotImplemented.NotImplemented$;
          },
          nb$or: function() {
            return Sk.builtin.NotImplemented.NotImplemented$;
          },
          nb$xor: function() {
            return Sk.builtin.NotImplemented.NotImplemented$;
          },
          sq$length: function() {
            return this.dict.get$size();
          },
          sq$contains: function(item) {
            var iter, key, value, pair;
            if (this.tp$name === dict$views.KEYS) {
              return this.dict.mp$lookup(item) !== void 0;
            } else if (this.tp$name === dict$views.VALUES) {
              for (iter = Sk.abstr.iter(this.dict), key = iter.tp$iternext(); key !== void 0; key = iter.tp$iternext()) {
                value = this.dict.mp$subscript(key);
                if (value === void 0) {
                  value = null;
                }
                if (Sk.misceval.isTrue(Sk.misceval.richCompareBool(value, item, "Eq"))) {
                  return true;
                }
              }
              return false;
            } else if (this.tp$name === dict$views.ITEMS) {
              if (item.mp$subscript && item.sq$length && item.sq$length() === 2) {
                key = item.mp$subscript(new Sk.builtin.int_(0));
                value = this.dict.mp$lookup(key);
                if (value !== void 0) {
                  pair = new Sk.builtin.tuple([key, value]);
                  if (Sk.misceval.isTrue(Sk.misceval.richCompareBool(pair, item, "Eq"))) {
                    return true;
                  }
                }
              }
              return false;
            }
          }
        };
        dict_view_options.methods = {
          isdisjoint: {
            $meth: function() {
              return Sk.builtin.NotImplemented.NotImplemented$;
            },
            $flags: {},
            $textsig: null,
            $doc: "Return True if the view and the given iterable have a null intersection."
          },
          __reversed__: {
            $meth: function() {
              if (this.tp$name === dict$views.KEYS) {
                return new Sk.builtin.dict_reverse_iter_(this.dict);
              } else if (this.tp$name === dict$views.ITEMS) {
                return new Sk.builtin.dict_reverse_itemiter_(this.dict);
              } else if (this.tp$name === dict$views.VALUES) {
                return new Sk.builtin.dict_reverse_valueiter_(this.dict);
              }
            },
            $flags: { NoArgs: true },
            $textsig: null,
            $doc: "Return a reverse iterator over the dict keys."
          }
        };
        dict_view_options.flags = {
          sk$acceptable_as_base: false
        };
        return Sk.abstr.buildNativeClass(typename, dict_view_options);
      }
      Sk.builtin.dict_keys = buildDictView("dict_keys");
      Sk.builtin.dict_values = buildDictView("dict_values");
      Sk.builtin.dict_items = buildDictView("dict_items");
      function dict_iter_constructor(dict) {
        this.$index = 0;
        this.$seq = dict.sk$asarray();
        this.$orig = dict;
      }
      function buildDictIterClass(typename, iternext, constructor) {
        return Sk.abstr.buildIteratorClass(typename, {
          constructor: constructor || function(dict) {
            dict_iter_constructor.call(this, dict);
          },
          iternext,
          methods: {
            __length_hint__: Sk.generic.iterLengthHintWithArrayMethodDef
          },
          flags: { sk$acceptable_as_base_class: false }
        });
      }
      Sk.builtin.dict_iter_ = buildDictIterClass(
        "dict_keyiterator",
        Sk.generic.iterNextWithArrayCheckSize
      );
      function dict_iter_get_value_or_throw() {
        const key = Sk.generic.iterNextWithArrayCheckSize.call(this);
        if (key === void 0) {
          return key;
        }
        const res = this.$orig.mp$lookup(key);
        if (res !== void 0) {
          return res;
        }
        throw new Sk.builtin.RuntimeError(Sk.misceval.objectRepr(key) + " removed during iteration");
      }
      Sk.builtin.dict_valueiter_ = buildDictIterClass("dict_valueiterator", function() {
        return dict_iter_get_value_or_throw.call(this);
      });
      Sk.builtin.dict_itemiter_ = buildDictIterClass("dict_itemiterator", function __next__() {
        const idx = this.$index;
        const val = dict_iter_get_value_or_throw.call(this);
        if (val === void 0) {
          return val;
        }
        return new Sk.builtin.tuple([this.$seq[idx], val]);
      });
      function dict_reverse_iter_constructor(dict) {
        dict_iter_constructor.call(this, dict);
        this.$seq.reverse();
      }
      Sk.builtin.dict_reverse_iter_ = buildDictIterClass(
        "dict_reversekeyiterator",
        Sk.generic.iterNextWithArrayCheckSize,
        function(dict) {
          dict_reverse_iter_constructor.call(this, dict);
        }
      );
      Sk.builtin.dict_reverse_itemiter_ = buildDictIterClass(
        "dict_reverseitemiterator",
        Sk.builtin.dict_itemiter_.prototype.tp$iternext,
        function(dict) {
          dict_reverse_iter_constructor.call(this, dict);
        }
      );
      Sk.builtin.dict_reverse_valueiter_ = buildDictIterClass(
        "dict_reversevalueiterator",
        Sk.builtin.dict_valueiter_.prototype.tp$iternext,
        function(dict) {
          dict_reverse_iter_constructor.call(this, dict);
        }
      );
    }
  });

  // src/mappingproxy.js
  var require_mappingproxy = __commonJS({
    "src/mappingproxy.js"() {
      Sk.builtin.mappingproxy = Sk.abstr.buildNativeClass("mappingproxy", {
        constructor: function mappingproxy(d) {
          Sk.asserts.assert(
            this instanceof Sk.builtin.mappingproxy,
            "bad call to mapping proxy, use 'new'"
          );
          this.mapping = new Sk.builtin.dict([]);
          if (d !== void 0) {
            customEntriesGetter(this.mapping, d);
          }
        },
        slots: {
          tp$getattr: Sk.generic.getAttr,
          tp$as_sequence_or_mapping: true,
          tp$hash: Sk.builtin.none.none$,
          tp$new(args, kwargs) {
            Sk.abstr.checkNoKwargs("mappingproxy", kwargs);
            Sk.abstr.checkOneArg("mappingproxy", args, kwargs);
            const mapping = args[0];
            if (!Sk.builtin.checkMapping(mapping)) {
              throw new Sk.builtin.TypeError(
                "mappingproxy() argument must be a mapping, not " + Sk.abstr.typeName(mapping)
              );
            }
            const mp = new Sk.builtin.mappingproxy();
            mp.mapping = mapping;
            return mp;
          },
          tp$richcompare(other, op) {
            return Sk.misceval.richCompareBool(this.mapping, other, op);
          },
          tp$str() {
            return this.mapping.tp$str();
          },
          $r() {
            return new Sk.builtin.str("mappingproxy(" + Sk.misceval.objectRepr(this.mapping) + ")");
          },
          mp$subscript(key, canSuspend) {
            return this.mapping.mp$subscript(key, canSuspend);
          },
          sq$contains(key) {
            return this.mapping.sq$contains(key);
          },
          sq$length() {
            return this.mapping.sq$length();
          },
          tp$iter() {
            return this.mapping.tp$iter();
          },
          tp$as_number: true,
          nb$or(other) {
            if (other instanceof Sk.builtin.mappingproxy) {
              other = other.mapping;
            }
            return Sk.abstr.numberBinOp(this.mapping, other, "BitOr");
          },
          nb$reflected_or(other) {
            if (other instanceof Sk.builtin.mappingproxy) {
              other = other.mapping;
            }
            return Sk.abstr.numberBinOp(other, this.mapping, "BitOr");
          },
          nb$inplace_or(other) {
            throw new Sk.builtin.TypeError(
              "'|=' is not supported by " + Sk.abstr.typeName(this) + "; use '|' instead"
            );
          }
        },
        methods: {
          get: {
            $meth(args, kwargs) {
              return Sk.misceval.callsimArray(
                this.mapping.tp$getattr(this.str$get),
                args,
                kwargs
              );
            },
            $flags: { FastCall: true },
            $textsig: null,
            $doc: "D.get(k[,d]) -> D[k] if k in D, else d.  d defaults to None."
          },
          keys: {
            $meth() {
              return Sk.misceval.callsimArray(this.mapping.tp$getattr(this.str$keys), []);
            },
            $flags: { NoArgs: true },
            $textsig: null,
            $doc: "D.keys() -> a set-like object providing a view on D's keys"
          },
          items: {
            $meth() {
              return Sk.misceval.callsimArray(this.mapping.tp$getattr(this.str$items), []);
            },
            $flags: { NoArgs: true },
            $textsig: null,
            $doc: "D.items() -> a set-like object providing a view on D's items"
          },
          values: {
            $meth() {
              return Sk.misceval.callsimArray(this.mapping.tp$getattr(this.str$values), []);
            },
            $flags: { NoArgs: true },
            $textsig: null,
            $doc: "D.values() -> a set-like object providing a view on D's values"
          },
          copy: {
            $meth() {
              return Sk.misceval.callsimArray(this.mapping.tp$getattr(this.str$copy), []);
            },
            $flags: { NoArgs: true },
            $textsig: null,
            $doc: "D.copy() -> a shallow copy of D"
          }
        },
        classmethods: Sk.generic.classGetItem,
        proto: {
          str$get: new Sk.builtin.str("get"),
          str$copy: new Sk.builtin.str("copy"),
          str$keys: new Sk.builtin.str("keys"),
          str$items: new Sk.builtin.str("items"),
          str$values: new Sk.builtin.str("values"),
          mp$lookup(key) {
            return this.mapping.mp$lookup(key);
          }
        },
        flags: {
          sk$unacceptableBase: true
        }
      });
      function customEntriesGetter(mapping, d) {
        Object.defineProperties(mapping, {
          entries: {
            get: () => {
              const entries = /* @__PURE__ */ Object.create(null);
              Object.entries(d).forEach(([key, val]) => {
                key = Sk.unfixReserved(key);
                if (!key.includes("$")) {
                  key = new Sk.builtin.str(key);
                  entries[key.$savedKeyHash] = [key, val];
                }
              });
              return entries;
            },
            configurable: true
          },
          size: {
            get: () => {
              return Object.keys(d).map((k) => Sk.unfixReserved(k)).filter((k) => !k.includes("$")).length;
            },
            configurable: true
          }
        });
      }
    }
  });

  // src/property_class_static.js
  var require_property_class_static = __commonJS({
    "src/property_class_static.js"() {
      Sk.builtin.property = Sk.abstr.buildNativeClass("property", {
        constructor: function property(fget, fset, fdel, doc) {
          this.prop$get = fget || Sk.builtin.none.none$;
          this.prop$set = fset || Sk.builtin.none.none$;
          this.prop$del = fdel || Sk.builtin.none.none$;
          this.prop$doc = doc || fget && fget.$doc || Sk.builtin.none.none$;
        },
        slots: {
          tp$getattr: Sk.generic.getAttr,
          tp$new: Sk.generic.new,
          tp$init(args, kwargs) {
            args = Sk.abstr.copyKeywordsToNamedArgs(
              "property",
              ["fget", "fset", "fdel", "doc"],
              args,
              kwargs,
              new Array(4).fill(Sk.builtin.none.none$)
            );
            this.prop$get = args[0];
            this.prop$set = args[1];
            this.prop$del = args[2];
            if (Sk.builtin.checkNone(args[3])) {
              if (!Sk.builtin.checkNone(args[0])) {
                this.prop$doc = args[0].$doc || args[3];
              }
            } else {
              this.prop$doc = args[3];
            }
          },
          tp$doc: "Property attribute.\n\n  fget\n    function to be used for getting an attribute value\n  fset\n    function to be used for setting an attribute value\n  fdel\n    function to be used for del'ing an attribute\n  doc\n    docstring\n\nTypical use is to define a managed attribute x:\n\nclass C(object):\n    def getx(self): return self._x\n    def setx(self, value): self._x = value\n    def delx(self): del self._x\n    x = property(getx, setx, delx, 'I'm the 'x' property.')\n\nDecorators make defining new properties or modifying existing ones easy:\n\nclass C(object):\n    @property\n    def x(self):\n        'I am the 'x' property.'\n        return self._x\n    @x.setter\n    def x(self, value):\n        self._x = value\n    @x.deleter\n    def x(self):\n        del self._x",
          tp$descr_get(obj, type) {
            if (obj === null) {
              return this;
            }
            if (this.prop$get === void 0) {
              throw new Sk.builtin.AttributeError("unreadable attribute");
            }
            return Sk.misceval.callsimOrSuspendArray(this.prop$get, [obj]);
          },
          tp$descr_set(obj, value) {
            let func;
            if (value == null) {
              func = this.prop$del;
            } else {
              func = this.prop$set;
            }
            if (Sk.builtin.checkNone(func)) {
              const msg = value == null ? "delete" : "set";
              throw new Sk.builtin.AttributeError("can't " + msg + " attribute");
            }
            if (!func.tp$call) {
              throw new Sk.builtin.TypeError("'" + Sk.abstr.typeName(func) + "' is not callable");
            }
            if (value == null) {
              return func.tp$call([obj]);
            } else {
              return func.tp$call([obj, value]);
            }
          }
        },
        methods: {
          getter: {
            $meth(fget) {
              return new Sk.builtin.property(fget, this.prop$set, this.prop$del, this.prop$doc);
            },
            $flags: { OneArg: true }
          },
          setter: {
            $meth(fset) {
              return new Sk.builtin.property(this.prop$get, fset, this.prop$del, this.prop$doc);
            },
            $flags: { OneArg: true }
          },
          deleter: {
            $meth(fdel) {
              return new Sk.builtin.property(this.prop$get, this.prop$set, fdel, this.prop$doc);
            },
            $flags: { OneArg: true }
          }
        },
        getsets: {
          fget: {
            $get() {
              return this.prop$get;
            }
          },
          fset: {
            $get() {
              return this.prop$set;
            }
          },
          fdel: {
            $get() {
              return this.prop$del;
            }
          },
          __doc__: {
            $get() {
              return this.prop$doc;
            },
            $set(value) {
              value = value || Sk.builtin.none.none$;
              this.prop$doc = value;
            }
          }
        }
      });
      Sk.builtin.classmethod = Sk.abstr.buildNativeClass("classmethod", {
        constructor: function classmethod(callable) {
          this.cm$callable = callable;
          this.$d = new Sk.builtin.dict();
        },
        slots: {
          tp$getattr: Sk.generic.getAttr,
          tp$new: Sk.generic.new,
          tp$init(args, kwargs) {
            Sk.abstr.checkNoKwargs("classmethod", kwargs);
            Sk.abstr.checkArgsLen("classmethod", args, 1, 1);
            this.cm$callable = args[0];
          },
          tp$doc: "classmethod(function) -> method\n\nConvert a function to be a class method.\n\nA class method receives the class as implicit first argument,\njust like an instance method receives the instance.\nTo declare a class method, use this idiom:\n\n  class C:\n      @classmethod\n      def f(cls, arg1, arg2, ...):\n          ...\n\nIt can be called either on the class (e.g. C.f()) or on an instance\n(e.g. C().f()).  The instance is ignored except for its class.\nIf a class method is called for a derived class, the derived class\nobject is passed as the implied first argument.\n\nClass methods are different than C++ or Java static methods.\nIf you want those, see the staticmethod builtin.",
          tp$descr_get(obj, type) {
            const callable = this.cm$callable;
            if (callable === void 0) {
              throw new Sk.builtin.RuntimeError("uninitialized classmethod object");
            }
            if (type === void 0) {
              type = obj.ob$type;
            }
            const f = callable.tp$descr_get;
            if (f) {
              return f.call(callable, type);
            }
            return new Sk.builtin.method(callable, type);
          }
        },
        getsets: {
          __func__: {
            $get() {
              return this.cm$callable;
            }
          },
          __dict__: Sk.generic.getSetDict
        }
      });
      Sk.builtin.staticmethod = Sk.abstr.buildNativeClass("staticmethod", {
        constructor: function staticmethod(callable) {
          this.sm$callable = callable;
          this.$d = new Sk.builtin.dict();
        },
        slots: {
          tp$getattr: Sk.generic.getAttr,
          tp$new: Sk.generic.new,
          tp$init(args, kwargs) {
            Sk.abstr.checkNoKwargs("staticmethod", kwargs);
            Sk.abstr.checkArgsLen("staticmethod", args, 1, 1);
            this.sm$callable = args[0];
          },
          tp$doc: "staticmethod(function) -> method\n\nConvert a function to be a static method.\n\nA static method does not receive an implicit first argument.\nTo declare a static method, use this idiom:\n\n     class C:\n         @staticmethod\n         def f(arg1, arg2, ...):\n             ...\n\nIt can be called either on the class (e.g. C.f()) or on an instance\n(e.g. C().f()).  The instance is ignored except for its class.\n\nStatic methods in Python are similar to those found in Java or C++.\nFor a more advanced concept, see the classmethod builtin.",
          tp$descr_get(obj, type) {
            if (this.sm$callable === void 0) {
              throw new Sk.builtin.RuntimeError("uninitialized staticmethod object");
            }
            return this.sm$callable;
          }
        },
        getsets: {
          __func__: {
            $get() {
              return this.sm$callable;
            }
          },
          __dict__: Sk.generic.getSetDict
        }
      });
    }
  });

  // src/int.js
  var require_int = __commonJS({
    "src/int.js"() {
      Sk.builtin.int_ = Sk.abstr.buildNativeClass("int", {
        constructor: function int_(x) {
          Sk.asserts.assert(this instanceof Sk.builtin.int_, "bad call to int use 'new'");
          let v;
          if (typeof x === "number" || JSBI.__isBigInt(x)) {
            v = x;
          } else if (x === void 0) {
            v = 0;
          } else if (typeof x === "string") {
            v = stringToNumberOrBig(x);
          } else if (x.nb$int) {
            return x.nb$int();
          } else {
            Sk.asserts.fail("bad argument to int constructor");
          }
          this.v = v;
        },
        slots: (
          /** @lends {Sk.builtin.int_.prototype}*/
          {
            tp$as_number: true,
            tp$doc: "int(x=0) -> integer\nint(x, base=10) -> integer\n\nConvert a number or string to an integer, or return 0 if no arguments\nare given.  If x is a number, return x.__int__().  For floating point\nnumbers, this truncates towards zero.\n\nIf x is not a number or if base is given, then x must be a string,\nbytes, or bytearray instance representing an integer literal in the\ngiven base.  The literal can be preceded by '+' or '-' and be surrounded\nby whitespace.  The base defaults to 10.  Valid bases are 0 and 2-36.\nBase 0 means to interpret the base from the string as an integer literal.\n>>> int('0b100', base=0)\n4",
            $r() {
              return new Sk.builtin.str(this.v.toString());
            },
            tp$hash() {
              const v = this.v;
              return typeof v === "number" ? v : JSBI.toNumber(JSBI.remainder(v, JSBI.__MAX_SAFE));
            },
            tp$new(args, kwargs) {
              let x, base;
              if (args.length + (kwargs ? kwargs.length : 0) === 1) {
                x = args[0];
                base = Sk.builtin.none.none$;
              } else {
                args = Sk.abstr.copyKeywordsToNamedArgs("int", [null, "base"], args, kwargs, [
                  new Sk.builtin.int_(0),
                  Sk.builtin.none.none$
                ]);
                x = args[0];
                base = args[1];
              }
              x = getInt(x, base);
              if (this === Sk.builtin.int_.prototype) {
                return x;
              } else {
                const instance = new this.constructor();
                instance.v = x.v;
                return instance;
              }
            },
            tp$getattr: Sk.generic.getAttr,
            ob$eq: compareSlot((v, w) => v == w, JSBI.equal),
            ob$ne: compareSlot((v, w) => v != w, JSBI.notEqual),
            ob$gt: compareSlot((v, w) => v > w, JSBI.greaterThan),
            ob$ge: compareSlot((v, w) => v >= w, JSBI.greaterThanOrEqual),
            ob$lt: compareSlot((v, w) => v < w, JSBI.lessThan),
            ob$le: compareSlot((v, w) => v <= w, JSBI.lessThanOrEqual),
            nb$int: cloneSelf,
            nb$index() {
              return this.v;
            },
            nb$float() {
              const v = this.v;
              if (typeof v === "number") {
                return new Sk.builtin.float_(v);
              } else {
                const x = parseFloat(JSBI.toNumber(v));
                if (x === Infinity || x === -Infinity) {
                  throw new Sk.builtin.OverflowError("int too large to convert to float");
                }
                return new Sk.builtin.float_(x);
              }
            },
            nb$isnegative() {
              const v = this.v;
              return typeof v === "number" ? v < 0 : JSBI.lessThan(v, JSBI.__ZERO);
            },
            nb$ispositive() {
              const v = this.v;
              return typeof v === "number" ? v >= 0 : JSBI.greaterThanOrEqual(v, JSBI.__ZERO);
            },
            nb$bool() {
              return this.v !== 0;
            },
            nb$positive: cloneSelf,
            nb$negative: numberUnarySlot((v) => -v, JSBI.unaryMinus),
            nb$add: numberSlot(
              (v, w) => v + w,
              (v, w) => JSBI.numberIfSafe(JSBI.add(v, w))
            ),
            nb$subtract: numberSlot(
              (v, w) => v - w,
              (v, w) => JSBI.numberIfSafe(JSBI.subtract(v, w))
            ),
            nb$multiply: numberSlot((v, w) => v * w, JSBI.multiply),
            nb$divide: trueDivide,
            nb$floor_divide: numberDivisionSlot((v, w) => Math.floor(v / w), BigIntFloorDivide),
            nb$remainder: numberDivisionSlot(
              (v, w) => v - Math.floor(v / w) * w,
              (v, w) => JSBI.subtract(v, JSBI.multiply(w, BigIntFloorDivide(v, w)))
            ),
            nb$divmod(other) {
              const floor = this.nb$floor_divide(other);
              const remainder = this.nb$remainder(other);
              if (floor === Sk.builtin.NotImplemented.NotImplemented$ || remainder === Sk.builtin.NotImplemented.NotImplemented$) {
                return Sk.builtin.NotImplemented.NotImplemented$;
              }
              return new Sk.builtin.tuple([floor, remainder]);
            },
            nb$and: numberBitSlot((v, w) => v & w, JSBI.bitwiseAnd),
            nb$or: numberBitSlot((v, w) => v | w, JSBI.bitwiseOr),
            nb$xor: numberBitSlot((v, w) => v ^ w, JSBI.bitwiseXor),
            nb$abs: numberUnarySlot(Math.abs, BigIntAbs),
            nb$lshift: numberShiftSlot((v, w) => {
              const tmp = v * 2 * shiftconsts[w];
              if (numberOrStringWithinThreshold(tmp)) {
                return tmp;
              }
              return void 0;
            }, JSBI.leftShift),
            nb$rshift: numberShiftSlot(
              (v, w) => {
                Math.floor(v / shiftconsts[w + 1]);
              },
              (v, w) => JSBI.numberIfSafe(JSBI.signedRightShift(v, w))
            ),
            nb$invert: numberUnarySlot(
              (v) => Math.abs(v) < __pow(2, 31) ? ~v : void 0,
              (v) => JSBI.numberIfSafe(JSBI.bitwiseNot(v))
            ),
            nb$power(other, mod) {
              let ret;
              if (mod === void 0) {
              } else if (Sk.builtin.checkNone(mod)) {
                mod = void 0;
              }
              if (!(other instanceof Sk.builtin.int_) || mod !== void 0 && !(mod instanceof Sk.builtin.int_)) {
                return Sk.builtin.NotImplemented.NotImplemented$;
              }
              const wNeg = other.nb$isnegative();
              if (wNeg && mod === void 0) {
                return this.nb$float().nb$power(other.nb$float());
              }
              let v = this.v;
              let w = other.v;
              if (typeof v === "number" && typeof w === "number") {
                const power = Math.pow(v, w);
                if (numberOrStringWithinThreshold(power)) {
                  ret = new Sk.builtin.int_(power);
                  if (mod === void 0) {
                    return ret;
                  }
                }
              }
              if (mod !== void 0) {
                if (wNeg) {
                  throw new Sk.builtin.ValueError(
                    "pow() 2nd argument cannot be negative when 3rd argument specified"
                  );
                } else if (mod.v === 0) {
                  throw new Sk.builtin.ValueError("pow() 3rd argument cannot be 0");
                }
                if (ret !== void 0) {
                  return ret.nb$remainder(mod);
                }
                return new Sk.builtin.int_(JSBI.powermod(bigUp(v), bigUp(w), bigUp(mod.v)));
              }
              return new Sk.builtin.int_(JSBI.exponentiate(bigUp(v), bigUp(w)));
            },
            nb$long() {
              return new Sk.builtin.lng(this.v);
            }
          }
        ),
        getsets: (
          /** @lends {Sk.builtin.int_.prototype}*/
          {
            real: {
              $get: cloneSelf,
              $doc: "the real part of a complex number"
            },
            imag: {
              $get() {
                return new Sk.builtin.int_(0);
              },
              $doc: "the imaginary part of a complex number"
            }
          }
        ),
        methods: (
          /** @lends {Sk.builtin.int_.prototype}*/
          {
            conjugate: {
              $meth: cloneSelf,
              $flags: { NoArgs: true },
              $textsig: null,
              $doc: "Returns self, the complex conjugate of any int."
            },
            bit_length: {
              $meth() {
                let v = this.v;
                if (v === 0) {
                  return new Sk.builtin.int_(0);
                }
                v = typeof v === "number" ? Math.abs(v) : BigIntAbs(v);
                return new Sk.builtin.int_(v.toString(2).length);
              },
              $flags: { NoArgs: true },
              $textsig: "($self, /)",
              $doc: "Number of bits necessary to represent self in binary.\n\n>>> bin(37)\n'0b100101'\n>>> (37).bit_length()\n6"
            },
            to_bytes: {
              $meth() {
                throw new Sk.builtin.NotImplementedError("Not yet implemented in Skulpt");
              },
              $flags: { FastCall: true },
              $textsig: "($self, /, length, byteorder, *, signed=False)",
              $doc: "Return an array of bytes representing an integer.\n\n  length\n    Length of bytes object to use.  An OverflowError is raised if the\n    integer is not representable with the given number of bytes.\n  byteorder\n    The byte order used to represent the integer.  If byteorder is 'big',\n    the most significant byte is at the beginning of the byte array.  If\n    byteorder is 'little', the most significant byte is at the end of the\n    byte array.  To request the native byte order of the host system, use\n    `sys.byteorder' as the byte order value.\n  signed\n    Determines whether two's complement is used to represent the integer.\n    If signed is False and a negative integer is given, an OverflowError\n    is raised."
            },
            __trunc__: {
              $meth: cloneSelf,
              $flags: { NoArgs: true },
              $textsig: null,
              $doc: "Truncating an Integral returns itself."
            },
            __floor__: {
              $meth: cloneSelf,
              $flags: { NoArgs: true },
              $textsig: null,
              $doc: "Flooring an Integral returns itself."
            },
            __ceil__: {
              $meth: cloneSelf,
              $flags: { NoArgs: true },
              $textsig: null,
              $doc: "Ceiling of an Integral returns itself."
            },
            __round__: {
              $meth(ndigits) {
                return this.round$(ndigits);
              },
              $flags: { MinArgs: 0, MaxArgs: 1 },
              $textsig: null,
              $doc: "Rounding an Integral returns itself.\nRounding with an ndigits argument also returns an integer."
            },
            __getnewargs__: {
              $meth() {
                return new Sk.builtin.tuple([new Sk.builtin.int_(this.v)]);
              },
              $flags: { NoArgs: true },
              $textsig: "($self, /)",
              $doc: Sk.builtin.none.none$
            },
            __format__: {
              $meth: Sk.formatting.mkNumber__format__(false),
              $flags: { OneArg: true },
              $textsig: "($self, format_spec, /)",
              $doc: Sk.builtin.none.none$
            }
          }
        ),
        proto: (
          /** @lends {Sk.builtin.int_.prototype}*/
          {
            str$(base, sign) {
              let tmp;
              if (base === void 0 || base === 10) {
                tmp = this.v.toString();
              } else {
                tmp = this.v.toString(base);
              }
              if (sign || sign === void 0) {
                return tmp;
              } else if (tmp[0] === "-") {
                tmp = tmp.substring(1);
              }
              return tmp;
            },
            round$(ndigits) {
              if (ndigits === void 0) {
                ndigits = 0;
              } else {
                ndigits = Sk.misceval.asIndexSized(ndigits);
              }
              const v = this.v;
              if (ndigits >= 0) {
                return new Sk.builtin.int_(v);
              }
              if (typeof v !== "number") {
                return BigIntRound(v, ndigits);
              }
              const multiplier = Math.pow(10, -ndigits);
              if (multiplier / 10 > Math.abs(v)) {
                return new Sk.builtin.int_(0);
              }
              if (!Sk.__future__.bankers_rounding) {
                return new Sk.builtin.int_(Math.round(v / multiplier) * multiplier);
              }
              const num10 = v / multiplier;
              const rounded = Math.round(num10);
              const bankRound = (num10 > 0 ? num10 : -num10) % 1 === 0.5 ? 0 === rounded % 2 ? rounded : rounded - 1 : rounded;
              const result = bankRound * multiplier;
              return new Sk.builtin.int_(result);
            },
            valueOf() {
              return this.v;
            },
            // flag to determine inheritance of ints without instanceof
            sk$int: true
          }
        )
      });
      Sk.exportSymbol("Sk.builtin.int_", Sk.builtin.int_);
      function numberSlot(number_func, bigint_func) {
        return function(other) {
          if (!(other instanceof Sk.builtin.int_)) {
            return Sk.builtin.NotImplemented.NotImplemented$;
          }
          let v = this.v;
          let w = other.v;
          if (typeof v === "number" && typeof w === "number") {
            const res = number_func(v, w);
            if (numberOrStringWithinThreshold(res)) {
              return new Sk.builtin.int_(res);
            }
          }
          v = bigUp(v);
          w = bigUp(w);
          return new Sk.builtin.int_(bigint_func(v, w));
        };
      }
      function compareSlot(number_func, bigint_func) {
        return function(other) {
          if (!(other instanceof Sk.builtin.int_)) {
            return Sk.builtin.NotImplemented.NotImplemented$;
          }
          let v = this.v;
          let w = other.v;
          if (typeof v === "number" && typeof w === "number") {
            return number_func(v, w);
          }
          v = bigUp(v);
          w = bigUp(w);
          return bigint_func(v, w);
        };
      }
      function numberUnarySlot(number_func, bigint_func) {
        function doUnarySlot() {
          let v = this.v;
          if (typeof v === "number") {
            const res = number_func(v);
            if (res !== void 0) {
              return new Sk.builtin.int_(res);
            }
            v = bigUp(v);
          }
          return new Sk.builtin.int_(bigint_func(v));
        }
        return doUnarySlot;
      }
      function cloneSelf() {
        return new Sk.builtin.int_(this.v);
      }
      var DBL_MANT_DIG = Math.log2(Number.MAX_SAFE_INTEGER);
      var DBL_MAX_EXP = JSBI.BigInt(Math.floor(Math.log2(Number.MAX_VALUE)));
      var DBL_MIN_EXP = Math.ceil(Math.log2(Number.MIN_VALUE));
      var BIG_2 = JSBI.BigInt(2);
      var BIG_1 = JSBI.BigInt(1);
      var DBL_MIN_OVERFLOW = JSBI.subtract(
        JSBI.exponentiate(BIG_2, DBL_MAX_EXP),
        JSBI.exponentiate(BIG_2, JSBI.subtract(DBL_MAX_EXP, JSBI.add(JSBI.BigInt(DBL_MANT_DIG), BIG_1)))
      );
      function trueDivide(other) {
        if (!Sk.__future__.python3) {
          return this.nb$floor_divide(other);
        }
        if (!(other instanceof Sk.builtin.int_)) {
          return Sk.builtin.NotImplemented.NotImplemented$;
        }
        let v = this.v;
        let w = other.v;
        if (w === 0) {
          throw new Sk.builtin.ZeroDivisionError("division by zero");
        }
        if (typeof v === "number" && typeof w === "number") {
          return new Sk.builtin.float_(v / w);
        }
        v = bigUp(v);
        w = bigUp(w);
        const negative = JSBI.lessThan(JSBI.bitwiseXor(v, w), JSBI.__ZERO);
        if (JSBI.equal(v, JSBI.__ZERO)) {
          return new Sk.builtin.float_(negative ? -0 : 0);
        }
        v = BigIntAbs(v);
        w = BigIntAbs(w);
        if (JSBI.greaterThanOrEqual(v, JSBI.multiply(DBL_MIN_OVERFLOW, w))) {
          throw new Sk.builtin.OverflowError("int/int too large to represent as a float");
        }
        let diff = v.toString(2).length - w.toString(2).length;
        const absBigDiff = JSBI.BigInt(diff < 0 ? -diff : diff);
        if (diff >= 0 && JSBI.greaterThanOrEqual(v, JSBI.multiply(JSBI.exponentiate(BIG_2, absBigDiff), w)) || diff < 0 && JSBI.greaterThanOrEqual(JSBI.multiply(v, JSBI.exponentiate(BIG_2, absBigDiff)), w)) {
          diff += 1;
        }
        const exp = Math.max(diff, DBL_MIN_EXP) - DBL_MANT_DIG;
        v = JSBI.leftShift(v, JSBI.BigInt(Math.max(-exp, 0)));
        w = JSBI.leftShift(w, JSBI.BigInt(Math.max(exp, 0)));
        let q = JSBI.divide(v, w);
        const r = JSBI.remainder(v, w);
        const doubleR = JSBI.multiply(BIG_2, r);
        if (JSBI.greaterThan(doubleR, w) || JSBI.equal(doubleR, w) && JSBI.equal(JSBI.remainder(q, BIG_2), BIG_1)) {
          q = JSBI.add(q, BIG_1);
        }
        q = JSBI.toNumber(q);
        if (q === Infinity || q === -Infinity) {
          throw new Sk.builtin.OverflowError("int/int too large to represent as a float");
        }
        let res = q * Math.pow(2, exp);
        res = negative ? -res : res;
        return new Sk.builtin.float_(res);
      }
      function numberDivisionSlot(number_func, bigint_func) {
        return function(other) {
          if (!(other instanceof Sk.builtin.int_)) {
            return Sk.builtin.NotImplemented.NotImplemented$;
          }
          let v = this.v;
          let w = other.v;
          if (w === 0) {
            throw new Sk.builtin.ZeroDivisionError("integer division or modulo by zero");
          }
          if (typeof v === "number" && typeof w === "number") {
            return new Sk.builtin.int_(number_func(v, w));
          }
          v = bigUp(v);
          w = bigUp(w);
          return new Sk.builtin.int_(JSBI.numberIfSafe(bigint_func(v, w)));
        };
      }
      function numberShiftSlot(number_func, bigint_func) {
        return function(other) {
          if (!(other instanceof Sk.builtin.int_)) {
            return Sk.builtin.NotImplemented.NotImplemented$;
          }
          const wNeg = other.nb$isnegative();
          if (wNeg) {
            throw new Sk.builtin.ValueError("negative shift count");
          }
          let v = this.v;
          if (v === 0) {
            return new Sk.builtin.int_(0);
          }
          let w = other.v;
          if (typeof v === "number" && typeof w === "number" && w < 53) {
            const ret = number_func(v, w);
            if (ret !== void 0) {
              return new Sk.builtin.int_(ret);
            }
          }
          v = bigUp(v);
          w = bigUp(w);
          return new Sk.builtin.int_(bigint_func(v, w));
        };
      }
      function numberBitSlot(number_func, bigint_func) {
        return function(other) {
          if (!(other instanceof Sk.builtin.int_)) {
            return Sk.builtin.NotImplemented.NotImplemented$;
          }
          let v = this.v;
          let w = other.v;
          if (typeof v === "number" && typeof w === "number" && Math.abs(v) < __pow(2, 31) && Math.abs(w) < __pow(2, 31)) {
            return new Sk.builtin.int_(number_func(v, w));
          }
          v = bigUp(v);
          w = bigUp(w);
          return new Sk.builtin.int_(JSBI.numberIfSafe(bigint_func(v, w)));
        };
      }
      function BigIntAbs(v) {
        return JSBI.lessThan(v, JSBI.__ZERO) ? JSBI.unaryMinus(v) : v;
      }
      function BigIntFloorDivide(v, w) {
        if (JSBI.greaterThanOrEqual(JSBI.bitwiseXor(v, w), JSBI.__ZERO)) {
          return JSBI.divide(v, w);
        }
        if (JSBI.lessThan(v, JSBI.__ZERO)) {
          v = JSBI.add(v, BIG_1);
        } else {
          v = JSBI.subtract(v, BIG_1);
        }
        return JSBI.subtract(JSBI.divide(v, w), BIG_1);
      }
      function BigIntRound(v, ndigits) {
        const isNeg = JSBI.lessThan(v, JSBI.__ZERO);
        if (isNeg) {
          v = JSBI.unaryMinus(v);
        }
        const BigMultiplier = JSBI.exponentiate(JSBI.BigInt(10), JSBI.unaryMinus(JSBI.BigInt(ndigits)));
        let result = JSBI.divide(v, BigMultiplier);
        const rem = JSBI.remainder(v, BigMultiplier);
        const doubleRem = JSBI.multiply(rem, BIG_2);
        if (JSBI.greaterThan(doubleRem, BigMultiplier)) {
          result = JSBI.add(result, BIG_1);
        } else if (JSBI.equal(doubleRem, BigMultiplier)) {
          if (!Sk.__future__.bankers_rounding) {
            result = JSBI.add(result, BIG_1);
          } else if (JSBI.equal(JSBI.remainder(result, BIG_2), BIG_1)) {
            result = JSBI.add(result, BIG_1);
          }
        }
        result = JSBI.multiply(result, BigMultiplier);
        if (isNeg) {
          result = JSBI.unaryMinus(result);
        }
        return new Sk.builtin.int_(result);
      }
      var validUnderscores = /_(?=[^_])/g;
      Sk.str2number = function(s, base) {
        var origs = s, neg = false, i, ch, val;
        s = s.replace(/^\s+|\s+$/g, "");
        if (s.charAt(0) === "-") {
          neg = true;
          s = s.substring(1);
        }
        if (s.charAt(0) === "+") {
          s = s.substring(1);
        }
        if (base === null || base === void 0) {
          base = 10;
        }
        if (base < 2 || base > 36) {
          if (base !== 0) {
            throw new Sk.builtin.ValueError("int() base must be >= 2 and <= 36");
          }
        }
        if (typeof base === "string") {
          base = Number(base);
        }
        if (s.substring(0, 2).toLowerCase() === "0x") {
          if (base === 16 || base === 0) {
            s = s.substring(2);
            base = 16;
          } else if (base < 34) {
            throw new Sk.builtin.ValueError(
              "invalid literal for int() with base " + base + ": '" + origs + "'"
            );
          }
        } else if (s.substring(0, 2).toLowerCase() === "0b") {
          if (base === 2 || base === 0) {
            s = s.substring(2);
            base = 2;
          } else if (base < 12) {
            throw new Sk.builtin.ValueError(
              "invalid literal for int() with base " + base + ": '" + origs + "'"
            );
          }
        } else if (s.substring(0, 2).toLowerCase() === "0o") {
          if (base === 8 || base === 0) {
            s = s.substring(2);
            base = 8;
          } else if (base < 25) {
            throw new Sk.builtin.ValueError(
              "invalid literal for int() with base " + base + ": '" + origs + "'"
            );
          }
        } else if (s.charAt(0) === "0") {
          if (s === "0") {
            return 0;
          }
          if (base === 8 || base === 0) {
            base = 8;
          }
        }
        if (base === 0) {
          base = 10;
        }
        if (s.indexOf("_") !== -1) {
          if (s.indexOf("__") !== -1) {
            throw new Sk.builtin.ValueError(
              "invalid literal for int() with base " + base + ": '" + origs + "'"
            );
          }
          if (base !== 10) {
            s = s.replace(validUnderscores, "");
          } else {
            s = s.charAt(0) + s.substring(1).replace(validUnderscores, "");
          }
        }
        if (s.length === 0) {
          throw new Sk.builtin.ValueError(
            "invalid literal for int() with base " + base + ": '" + origs + "'"
          );
        }
        for (i = 0; i < s.length; i = i + 1) {
          ch = s.charCodeAt(i);
          val = base;
          if (ch >= 48 && ch <= 57) {
            val = ch - 48;
          } else if (ch >= 65 && ch <= 90) {
            val = ch - 65 + 10;
          } else if (ch >= 97 && ch <= 122) {
            val = ch - 97 + 10;
          }
          if (val >= base) {
            throw new Sk.builtin.ValueError(
              "invalid literal for int() with base " + base + ": '" + origs + "'"
            );
          }
        }
        if (neg) {
          s = "-" + s;
        }
        val = parseInt(s, base);
        if (numberOrStringWithinThreshold(val)) {
          return val;
        }
        return fromStrToBigWithBase(s, base);
      };
      Sk.builtin.int_.py2$methods = {};
      Sk.longFromStr = function(s, base) {
        if (Sk.__future__.python3) {
          return new Sk.builtin.int_(stringToNumberOrBig(s));
        } else {
          const num = Sk.str2number(s, base);
          return new Sk.builtin.lng(num);
        }
      };
      Sk.exportSymbol("Sk.longFromStr", Sk.longFromStr);
      function numberOrStringWithinThreshold(v) {
        return v <= Number.MAX_SAFE_INTEGER && v >= -Number.MAX_SAFE_INTEGER;
      }
      Sk.builtin.int_.withinThreshold = numberOrStringWithinThreshold;
      function stringToNumberOrBig(s) {
        if (s <= Number.MAX_SAFE_INTEGER && s >= -Number.MAX_SAFE_INTEGER) {
          return +s;
        }
        return JSBI.BigInt(s);
      }
      Sk.builtin.int_.stringToNumberOrBig = stringToNumberOrBig;
      function bigUp(v) {
        if (typeof v === "number") {
          return JSBI.BigInt(v);
        }
        return v;
      }
      function getInt(x, base) {
        let func, res;
        if (base !== Sk.builtin.none.none$) {
          base = Sk.misceval.asIndexOrThrow(base);
        } else {
          base = null;
        }
        if (x instanceof Sk.builtin.str) {
          if (base === null) {
            base = 10;
          }
          return new Sk.builtin.int_(Sk.str2number(x.v, base));
        } else if (base !== null) {
          throw new Sk.builtin.TypeError("int() can't convert non-string with explicit base");
        } else if (x.nb$int !== void 0) {
          return x.nb$int();
        } else if (x.nb$index !== void 0) {
          return new Sk.builtin.int_(x.nb$index());
        }
        if (func = Sk.abstr.lookupSpecial(x, Sk.builtin.str.$trunc)) {
          res = Sk.misceval.callsimArray(func, []);
          if (!Sk.builtin.checkInt(res)) {
            throw new Sk.builtin.TypeError(
              Sk.builtin.str.$trunc.$jsstr() + " returned non-Integral (type " + Sk.abstr.typeName(x) + ")"
            );
          }
          return new Sk.builtin.int_(res.v);
        }
        throw new Sk.builtin.TypeError(
          "int() argument must be a string, a bytes-like object or a number, not '" + Sk.abstr.typeName(x) + "'"
        );
      }
      function fromStrToBigWithBase(s, base) {
        let neg = false;
        if (s[0] === "-") {
          neg = true;
          s = s.substring(1);
        }
        base = JSBI.BigInt(base);
        let power = BIG_1;
        let num = JSBI.__ZERO;
        let toadd, val;
        for (let i = s.length - 1; i >= 0; i--) {
          val = s.charCodeAt(i);
          if (val >= 48 && val <= 57) {
            val = val - 48;
          } else if (val >= 65 && val <= 90) {
            val = val - 65 + 10;
          } else if (val >= 97 && val <= 122) {
            val = val - 97 + 10;
          }
          toadd = JSBI.multiply(JSBI.BigInt(val), power);
          num = JSBI.add(num, toadd);
          power = JSBI.multiply(power, base);
        }
        if (neg) {
          num = JSBI.multiply(num, JSBI.BigInt(-1));
        }
        return num;
      }
      var shiftconsts = [
        0.5,
        1,
        2,
        4,
        8,
        16,
        32,
        64,
        128,
        256,
        512,
        1024,
        2048,
        4096,
        8192,
        16384,
        32768,
        65536,
        131072,
        262144,
        524288,
        1048576,
        2097152,
        4194304,
        8388608,
        16777216,
        33554432,
        67108864,
        134217728,
        268435456,
        536870912,
        1073741824,
        2147483648,
        4294967296,
        8589934592,
        17179869184,
        34359738368,
        68719476736,
        137438953472,
        274877906944,
        549755813888,
        1099511627776,
        2199023255552,
        4398046511104,
        8796093022208,
        17592186044416,
        35184372088832,
        70368744177664,
        140737488355328,
        281474976710656,
        562949953421312,
        1125899906842624,
        2251799813685248,
        4503599627370496,
        9007199254740992
      ];
      Sk.builtin.lng = Sk.abstr.buildNativeClass("long", {
        base: Sk.builtin.int_,
        // not technically correct but makes backward compatibility easy
        constructor: function lng(x) {
          Sk.builtin.int_.call(this, x);
        },
        slots: (
          /** @lends {Sk.builtin.lng.prototype} */
          {
            $r() {
              return new Sk.builtin.str(this.v.toString() + "L");
            },
            tp$as_number: true,
            nb$negative() {
              return new Sk.builtin.lng(intProto.nb$negative.call(this).v);
            },
            nb$positive() {
              return new Sk.builtin.lng(intProto.nb$positive.call(this).v);
            }
          }
        )
      });
      var intProto = Sk.builtin.int_.prototype;
    }
  });

  // src/bool.js
  var require_bool = __commonJS({
    "src/bool.js"() {
      var int_proto = Sk.builtin.int_.prototype;
      Sk.builtin.bool = Sk.abstr.buildNativeClass("bool", {
        constructor: function bool(x) {
          if (Sk.misceval.isTrue(x)) {
            return Sk.builtin.bool.true$;
          } else {
            return Sk.builtin.bool.false$;
          }
        },
        base: Sk.builtin.int_,
        slots: {
          tp$doc: "bool(x) -> bool\n\nReturns True when the argument x is true, False otherwise.\nThe builtins True and False are the only two instances of the class bool.\nThe class bool is a subclass of the class int, and cannot be subclassed.",
          tp$new(args, kwargs) {
            Sk.abstr.checkNoKwargs("bool", kwargs);
            Sk.abstr.checkArgsLen("bool", args, 0, 1);
            return new Sk.builtin.bool(args[0]);
          },
          $r() {
            return this.v ? this.str$True : this.str$False;
          },
          tp$as_number: true,
          nb$and(other) {
            if (other.ob$type === Sk.builtin.bool) {
              return new Sk.builtin.bool(this.v & other.v);
            }
            return int_proto.nb$and.call(this, other);
          },
          nb$or(other) {
            if (other.ob$type === Sk.builtin.bool) {
              return new Sk.builtin.bool(this.v | other.v);
            }
            return int_proto.nb$or.call(this, other);
          },
          nb$xor(other) {
            if (other.ob$type === Sk.builtin.bool) {
              return new Sk.builtin.bool(this.v ^ other.v);
            }
            return int_proto.nb$xor.call(this, other);
          }
        },
        flags: {
          sk$unacceptableBase: true
        },
        methods: {
          __format__: {
            $meth() {
              return this.$r();
            },
            $flags: { OneArg: true }
          }
        },
        proto: {
          str$False: new Sk.builtin.str("False"),
          str$True: new Sk.builtin.str("True")
        }
      });
      Sk.exportSymbol("Sk.builtin.bool", Sk.builtin.bool);
      Sk.builtin.bool.true$ = /** @type {Sk.builtin.bool} */
      Object.create(Sk.builtin.bool.prototype, {
        v: { value: 1, enumerable: true }
      });
      Sk.builtin.bool.false$ = /** @type {Sk.builtin.bool} */
      Object.create(Sk.builtin.bool.prototype, {
        v: { value: 0, enumerable: true }
      });
    }
  });

  // src/float.js
  var require_float = __commonJS({
    "src/float.js"() {
      var hashMap = Object.create(null, {
        Infinity: { value: 314159 },
        "-Infinity": { value: -314159 },
        NaN: { value: 0 }
      });
      Sk.builtin.float_ = Sk.abstr.buildNativeClass("float", {
        constructor: function float_(x) {
          Sk.asserts.assert(this instanceof Sk.builtin.float_, "bad call to float use 'new'");
          if (typeof x === "number") {
            this.v = x;
          } else if (x === void 0) {
            this.v = 0;
          } else if (typeof x === "string") {
            this.v = parseFloat(x);
          } else if (x.nb$float) {
            return x.nb$float();
          } else {
            Sk.asserts.fail("bad argument to float constructor");
          }
        },
        slots: (
          /**@lends {Sk.builtin.float_.prototype} */
          {
            tp$getattr: Sk.generic.getAttr,
            tp$as_number: true,
            tp$doc: "Convert a string or number to a floating point number, if possible.",
            tp$hash() {
              const v = this.v;
              let hash = hashMap[v];
              if (hash !== void 0) {
                return hash;
              } else if (Number.isInteger(v)) {
                hash = this.nb$int().tp$hash();
              } else {
                hash = Math.floor(
                  Math.random() * Number.MAX_SAFE_INTEGER - Number.MAX_SAFE_INTEGER / 2
                );
              }
              hashMap[this.v] = hash;
              return hash;
            },
            $r() {
              return new Sk.builtin.str(this.str$(10, true));
            },
            tp$new(args, kwargs) {
              if (kwargs && kwargs.length) {
                throw new Sk.builtin.TypeError("float() takes no keyword arguments");
              } else if (args && args.length > 1) {
                throw new Sk.builtin.TypeError(
                  "float expected at most 1 arguments, got " + args.length
                );
              }
              const arg = args[0];
              let x;
              if (arg === void 0) {
                x = new Sk.builtin.float_(0);
              } else if (arg.nb$float !== void 0) {
                x = arg.nb$float();
              } else if (arg.nb$index !== void 0) {
                x = new Sk.builtin.int_(arg.nb$index()).nb$float();
              } else if (Sk.builtin.checkString(arg)) {
                x = _str_to_float(arg.v);
              }
              if (x === void 0) {
                throw new Sk.builtin.TypeError("float() argument must be a string or a number");
              }
              if (this === Sk.builtin.float_.prototype) {
                return x;
              } else {
                const instance = new this.constructor();
                instance.v = x.v;
                return instance;
              }
            },
            // number slots
            nb$int() {
              let v = this.v;
              if (!Number.isFinite(v)) {
                if (v === Infinity || v === -Infinity) {
                  throw new Sk.builtin.OverflowError("cannot convert float infinity to integer");
                }
                throw new Sk.builtin.ValueError("cannot convert float NaN to integer");
              }
              if (v < 0) {
                v = Math.ceil(v);
              } else {
                v = Math.floor(v);
              }
              if (Sk.builtin.int_.withinThreshold(v)) {
                return new Sk.builtin.int_(v);
              } else {
                return new Sk.builtin.int_(JSBI.BigInt(v));
              }
            },
            nb$float: cloneSelf,
            nb$long() {
              return new Sk.builtin.lng(this.nb$int().v);
            },
            nb$add: numberSlot((v, w) => new Sk.builtin.float_(v + w)),
            nb$subtract: numberSlot((v, w) => new Sk.builtin.float_(v - w)),
            nb$reflected_subtract: numberSlot((v, w) => new Sk.builtin.float_(w - v)),
            nb$multiply: numberSlot((v, w) => new Sk.builtin.float_(v * w)),
            nb$divide: numberSlot(divide),
            nb$reflected_divide: numberSlot((v, w) => divide(w, v)),
            nb$floor_divide: numberSlot(floordivide),
            nb$reflected_floor_divide: numberSlot((v, w) => floordivide(w, v)),
            nb$remainder: numberSlot(remainder),
            nb$reflected_remainder: numberSlot((v, w) => remainder(w, v)),
            nb$divmod: numberSlot((v, w) => new Sk.builtin.tuple([floordivide(v, w), remainder(v, w)])),
            nb$reflected_divmod: numberSlot(
              (v, w) => new Sk.builtin.tuple([floordivide(w, v), remainder(w, v)])
            ),
            nb$power: ternarySlot(power),
            nb$reflected_power: ternarySlot((v, w) => power(w, v)),
            nb$abs() {
              return new Sk.builtin.float_(Math.abs(this.v));
            },
            nb$negative() {
              return new Sk.builtin.float_(-this.v);
            },
            nb$positive() {
              return new Sk.builtin.float_(this.v);
            },
            nb$bool() {
              return this.v !== 0;
            },
            nb$isnegative() {
              return this.v < 0;
            },
            nb$ispositive() {
              return this.v >= 0;
            },
            ob$eq: compareSlot((v, w) => v == w, JSBI.EQ),
            ob$ne: compareSlot((v, w) => v != w, JSBI.NE),
            ob$gt: compareSlot((v, w) => v > w, JSBI.GT),
            ob$ge: compareSlot((v, w) => v >= w, JSBI.GE),
            ob$lt: compareSlot((v, w) => v < w, JSBI.LT),
            ob$le: compareSlot((v, w) => v <= w, JSBI.LE)
          }
        ),
        getsets: (
          /**@lends {Sk.builtin.float_.prototype} */
          {
            real: {
              $get: cloneSelf,
              $doc: "the real part of a complex number"
            },
            imag: {
              $get() {
                return new Sk.builtin.float_(0);
              },
              $doc: "the imaginary part of a complex number"
            }
          }
        ),
        methods: (
          /**@lends {Sk.builtin.float_.prototype} */
          {
            conjugate: {
              $meth: cloneSelf,
              $flags: { NoArgs: true },
              $textsig: "($self, /)",
              $doc: "Return self, the complex conjugate of any float."
            },
            __trunc__: {
              $meth() {
                return this.nb$int();
              },
              $flags: { NoArgs: true },
              $textsig: "($self, /)",
              $doc: "Return the Integral closest to x between 0 and x."
            },
            __round__: {
              $meth(ndigits) {
                return this.round$(ndigits);
              },
              $flags: { MinArgs: 0, MaxArgs: 1 },
              $textsig: "($self, ndigits=None, /)",
              $doc: "Return the Integral closest to x, rounding half toward even.\n\nWhen an argument is passed, work like built-in round(x, ndigits)."
            },
            as_integer_ratio: {
              $meth() {
                if (!Number.isFinite(this.v)) {
                  if (Number.isNaN(this.v)) {
                    throw new Sk.builtin.ValueError("cannot convert NaN to integer ratio");
                  }
                  throw new Sk.builtin.OverflowError("cannot convert Infinity to integer ratio");
                }
                let [float_part, exponent] = frexp(this.v);
                for (let i = 0; i < 300 && float_part != Math.floor(float_part); i++) {
                  float_part *= 2;
                  exponent--;
                }
                const py_exp = new Sk.builtin.int_(Math.abs(exponent));
                let numerator = new Sk.builtin.int_(float_part);
                let denominator = new Sk.builtin.int_(1);
                if (exponent > 0) {
                  numerator = numerator.nb$lshift(py_exp);
                } else {
                  denominator = denominator.nb$lshift(py_exp);
                }
                return new Sk.builtin.tuple([numerator, denominator]);
              },
              $flags: { NoArgs: true },
              $textsig: "($self, /)",
              $doc: "Return integer ratio.\n\nReturn a pair of integers, whose ratio is exactly equal to the original float\nand with a positive denominator.\n\nRaise OverflowError on infinities and a ValueError on NaNs.\n\n>>> (10.0).as_integer_ratio()\n(10, 1)\n>>> (0.0).as_integer_ratio()\n(0, 1)\n>>> (-.25).as_integer_ratio()\n(-1, 4)"
            },
            // hex: {
            //     $meth: methods.hex,
            //     $flags: { NoArgs: true },
            //     $textsig: "($self, /)",
            //     $doc:
            //         "Return a hexadecimal representation of a floating-point number.\n\n>>> (-0.1).hex()\n'-0x1.999999999999ap-4'\n>>> 3.14159.hex()\n'0x1.921f9f01b866ep+1'",
            // },
            is_integer: {
              $meth() {
                return new Sk.builtin.bool(Number.isInteger(this.v));
              },
              $flags: { NoArgs: true },
              $textsig: "($self, /)",
              $doc: "Return True if the float is an integer."
            },
            __getnewargs__: {
              $meth() {
                return new Sk.builtin.tuple([this]);
              },
              $flags: { NoArgs: true },
              $textsig: "($self, /)",
              $doc: Sk.builtin.none.none$
            },
            __format__: {
              $meth: Sk.formatting.mkNumber__format__(true),
              $flags: { OneArg: true },
              $textsig: "($self, format_spec, /)",
              $doc: Sk.builtin.none.none$
            }
          }
        )
      });
      function frexp(arg) {
        const res = [arg, 0];
        if (arg === 0) {
          return res;
        }
        const absArg = Math.abs(arg);
        let exp = Math.max(-1023, Math.floor(Math.log2(absArg)) + 1);
        let m = absArg * Math.pow(2, -exp);
        while (m < 0.5) {
          m *= 2;
          exp--;
        }
        while (m >= 1) {
          m *= 0.5;
          exp++;
        }
        if (arg < 0) {
          m = -m;
        }
        res[0] = m;
        res[1] = exp;
        return res;
      }
      var invalidUnderscores = /_[eE]|[eE]_|\._|_\.|[+-]_|__/;
      var validUnderscores = /_(?=[^_])/g;
      function _str_to_float(str) {
        let ret;
        let tmp = str;
        if (str.indexOf("_") !== -1) {
          if (invalidUnderscores.test(str)) {
            throw new Sk.builtin.ValueError("could not convert string to float: '" + str + "'");
          }
          tmp = str.charAt(0) + str.substring(1).replace(validUnderscores, "");
        }
        if (str.match(/^-inf$/i)) {
          ret = -Infinity;
        } else if (str.match(/^[+]?inf$/i)) {
          ret = Infinity;
        } else if (str.match(/^[-+]?nan$/i)) {
          ret = NaN;
        } else if (!isNaN(tmp)) {
          ret = parseFloat(tmp);
          if (Number.isNaN(ret)) {
            ret = void 0;
          }
        }
        if (ret === void 0) {
          throw new Sk.builtin.ValueError(
            "could not convert string to float: " + Sk.misceval.objectRepr(new Sk.builtin.str(str))
          );
        }
        return new Sk.builtin.float_(ret);
      }
      function cloneSelf() {
        return new Sk.builtin.float_(this.v);
      }
      Sk.builtin.float_.PyFloat_Check = function(op) {
        if (op === void 0) {
          return false;
        }
        if (Sk.builtin.checkNumber(op)) {
          return true;
        }
        if (Sk.builtin.checkFloat(op)) {
          return true;
        }
        if (op.ob$type.$isSubType(Sk.builtin.float_)) {
          return true;
        }
        return false;
      };
      Sk.builtin.float_.prototype.toFixed = function(x) {
        x = Sk.builtin.asnum$(x);
        return this.v.toFixed(x);
      };
      function numberSlot(f) {
        return function(other) {
          const v = this.v;
          let w = other.v;
          if (typeof w === "number") {
          } else if (JSBI.__isBigInt(w)) {
            w = fromBigIntToNumberOrOverflow(w);
          } else {
            return Sk.builtin.NotImplemented.NotImplemented$;
          }
          return f(v, w);
        };
      }
      function compareSlot(doCompare, JSBI_ALT) {
        return function(other) {
          const v = this.v;
          const w = other.v;
          if (typeof w === "number") {
          } else if (!JSBI.__isBigInt(w)) {
            return Sk.builtin.NotImplemented.NotImplemented$;
          } else if (JSBI_ALT !== void 0) {
            return JSBI_ALT(v, w);
          }
          return doCompare(v, w);
        };
      }
      function ternarySlot(f) {
        const binSlot = numberSlot(f);
        return function(other, z) {
          if (z !== void 0 && !Sk.builtin.checkNone(z)) {
            throw new Sk.builtin.TypeError(
              "pow() 3rd argument not allowed unless all arguments are integers"
            );
          }
          return binSlot.call(this, other);
        };
      }
      function divide(v, w) {
        if (w === 0) {
          throw new Sk.builtin.ZeroDivisionError("integer division or modulo by zero");
        }
        if (v === Infinity) {
          if (w === Infinity || v === -Infinity) {
            return new Sk.builtin.float_(NaN);
          } else if (w < 0) {
            return new Sk.builtin.float_(-Infinity);
          } else {
            return new Sk.builtin.float_(Infinity);
          }
        }
        if (v === -Infinity) {
          if (w === Infinity || v === -Infinity) {
            return new Sk.builtin.float_(NaN);
          } else if (w < 0) {
            return new Sk.builtin.float_(Infinity);
          } else {
            return new Sk.builtin.float_(-Infinity);
          }
        }
        return new Sk.builtin.float_(v / w);
      }
      function floordivide(v, w) {
        if (v === Infinity || v === -Infinity) {
          return new Sk.builtin.float_(NaN);
        }
        if (w === 0) {
          throw new Sk.builtin.ZeroDivisionError("integer division or modulo by zero");
        }
        if (w === Infinity) {
          if (v < 0) {
            return new Sk.builtin.float_(-1);
          } else {
            return new Sk.builtin.float_(0);
          }
        }
        if (w === -Infinity) {
          if (v < 0 || v !== 0) {
            return new Sk.builtin.float_(0);
          } else {
            return new Sk.builtin.float_(-1);
          }
        }
        return new Sk.builtin.float_(Math.floor(v / w));
      }
      function remainder(v, w) {
        if (w === 0) {
          throw new Sk.builtin.ZeroDivisionError("integer division or modulo by zero");
        }
        if (v === 0) {
          return new Sk.builtin.float_(0);
        }
        if (w === Infinity) {
          if (v === Infinity || this.v === -Infinity) {
            return new Sk.builtin.float_(NaN);
          } else if (v > 0) {
            return new Sk.builtin.float_(v);
          } else {
            return new Sk.builtin.float_(Infinity);
          }
        }
        let tmp = v % w;
        if (v < 0) {
          if (w > 0 && tmp < 0) {
            tmp = tmp + w;
          }
        } else {
          if (w < 0 && tmp !== 0) {
            tmp = tmp + w;
          }
        }
        if (tmp === 0) {
          if (w < 0) {
            tmp = -0;
          } else if (Infinity / tmp === -Infinity) {
            tmp = 0;
          }
        }
        return new Sk.builtin.float_(tmp);
      }
      function power(v, w) {
        if (v < 0 && w % 1 !== 0) {
          throw new Sk.builtin.ValueError("negative number cannot be raised to a fractional power");
        }
        if (v === 0 && w < 0) {
          throw new Sk.builtin.ZeroDivisionError("0.0 cannot be raised to a negative power");
        }
        const result = Math.pow(v, w);
        if (Math.abs(result) === Infinity && Math.abs(v) !== Infinity && Math.abs(w) !== Infinity) {
          throw new Sk.builtin.OverflowError("Numerical result out of range");
        }
        return new Sk.builtin.float_(result);
      }
      Sk.builtin.float_.prototype.round$ = function(ndigits) {
        var result, multiplier, number, num10, rounded, bankRound, ndigs;
        number = Sk.builtin.asnum$(this);
        if (ndigits === void 0) {
          ndigs = 0;
        } else {
          ndigs = Sk.misceval.asIndexSized(ndigits);
        }
        if (Sk.__future__.bankers_rounding) {
          num10 = number * Math.pow(10, ndigs);
          rounded = Math.round(num10);
          bankRound = (num10 > 0 ? num10 : -num10) % 1 === 0.5 ? 0 === rounded % 2 ? rounded : rounded - 1 : rounded;
          result = bankRound / Math.pow(10, ndigs);
          if (ndigits === void 0) {
            return new Sk.builtin.int_(result);
          } else {
            return new Sk.builtin.float_(result);
          }
        } else {
          multiplier = Math.pow(10, ndigs);
          result = Math.round(number * multiplier) / multiplier;
          return new Sk.builtin.float_(result);
        }
      };
      Sk.builtin.float_.prototype.str$ = function(base, sign) {
        var post;
        var pre;
        var idx;
        var tmp;
        var work;
        if (isNaN(this.v)) {
          return "nan";
        }
        if (sign === void 0) {
          sign = true;
        }
        if (this.v == Infinity) {
          return "inf";
        }
        if (this.v == -Infinity && sign) {
          return "-inf";
        }
        if (this.v == -Infinity && !sign) {
          return "inf";
        }
        work = sign ? this.v : Math.abs(this.v);
        if (base === void 0 || base === 10) {
          if (Sk.__future__.python3) {
            tmp = work.toPrecision(16);
          } else {
            tmp = work.toPrecision(12);
          }
          idx = tmp.indexOf(".");
          pre = work.toString().slice(0, idx);
          post = work.toString().slice(idx);
          if (pre.match(/^-?0$/) && post.slice(1).match(/^0{4,}/)) {
            if (tmp.length < 12) {
              tmp = work.toExponential();
            } else {
              tmp = work.toExponential(11);
            }
          }
          if (tmp.indexOf("e") < 0 && tmp.indexOf(".") >= 0) {
            while (tmp.charAt(tmp.length - 1) == "0") {
              tmp = tmp.substring(0, tmp.length - 1);
            }
            if (tmp.charAt(tmp.length - 1) == ".") {
              tmp = tmp + "0";
            }
          }
          tmp = tmp.replace(new RegExp("\\.0+e"), "e", "i");
          tmp = tmp.replace(/(e[-+])([1-9])$/, "$10$2");
          tmp = tmp.replace(/0+(e.*)/, "$1");
        } else {
          tmp = work.toString(base);
        }
        if (this.v === 0 && 1 / this.v === -Infinity) {
          tmp = "-" + tmp;
        }
        if (tmp.indexOf(".") < 0 && tmp.indexOf("E") < 0 && tmp.indexOf("e") < 0) {
          tmp = tmp + ".0";
        }
        return tmp;
      };
      Sk.builtin.float_.py2$methods = {};
      function fromBigIntToNumberOrOverflow(big) {
        const x = parseFloat(JSBI.toNumber(big));
        if (x == Infinity || x == -Infinity) {
          throw new Sk.builtin.OverflowError("int too large to convert to float");
        }
        return x;
      }
    }
  });

  // src/complex.js
  var require_complex = __commonJS({
    "src/complex.js"() {
      Sk.builtin.complex = Sk.abstr.buildNativeClass("complex", {
        constructor: function complex(real, imag) {
          Sk.asserts.assert(
            this instanceof Sk.builtin.complex,
            "bad call to complex constructor, use 'new'"
          );
          this.real = real;
          this.imag = imag;
        },
        slots: (
          /**@lends {Sk.builtin.complex.prototype}*/
          {
            tp$as_number: true,
            tp$doc: "Create a complex number from a real part and an optional imaginary part.\n\nThis is equivalent to (real + imag*1j) where imag defaults to 0.",
            tp$hash() {
              const real_hash = new Sk.builtin.float_(this.real).tp$hash();
              const imag_hash = new Sk.builtin.float_(this.imag).tp$hash();
              const v = imag_hash * 1003 + real_hash;
              if (Sk.builtin.int_.withinThreshold(v)) {
                return v;
              }
              return new Sk.builtin.int_(JSBI.BigInt(v)).tp$hash();
            },
            tp$getattr: Sk.generic.getAttr,
            tp$new(args, kwargs) {
              args = Sk.abstr.copyKeywordsToNamedArgs("complex", ["real", "imag"], args, kwargs, [
                null,
                null
              ]);
              return complex_from_py.call(this, args[0], args[1]);
            },
            tp$richcompare(w, op) {
              if (op !== "Eq" && op !== "NotEq") {
                if (Sk.builtin.checkNumber(w) || _complex_check(w)) {
                  throw new Sk.builtin.TypeError(
                    "no ordering relation is defined for complex numbers"
                  );
                }
                return Sk.builtin.NotImplemented.NotImplemented$;
              }
              return complexNumberSlot(function(a_real, a_imag, b_real, b_imag) {
                const equal = a_real == b_real && a_imag == b_imag;
                return op === "Eq" ? equal : !equal;
              }, true).call(this, w);
            },
            $r() {
              return complex_format(this, null, "g");
            },
            // number slots
            nb$int() {
              throw new Sk.builtin.TypeError("can't convert complex to int");
            },
            nb$long() {
              throw new Sk.builtin.TypeError("can't convert complex to long");
            },
            nb$float() {
              throw new Sk.builtin.TypeError("can't convert complex to float");
            },
            nb$positive() {
              return new Sk.builtin.complex(this.real, this.imag);
            },
            nb$negative() {
              return new Sk.builtin.complex(-this.real, -this.imag);
            },
            nb$bool() {
              return this.real || this.imag;
            },
            nb$add: complexNumberSlot((a_real, a_imag, b_real, b_imag) => {
              return new Sk.builtin.complex(a_real + b_real, a_imag + b_imag);
            }),
            nb$subtract: complexNumberSlot((a_real, a_imag, b_real, b_imag) => {
              return new Sk.builtin.complex(a_real - b_real, a_imag - b_imag);
            }),
            nb$reflected_subtract: complexNumberSlot((a_real, a_imag, b_real, b_imag) => {
              return new Sk.builtin.complex(b_real - a_real, b_imag - a_imag);
            }),
            nb$multiply: complexNumberSlot((a_real, a_imag, b_real, b_imag) => {
              return new Sk.builtin.complex(
                b_real * a_real - b_imag * a_imag,
                a_real * b_imag + a_imag * b_real
              );
            }),
            nb$divide: complexNumberSlot(divide),
            nb$reflected_divide: complexNumberSlot((a_real, a_imag, b_real, b_imag) => {
              return divide(b_real, b_imag, a_real, a_imag);
            }),
            nb$floor_divide(other) {
              throw new Sk.builtin.TypeError("can't take floor of complex number.");
            },
            nb$reflected_floor_divide(other) {
              throw new Sk.builtin.TypeError("can't take floor of complex number.");
            },
            nb$remainder(other) {
              throw new Sk.builtin.TypeError("can't mod complex numbers.");
            },
            nb$reflected_remainder(other) {
              throw new Sk.builtin.TypeError("can't mod complex numbers.");
            },
            nb$divmod(other) {
              throw new Sk.builtin.TypeError("can't take floor or mod of complex number.");
            },
            nb$power(other, z) {
              if (z != null && !Sk.builtin.checkNone(z)) {
                throw new Sk.builtin.ValueError("complex modulo");
              }
              return power.call(this, other);
            },
            nb$abs() {
              const _real = this.real;
              const _imag = this.imag;
              if (!_is_finite(_real) || !_is_finite(_imag)) {
                if (_is_infinity(_real)) {
                  return new Sk.builtin.float_(Math.abs(_real));
                } else if (_is_infinity(_imag)) {
                  return new Sk.builtin.float_(Math.abs(_imag));
                }
                return new Sk.builtin.float_(NaN);
              }
              const result = Math.hypot(_real, _imag);
              if (!_is_finite(result)) {
                throw new Sk.builtin.OverflowError("absolute value too large");
              }
              return new Sk.builtin.float_(result);
            }
          }
        ),
        getsets: {
          real: {
            $get() {
              return new Sk.builtin.float_(this.real);
            },
            $doc: "the real part of a complex number"
          },
          imag: {
            $get() {
              return new Sk.builtin.float_(this.imag);
            },
            $doc: "the imaginary part of a complex number"
          }
        },
        methods: (
          /**@lends {Sk.builtin.complex.prototype}*/
          {
            conjugate: {
              $meth() {
                return new Sk.builtin.complex(this.real, -this.imag);
              },
              $flags: { NoArgs: true },
              $textsig: null,
              $doc: "complex.conjugate() -> complex\n\nReturn the complex conjugate of its argument. (3-4j).conjugate() == 3+4j."
            },
            __getnewargs__: {
              $meth() {
                return new Sk.builtin.tuple([
                  new Sk.builtin.float_(this.real),
                  new Sk.builtin.float_(this.imag)
                ]);
              },
              $flags: { NoArgs: true },
              $textsig: null,
              $doc: Sk.builtin.none.none$
            },
            __format__: {
              $meth(format_spec) {
                if (Sk.builtin.checkString(format_spec)) {
                  return _PyComplex_FormatAdvanced(this, format_spec);
                }
                throw new Sk.builtin.TypeError("__format__ requires str");
              },
              $flags: { OneArg: true },
              $textsig: null,
              $doc: "complex.__format__() -> str\n\nConvert to a string according to format_spec."
            }
          }
        )
      });
      Sk.exportSymbol("Sk.builtin.complex", Sk.builtin.complex);
      function PyFloat_AsDouble(op) {
        let v = op.v;
        if (typeof v === "number") {
          return v;
        } else if (op.nb$float) {
          v = op.nb$float();
        }
        if (v === void 0) {
          throw new Sk.builtin.TypeError("a float is required");
        }
        return v.v;
      }
      function try_complex_special_method(op) {
        if (op == null) {
          return null;
        }
        const f = Sk.abstr.lookupSpecial(op, Sk.builtin.str.$complex);
        if (f !== void 0) {
          return Sk.misceval.callsimArray(f, []);
        }
        return null;
      }
      var _complex_check = Sk.builtin.checkComplex;
      function complex_from_py(real, imag) {
        let tmp;
        const cr = {};
        const ci = {};
        let cr_is_complex = false;
        let ci_is_complex = false;
        let r = real;
        let i = imag;
        if (r != null && r.constructor === Sk.builtin.complex && i == null) {
          return r;
        }
        if (Sk.builtin.checkString(r)) {
          if (i != null) {
            throw new Sk.builtin.TypeError("complex() can't take second arg if first is a string");
          }
          return Sk.builtin.complex.complex_subtype_from_string(r, this);
        }
        if (i != null && Sk.builtin.checkString(i)) {
          throw new Sk.builtin.TypeError("complex() second arg can't be a string");
        }
        tmp = try_complex_special_method(r);
        if (tmp != null && tmp !== Sk.builtin.NotImplemented.NotImplemented$) {
          if (!_complex_check(tmp)) {
            throw new Sk.builtin.TypeError("__complex__ should return a complex object");
          }
          r = tmp;
        }
        function check_number(nb) {
          return nb.nb$float !== void 0;
        }
        if (r != null) {
          if (!check_number(r)) {
            throw new Sk.builtin.TypeError(
              "complex() first argument must be a string or a number, not '" + Sk.abstr.typeName(r) + "'"
            );
          }
        }
        if (i != null) {
          if (!check_number(i)) {
            throw new Sk.builtin.TypeError(
              "complex() second argument must be a number, not '" + Sk.abstr.typeName(r) + "'"
            );
          }
        }
        if (r == null) {
          cr.real = 0;
          cr.imag = 0;
        } else if (_complex_check(r)) {
          cr.real = r.real;
          cr.imag = r.imag;
          cr_is_complex = true;
        } else {
          cr.real = PyFloat_AsDouble(r);
          cr.imag = 0;
        }
        if (i == null) {
          ci.real = 0;
          ci.imag = 0;
        } else if (_complex_check(i)) {
          ci.real = i.real;
          ci.imag = i.imag;
          ci_is_complex = true;
        } else {
          ci.real = PyFloat_AsDouble(i);
          ci.imag = 0;
        }
        if (ci_is_complex === true) {
          cr.real -= ci.imag;
        }
        if (cr_is_complex === true) {
          ci.real += cr.imag;
        }
        return complex_subtype_from_doubles(cr.real, ci.real, this);
      }
      function complex_subtype_from_doubles(real, imag, type_prototype) {
        if (type_prototype === Sk.builtin.complex.prototype) {
          return new Sk.builtin.complex(real, imag);
        } else {
          const instance = new type_prototype.constructor();
          Sk.builtin.complex.call(instance, real, imag);
          return instance;
        }
      }
      var invalidUnderscores = /_[eE]|[eE]_|\._|_\.|[+-]_|_j|j_/;
      var validUnderscores = /_(?=[^_])/g;
      Sk.builtin.complex.complex_subtype_from_string = function(val, type_prototype) {
        type_prototype = type_prototype || Sk.builtin.complex.prototype;
        var index;
        var start;
        var val_wws;
        var x = 0, y = 0;
        var got_bracket = false;
        var len;
        var match;
        if (Sk.builtin.checkString(val)) {
          val = Sk.ffi.remapToJs(val);
        } else if (typeof val !== "string") {
          throw new TypeError("provided unsupported string-alike argument");
        }
        if (val.indexOf("\0") !== -1 || val.length === 0 || val === "") {
          throw new Sk.builtin.ValueError("complex() arg is a malformed string");
        }
        index = 0;
        val = val.replace(/inf|infinity/gi, "Infinity");
        val = val.replace(/nan/gi, "NaN");
        start = 0;
        while (val[index] === " ") {
          index++;
        }
        if (val[index] === "(") {
          got_bracket = true;
          index++;
          while (val[index] === " ") {
            index++;
          }
        }
        if (val.indexOf("_") !== -1) {
          if (invalidUnderscores.test(val)) {
            throw new Sk.builtin.ValueError("could not convert string to complex: '" + val + "'");
          }
          val = val.charAt(0) + val.substring(1).replace(validUnderscores, "");
        }
        var float_regex2 = /^(?:[+-]?(?:(?:(?:\d*\.\d+)|(?:\d+\.?))(?:[eE][+-]?\d+)?|NaN|Infinity))/;
        val_wws = val.substr(index);
        match = val_wws.match(float_regex2);
        if (match !== null) {
          index += match[0].length;
          if (val[index] === "j" || val[index] === "J") {
            y = parseFloat(match[0]);
            index++;
          } else if (val[index] === "+" || val[index] === "-") {
            x = parseFloat(match[0]);
            match = val.substr(index).match(float_regex2);
            if (match !== null) {
              y = parseFloat(match[0]);
              index += match[0].length;
            } else {
              y = val[index] === "+" ? 1 : -1;
              index++;
            }
            if (val[index] !== "j" && val[index] !== "J") {
              throw new Sk.builtin.ValueError("complex() arg is malformed string");
            }
            index++;
          } else {
            x = parseFloat(match[0]);
          }
        } else {
          match = match = val_wws.match(/^([+-]?[jJ])/);
          if (match !== null) {
            if (match[0].length === 1) {
              y = 1;
            } else {
              y = match[0][0] === "+" ? 1 : -1;
            }
            index += match[0].length;
          }
        }
        while (val[index] === " ") {
          index++;
        }
        if (got_bracket) {
          if (val[index] !== ")") {
            throw new Sk.builtin.ValueError("complex() arg is malformed string");
          }
          index++;
          while (val[index] === " ") {
            index++;
          }
        }
        if (val.length !== index) {
          throw new Sk.builtin.ValueError("complex() arg is malformed string");
        }
        return complex_subtype_from_doubles(x, y, type_prototype);
      };
      function fromBigIntToNumberOrOverflow(big) {
        const x = parseFloat(JSBI.toNumber(big));
        if (x == Infinity || x == -Infinity) {
          throw new Sk.builtin.OverflowError("int too large to convert to float");
        }
        return x;
      }
      function complexNumberSlot(f, suppressOverflow) {
        return function(other) {
          const a_real = this.real;
          const a_imag = this.imag;
          let b_real = other.real;
          let b_imag;
          const other_v = other.v;
          if (typeof b_real === "number") {
            b_imag = other.imag;
          } else if (typeof other_v === "number") {
            b_real = other_v;
            b_imag = 0;
          } else if (JSBI.__isBigInt(other_v)) {
            if (suppressOverflow === void 0) {
              b_real = fromBigIntToNumberOrOverflow(other_v);
            } else {
              b_real = other_v.toString();
            }
            b_imag = 0;
          } else {
            return Sk.builtin.NotImplemented.NotImplemented$;
          }
          return f(a_real, a_imag, b_real, b_imag);
        };
      }
      function divide(a_real, a_imag, b_real, b_imag) {
        let ratio, denom, real, imag;
        const abs_b_real = Math.abs(b_real);
        const abs_b_imag = Math.abs(b_imag);
        if (abs_b_real >= abs_b_imag) {
          if (abs_b_real === 0) {
            throw new Sk.builtin.ZeroDivisionError("complex division by zero");
          } else {
            ratio = b_imag / b_real;
            denom = b_real + b_imag * ratio;
            real = (a_real + a_imag * ratio) / denom;
            imag = (a_imag - a_real * ratio) / denom;
          }
        } else if (abs_b_imag >= abs_b_real) {
          ratio = b_real / b_imag;
          denom = b_real * ratio + b_imag;
          Sk.asserts.assert(b_imag !== 0);
          real = (a_real * ratio + a_imag) / denom;
          imag = (a_imag * ratio - a_real) / denom;
        } else {
          real = NaN;
          imag = NaN;
        }
        return new Sk.builtin.complex(real, imag);
      }
      var power = complexNumberSlot((a_real, a_imag, b_real, b_imag) => {
        const int_exponent = b_real | 0;
        if (b_imag === 0 && b_real === int_exponent) {
          return c_powi(a_real, a_imag, int_exponent);
        } else {
          return c_pow(a_real, a_imag, b_real, b_imag);
        }
      });
      function c_pow(a_real, a_imag, b_real, b_imag) {
        let len, phase, real, imag;
        if (b_real === 0 && b_imag === 0) {
          real = 1;
          imag = 0;
        } else if (a_real === 0 && a_imag === 0) {
          if (b_imag !== 0 || b_real < 0) {
            throw new Sk.builtin.ZeroDivisionError("complex division by zero");
          }
          real = 0;
          imag = 0;
        } else {
          const vabs = Math.hypot(a_real, a_imag);
          len = Math.pow(vabs, b_real);
          const at = Math.atan2(a_imag, a_real);
          phase = at * b_real;
          if (b_imag !== 0) {
            len /= Math.exp(at * b_imag);
            phase += b_imag * Math.log(vabs);
          }
          real = len * Math.cos(phase);
          imag = len * Math.sin(phase);
        }
        return new Sk.builtin.complex(real, imag);
      }
      function c_powi(a_real, a_imag, n) {
        if (n > 100 || n < -100) {
          return c_pow(a_real, a_imag, n, 0);
        } else if (n > 0) {
          return c_powu(a_real, a_imag, n);
        } else {
          const r = c_powu(a_real, a_imag, -n);
          return divide(1, 0, r.real, r.imag);
        }
      }
      function c_powu(a_real, a_imag, n) {
        var r, p;
        let mask = 1;
        r = new Sk.builtin.complex(1, 0);
        p = new Sk.builtin.complex(a_real, a_imag);
        while (mask > 0 && n >= mask) {
          if (n & mask) {
            r = new Sk.builtin.complex(
              r.real * p.real - r.imag * p.imag,
              r.real * p.imag + p.real * r.imag
            );
          }
          mask <<= 1;
          p = new Sk.builtin.complex(p.real * p.real - p.imag * p.imag, 2 * p.real * p.imag);
        }
        return r;
      }
      function complex_format(v, precision, format_code) {
        function copysign(a, b) {
          let sign;
          if (b) {
            sign = b < 0 ? -1 : 1;
          } else {
            sign = 1 / b < 0 ? -1 : 1;
          }
          return sign * Math.abs(a);
        }
        let result;
        let pre = "";
        let im = "";
        let re = null;
        let lead = "";
        let tail = "";
        const real = v.real;
        const imag = v.imag;
        if (real === 0 && copysign(1, real) == 1) {
          re = "";
          im = PyOS_double_to_string(imag, format_code, precision, 0, null);
        } else {
          pre = PyOS_double_to_string(real, format_code, precision, 0, null);
          re = pre;
          im = PyOS_double_to_string(
            imag,
            format_code,
            precision,
            PyOS_double_to_string.Py_DTSF_SIGN,
            null
          );
          if (imag === 0 && 1 / imag === -Infinity && im && im[0] !== "-") {
            im = "-" + im;
          }
          lead = "(";
          tail = ")";
        }
        result = "" + lead + re + im + "j" + tail;
        return new Sk.builtin.str(result);
      }
      function _PyComplex_FormatAdvanced(self2, format_spec) {
        throw new Sk.builtin.NotImplementedError("__format__ is not implemented for complex type.");
      }
      function _is_finite(val) {
        return Number.isFinite(val);
      }
      function _is_infinity(val) {
        return val === Infinity || val === -Infinity;
      }
      function PyOS_double_to_string(val, format_code, precision, flags, type) {
        let buf, t, upper = false;
        switch (format_code) {
          case "e":
          /* exponent */
          case "f":
          /* fixed */
          case "g":
            break;
          case "E":
            upper = true;
            format_code = "e";
            break;
          case "F":
            upper = true;
            format_code = "f";
            break;
          case "r":
            if (precision !== 0) {
              throw new Error("Bad internall call");
            }
            precision = 17;
            format_code = "g";
            break;
          default:
            throw new Error("Bad internall call");
        }
        if (isNaN(val)) {
          buf = "nan";
          t = PyOS_double_to_string.Py_DTST_NAN;
        } else if (val === Infinity) {
          buf = "inf";
          t = PyOS_double_to_string.Py_DTST_INFINITE;
        } else if (val === -Infinity) {
          buf = "-inf";
          t = PyOS_double_to_string.Py_DTST_INFINITE;
        } else {
          t = PyOS_double_to_string.Py_DTST_FINITE;
          if (flags & PyOS_double_to_string.Py_DTSF_ADD_DOT_0) {
            format_code = "g";
          }
          var format_str = "%";
          format_str += flags & PyOS_double_to_string.Py_DTSF_ALT ? "#" : "";
          if (precision != null) {
            format_str += ".";
            format_str += precision;
          }
          format_str += format_code;
          format_str = new Sk.builtin.str(format_str);
          buf = format_str.nb$remainder(new Sk.builtin.float_(val));
          buf = buf.v;
        }
        if (flags & PyOS_double_to_string.Py_DTSF_SIGN && buf[0] !== "-") {
          buf = "+" + buf;
        }
        if (upper) {
          buf = buf.toUpperCase();
        }
        return buf;
      }
      PyOS_double_to_string.Py_DTSF_SIGN = 1;
      PyOS_double_to_string.Py_DTSF_ADD_DOT_0 = 2;
      PyOS_double_to_string.Py_DTSF_ALT = 4;
      PyOS_double_to_string.Py_DTST_FINITE = 0;
      PyOS_double_to_string.Py_DTST_INFINITE = 1;
      PyOS_double_to_string.Py_DTST_NAN = 2;
    }
  });

  // src/slice.js
  var require_slice = __commonJS({
    "src/slice.js"() {
      Sk.builtin.slice = Sk.abstr.buildNativeClass("slice", {
        constructor: function slice(start, stop, step) {
          if (stop === void 0 && step === void 0) {
            stop = start;
            start = Sk.builtin.none.none$;
          }
          if (stop === void 0) {
            stop = Sk.builtin.none.none$;
          }
          if (step === void 0) {
            step = Sk.builtin.none.none$;
          }
          this.start = start;
          this.stop = stop;
          this.step = step;
        },
        slots: (
          /**@lends {Sk.builtin.slice.prototype} */
          {
            tp$getattr: Sk.generic.getAttr,
            tp$doc: "slice(stop)\nslice(start, stop[, step])\n\nCreate a slice object.  This is used for extended slicing (e.g. a[0:10:2]).",
            tp$hash: Sk.builtin.none.none$,
            tp$new(args, kwargs) {
              Sk.abstr.checkNoKwargs("slice", kwargs);
              Sk.abstr.checkArgsLen("slice", args, 1, 3);
              return new Sk.builtin.slice(...args);
            },
            $r() {
              const a = Sk.misceval.objectRepr(this.start);
              const b = Sk.misceval.objectRepr(this.stop);
              const c = Sk.misceval.objectRepr(this.step);
              return new Sk.builtin.str("slice(" + a + ", " + b + ", " + c + ")");
            },
            tp$richcompare(w, op) {
              if (w.ob$type !== Sk.builtin.slice) {
                return Sk.builtin.NotImplemented.NotImplemented$;
              }
              const t1 = new Sk.builtin.tuple([this.start, this.stop, this.step]);
              const t2 = new Sk.builtin.tuple([w.start, w.stop, w.step]);
              return t1.tp$richcompare(t2, op);
            }
          }
        ),
        getsets: (
          /**@lends {Sk.builtin.slice.prototype} */
          {
            start: {
              $get() {
                return this.start;
              }
            },
            step: {
              $get() {
                return this.step;
              }
            },
            stop: {
              $get() {
                return this.stop;
              }
            }
          }
        ),
        methods: (
          /**@lends {Sk.builtin.slice.prototype} */
          {
            indices: {
              $meth: function indices(length) {
                length = Sk.misceval.asIndexSized(length, Sk.builtin.OverflowError);
                if (length < 0) {
                  throw new Sk.builtin.TypeError("length should not be negative");
                }
                const { start, stop, step } = this.slice$indices(length);
                return new Sk.builtin.tuple([
                  new Sk.builtin.int_(start),
                  new Sk.builtin.int_(stop),
                  new Sk.builtin.int_(step)
                ]);
              },
              $doc: "S.indices(len) -> (start, stop, stride)\n\nAssuming a sequence of length len, calculate the start and stop\nindices, and the stride length of the extended slice described by\nS. Out of bounds indices are clipped in a manner consistent with the\nhandling of normal slices.",
              $textsig: null,
              $flags: { OneArg: true }
            }
          }
        ),
        proto: (
          /**@lends {Sk.builtin.slice.prototype} */
          {
            slice$as_indices(sized) {
              let start, stop, step;
              const msg = "slice indices must be integers or None or have an __index__ method";
              let getIndex;
              if (sized) {
                getIndex = (idx) => Sk.misceval.asIndexSized(idx, null, msg);
              } else {
                getIndex = (idx) => Sk.misceval.asIndexOrThrow(idx, msg);
              }
              if (Sk.builtin.checkNone(this.step)) {
                step = 1;
              } else {
                step = getIndex(this.step);
                if (step === 0) {
                  throw new Sk.builtin.ValueError("slice step cannot be zero");
                }
              }
              if (Sk.builtin.checkNone(this.start)) {
                start = null;
              } else {
                start = getIndex(this.start);
              }
              if (Sk.builtin.checkNone(this.stop)) {
                stop = null;
              } else {
                stop = getIndex(this.stop);
              }
              return { start, stop, step };
            },
            $wrt(length, start, stop, step, sized) {
              let idxFromNeg;
              if (sized) {
                idxFromNeg = (idx) => JSBI.__isBigInt(idx) ? JSBI.add(idx, JSBI.BigInt(length)) : idx + length;
              } else {
                idxFromNeg = (idx) => idx + length;
              }
              if (step > 0) {
                if (start === null) {
                  start = 0;
                } else if (start < 0) {
                  start = idxFromNeg(start);
                  if (start < 0) {
                    start = 0;
                  }
                }
                if (stop === null) {
                  stop = length;
                } else if (stop > length) {
                  stop = length;
                } else if (stop < 0) {
                  stop = idxFromNeg(stop);
                }
              } else {
                if (start === null) {
                  start = length - 1;
                } else if (start >= length) {
                  start = length - 1;
                } else if (start < 0) {
                  start = idxFromNeg(start);
                }
                if (stop === null) {
                  stop = -1;
                } else if (stop < 0) {
                  stop = idxFromNeg(stop);
                  if (stop < 0) {
                    stop = -1;
                  }
                }
              }
              return { start, stop, step };
            },
            slice$indices(length, sized) {
              let { start, stop, step } = this.slice$as_indices(true, sized);
              return this.$wrt(length, start, stop, step, sized);
            },
            /**
             * used by objects like str, list, tuple that can return a slice
             * @param {number} len
             * @param {Function} f
             */
            sssiter$(len, f) {
              let { start, stop, step } = this.slice$indices(len, true);
              if (step > 0) {
                for (let i = start; i < stop; i += step) {
                  f(i);
                }
              } else {
                for (let i = start; i > stop; i += step) {
                  f(i);
                }
              }
            }
          }
        ),
        flags: {
          sk$unacceptableBase: true
        }
      });
      Sk.builtin.slice.startEnd$wrt = function(pyObj, start, end) {
        const len = pyObj.sq$length();
        const msg = "slice indices must be integers or have an __index__ method";
        if (start === void 0 || Sk.builtin.checkNone(start)) {
          start = 0;
        } else {
          start = Sk.misceval.asIndexSized(start, null, msg);
          if (start < 0) {
            start = start + len;
            if (start < 0) {
              start = 0;
            }
          }
        }
        if (end === void 0 || Sk.builtin.checkNone(end)) {
          end = len;
        } else {
          end = Sk.misceval.asIndexSized(end, null, msg);
          if (end < 0) {
            end = end + len;
            if (end < 0) {
              end = 0;
            }
          } else if (end > len) {
            end = len;
          }
        }
        return { start, end };
      };
    }
  });

  // src/set.js
  var require_set = __commonJS({
    "src/set.js"() {
      var set_private_ = {};
      Sk.builtin.set = Sk.abstr.buildNativeClass("set", {
        constructor: function set(S) {
          if (S === void 0) {
            S = [];
          } else if (!Array.isArray(S)) {
            S = Sk.misceval.arrayFromIterable(S);
          }
          Sk.asserts.assert(
            this instanceof Sk.builtin.set,
            "Bad call to set - must be called with an Array and 'new'"
          );
          const L = [];
          for (let i = 0; i < S.length; i++) {
            L.push(S[i]);
            L.push(true);
          }
          this.v = new Sk.builtin.dict(L);
          this.in$repr = false;
        },
        slots: (
          /**@lends {Sk.builtin.set.prototype}*/
          {
            tp$getattr: Sk.generic.getAttr,
            tp$as_number: true,
            tp$as_sequence_or_mapping: true,
            tp$hash: Sk.builtin.none.none$,
            tp$doc: "set() -> new empty set object\nset(iterable) -> new set object\n\nBuild an unordered collection of unique elements.",
            tp$init(args, kwargs) {
              Sk.abstr.checkNoKwargs("set", kwargs);
              Sk.abstr.checkArgsLen("set", args, 0, 1);
              this.set$clear();
              const iterable = args[0];
              return iterable && this.set$update(iterable);
            },
            tp$new: Sk.generic.new,
            $r() {
              if (this.in$repr) {
                return new Sk.builtin.str(Sk.abstr.typeName(this) + "(...)");
              }
              this.in$repr = true;
              const ret = this.sk$asarray().map((x) => Sk.misceval.objectRepr(x));
              this.in$repr = false;
              if (Sk.__future__.python3) {
                if (ret.length === 0) {
                  return new Sk.builtin.str(Sk.abstr.typeName(this) + "()");
                } else if (this.ob$type !== Sk.builtin.set) {
                  return new Sk.builtin.str(
                    Sk.abstr.typeName(this) + "({" + ret.join(", ") + "})"
                  );
                } else {
                  return new Sk.builtin.str("{" + ret.join(", ") + "}");
                }
              } else {
                return new Sk.builtin.str(Sk.abstr.typeName(this) + "([" + ret.join(", ") + "])");
              }
            },
            tp$iter() {
              return new set_iter_(this);
            },
            tp$richcompare(other, op) {
              if (!Sk.builtin.checkAnySet(other)) {
                return Sk.builtin.NotImplemented.NotImplemented$;
              }
              switch (op) {
                case "NotEq":
                case "Eq":
                  let res;
                  if (this === other) {
                    res = true;
                  } else if (this.get$size() !== other.get$size()) {
                    res = false;
                  } else {
                    res = Sk.misceval.isTrue(this.set$issubset(other));
                  }
                  return op === "Eq" ? res : !res;
                case "LtE":
                  return this === other || Sk.misceval.isTrue(this.set$issubset(other));
                case "GtE":
                  return this === other || Sk.misceval.isTrue(other.set$issubset(this));
                case "Lt":
                  return this.get$size() < other.get$size() && Sk.misceval.isTrue(this.set$issubset(other));
                case "Gt":
                  return this.get$size() > other.get$size() && Sk.misceval.isTrue(other.set$issubset(this));
              }
            },
            // number slots
            nb$subtract: numberSlot(function(other) {
              return this.difference.$meth.call(this, other);
            }),
            nb$and: numberSlot(function(other) {
              return this.intersection.$meth.call(this, other);
            }),
            nb$or: numberSlot(function(other) {
              return this.union.$meth.call(this, other);
            }),
            nb$xor: numberSlot(function(other) {
              return this.symmetric_difference.$meth.call(this, other);
            }),
            nb$inplace_subtract: numberSlot(function(other) {
              if (other === this) {
                other = other.set$copy();
              }
              return Sk.misceval.chain(this.difference_update.$meth.call(this, other), () => this);
            }),
            nb$inplace_and: numberSlot(function(other) {
              return Sk.misceval.chain(this.intersection_update.$meth.call(this, other), () => this);
            }),
            nb$inplace_or: numberSlot(function(other) {
              return Sk.misceval.chain(this.update.$meth.call(this, other), () => this);
            }),
            nb$inplace_xor: numberSlot(function(other) {
              if (other === this) {
                other = other.set$copy();
              }
              return Sk.misceval.chain(
                this.symmetric_difference_update.$meth.call(this, other),
                () => this
              );
            }),
            // sequence or mapping slots
            sq$length() {
              return this.get$size();
            },
            sq$contains(entry) {
              entry = entry_or_hashable_set(entry);
              return this.v.sq$contains(entry);
            }
          }
        ),
        methods: (
          /**@lends {Sk.builtin.set.prototype}*/
          {
            add: {
              $meth(item) {
                this.set$add(item);
                return Sk.builtin.none.none$;
              },
              $flags: { OneArg: true },
              $textsig: null,
              $doc: "Add an element to a set.\n\nThis has no effect if the element is already present."
            },
            clear: {
              $meth() {
                this.set$clear();
                return Sk.builtin.none.none$;
              },
              $flags: { NoArgs: true },
              $textsig: null,
              $doc: "Remove all elements from this set."
            },
            copy: {
              $meth() {
                return this.set$copy();
              },
              $flags: { NoArgs: true },
              $textsig: null,
              $doc: "Return a shallow copy of a set."
            },
            discard: {
              $meth(entry) {
                entry = entry_or_hashable_set(entry);
                this.set$discard(entry);
                return Sk.builtin.none.none$;
              },
              $flags: { OneArg: true },
              $textsig: null,
              $doc: "Remove an element from a set if it is a member.\n\nIf the element is not a member, do nothing."
            },
            difference: {
              $meth(...args) {
                const result = this.set$copy();
                return Sk.misceval.chain(
                  Sk.misceval.iterArray(args, (arg) => result.set$difference_update(arg)),
                  () => result
                );
              },
              $flags: { MinArgs: 0 },
              $textsig: null,
              $doc: "Return the difference of two or more sets as a new set.\n\n(i.e. all elements that are in this set but not the others.)"
            },
            difference_update: {
              $meth(...args) {
                return Sk.misceval.chain(
                  Sk.misceval.iterArray(args, (arg) => this.set$difference_update(arg)),
                  () => Sk.builtin.none.none$
                );
              },
              $flags: { MinArgs: 0 },
              $textsig: null,
              $doc: "Remove all elements of another set from this set."
            },
            intersection: {
              $meth(...args) {
                return this.set$intersection_multi(...args);
              },
              $flags: { MinArgs: 0 },
              $textsig: null,
              $doc: "Return the intersection of two sets as a new set.\n\n(i.e. all elements that are in both sets.)"
            },
            intersection_update: {
              $meth(...args) {
                return Sk.misceval.chain(this.set$intersection_multi(...args), (res) => {
                  this.swap$bodies(res);
                  return Sk.builtin.none.none$;
                });
              },
              $flags: { MinArgs: 0 },
              $textsig: null,
              $doc: "Update a set with the intersection of itself and another."
            },
            isdisjoint: {
              $meth(other) {
                return Sk.misceval.chain(
                  Sk.misceval.iterFor(Sk.abstr.iter(other), (i) => {
                    if (this.sq$contains(i)) {
                      return new Sk.misceval.Break(Sk.builtin.bool.false$);
                    }
                  }),
                  (res) => res || Sk.builtin.bool.true$
                );
              },
              $flags: { OneArg: true },
              $textsig: null,
              $doc: "Return True if two sets have a null intersection."
            },
            issubset: {
              $meth(other) {
                if (!Sk.builtin.checkAnySet(other)) {
                  other = this.set$make_basetype(other);
                }
                return Sk.misceval.chain(other, (other_set) => this.set$issubset(other_set));
              },
              $flags: { OneArg: true },
              $textsig: null,
              $doc: "Report whether another set contains this set."
            },
            issuperset: {
              $meth(other) {
                if (!Sk.builtin.checkAnySet(other)) {
                  other = this.set$make_basetype(other);
                }
                return Sk.misceval.chain(other, (other_set) => other_set.set$issubset(this));
              },
              $flags: { OneArg: true },
              $textsig: null,
              $doc: "Report whether this set contains another set."
            },
            pop: {
              $meth() {
                if (this.get$size() === 0) {
                  throw new Sk.builtin.KeyError("pop from an empty set");
                }
                const item = Sk.misceval.callsimArray(this.v.popitem, [this.v]);
                return item.v[0];
              },
              $flags: { NoArgs: true },
              $textsig: null,
              $doc: "Remove and return an arbitrary set element.\nRaises KeyError if the set is empty."
            },
            // __reduce__: {
            //     $meth: methods.$__reduce__,
            //     $flags:{},
            //     $textsig: null,
            //     $doc: "Return state information for pickling." },
            remove: {
              $meth(entry) {
                const tmp = entry_or_hashable_set(entry);
                if (this.v.mp$lookup(tmp)) {
                  this.v.mp$ass_subscript(tmp);
                  return Sk.builtin.none.none$;
                }
                throw new Sk.builtin.KeyError(entry);
              },
              $flags: { OneArg: true },
              $textsig: null,
              $doc: "Remove an element from a set; it must be a member.\n\nIf the element is not a member, raise a KeyError."
            },
            // __sizeof__: {
            //     $meth: methods.$__sizeof__,
            //     $flags:{},
            //     $textsig: null,
            //     $doc: "S.__sizeof__() -> size of S in memory, in bytes" },
            symmetric_difference: {
              $meth(other) {
                let other_set;
                return Sk.misceval.chain(
                  this.set$make_basetype(other),
                  (os) => {
                    other_set = os;
                    return other_set.set$symmetric_diff_update(this);
                  },
                  () => other_set
                );
              },
              $flags: { OneArg: true },
              $textsig: null,
              $doc: "Return the symmetric difference of two sets as a new set.\n\n(i.e. all elements that are in exactly one of the sets.)"
            },
            symmetric_difference_update: {
              $meth(other) {
                if (!Sk.builtin.checkAnySet(other)) {
                  other = this.set$make_basetype(other);
                }
                return Sk.misceval.chain(
                  other,
                  (other_set) => this.set$symmetric_diff_update(other_set),
                  () => Sk.builtin.none.none$
                );
              },
              $flags: { OneArg: true },
              $textsig: null,
              $doc: "Update a set with the symmetric difference of itself and another."
            },
            union: {
              $meth(...args) {
                const result = this.set$copy();
                return Sk.misceval.chain(
                  Sk.misceval.iterArray(args, (arg) => result.set$update(arg)),
                  () => result
                );
              },
              $flags: { MinArgs: 0 },
              $textsig: null,
              $doc: "Return the union of sets as a new set.\n\n(i.e. all elements that are in either set.)"
            },
            update: {
              $meth(...args) {
                return Sk.misceval.chain(
                  Sk.misceval.iterArray(args, (arg) => this.set$update(arg)),
                  () => Sk.builtin.none.none$
                );
              },
              $flags: { MinArgs: 0 },
              $textsig: null,
              $doc: "Update a set with the union of itself and others."
            }
          }
        ),
        classmethods: Sk.generic.classGetItem,
        proto: (
          /**@lends {Sk.builtin.set.prototype}*/
          Object.assign(set_private_, {
            sk$asarray() {
              return this.v.sk$asarray();
            },
            get$size() {
              return this.v.sq$length();
            },
            set$add(entry) {
              this.v.mp$ass_subscript(entry, true);
            },
            set$make_basetype(other) {
              return Sk.misceval.chain(
                Sk.misceval.arrayFromIterable(other, true),
                (S) => new this.sk$builtinBase(S)
              );
            },
            set$discard(entry) {
              return this.v.pop$item(entry);
            },
            set$clear() {
              this.v = new Sk.builtin.dict([]);
            },
            set$copy() {
              const setCopy = new this.sk$builtinBase();
              setCopy.v = this.v.dict$copy();
              return setCopy;
            },
            set$difference_update(other) {
              return Sk.misceval.iterFor(Sk.abstr.iter(other), (entry) => {
                this.set$discard(entry);
              });
            },
            set$intersection(other) {
              const res = new this.sk$builtinBase();
              return Sk.misceval.chain(
                Sk.misceval.iterFor(Sk.abstr.iter(other), (entry) => {
                  if (this.sq$contains(entry)) {
                    res.set$add(entry);
                  }
                }),
                () => res
              );
            },
            set$intersection_multi(...args) {
              if (!args.length) {
                return this.set$copy();
              }
              let result = this;
              return Sk.misceval.chain(
                Sk.misceval.iterArray(args, (arg) => {
                  return Sk.misceval.chain(result.set$intersection(arg), (res) => {
                    result = res;
                  });
                }),
                () => result
              );
            },
            set$issubset(other_set) {
              const thisLength = this.get$size();
              const otherLength = other_set.get$size();
              if (thisLength > otherLength) {
                return Sk.builtin.bool.false$;
              }
              for (let it = this.tp$iter(), i = it.tp$iternext(); i !== void 0; i = it.tp$iternext()) {
                if (!other_set.sq$contains(i)) {
                  return Sk.builtin.bool.false$;
                }
              }
              return Sk.builtin.bool.true$;
            },
            set$symmetric_diff_update(other) {
              return Sk.misceval.iterFor(Sk.abstr.iter(other), (entry) => {
                const discarded = this.set$discard(entry);
                if (discarded === void 0) {
                  this.set$add(entry);
                }
              });
            },
            set$update(other) {
              return Sk.misceval.iterFor(Sk.abstr.iter(other), (entry) => {
                this.set$add(entry);
              });
            },
            swap$bodies(other) {
              this.v = other.v;
            }
          })
        )
      });
      Sk.exportSymbol("Sk.builtin.set", Sk.builtin.set);
      var set_proto = Sk.builtin.set.prototype;
      Sk.builtin.frozenset = Sk.abstr.buildNativeClass("frozenset", {
        constructor: function frozenset(S) {
          if (S === void 0) {
            S = [];
          } else if (!Array.isArray(S)) {
            S = Sk.misceval.arrayFromIterable(S);
          }
          Sk.asserts.assert(
            this instanceof Sk.builtin.frozenset,
            "bad call to frozen set - must be called with 'new'"
          );
          const L = [];
          for (let i = 0; i < S.length; i++) {
            L.push(S[i]);
            L.push(true);
          }
          this.v = new Sk.builtin.dict(L);
          this.in$repr = false;
        },
        slots: (
          /**@lends {Sk.builtin.frozenset.prototype}*/
          {
            tp$getattr: Sk.generic.getAttr,
            tp$as_number: true,
            tp$as_sequence_or_mapping: true,
            tp$doc: "frozenset() -> empty frozenset object\nfrozenset(iterable) -> frozenset object\n\nBuild an immutable unordered collection of unique elements.",
            tp$hash() {
              let hash = 1927868237;
              const entries = this.sk$asarray();
              hash *= entries.length + 1;
              for (let i = 0; i < entries.length; i++) {
                const h = Sk.abstr.objectHash(entries[i]);
                hash ^= (h ^ h << 16 ^ 89869747) * 3644798167;
              }
              hash = hash * 69069 + 907133923;
              return hash;
            },
            /**
             * @param {Array} args
             * @param {Array=} kwargs
             * @ignore
             */
            tp$new(args, kwargs) {
              if (this !== Sk.builtin.frozenset.prototype) {
                return this.$subtype_new(args, kwargs);
              }
              Sk.abstr.checkNoKwargs("frozenset", kwargs);
              Sk.abstr.checkArgsLen("frozenset", args, 0, 1);
              const arg = args[0];
              if (arg !== void 0 && arg.ob$type === Sk.builtin.frozenset) {
                return arg;
              }
              return Sk.misceval.chain(Sk.misceval.arrayFromIterable(arg, true), (S) => {
                if (!S.length) {
                  return Sk.builtin.frozenset.$emptyset;
                }
                return new Sk.builtin.frozenset(S);
              });
            },
            $r: set_proto.$r,
            tp$iter: set_proto.tp$iter,
            tp$richcompare: set_proto.tp$richcompare,
            // number slots
            nb$subtract: set_proto.nb$subtract,
            nb$and: set_proto.nb$and,
            nb$or: set_proto.nb$or,
            nb$xor: set_proto.nb$xor,
            // as mapping
            sq$length: set_proto.sq$length,
            sq$contains: set_proto.sq$contains
          }
        ),
        methods: (
          /**@lends {Sk.builtin.frozenset.prototype}*/
          {
            copy: Object.assign({}, set_proto.copy.d$def, {
              $meth() {
                return this.constructor === this.sk$builtinBase ? this : new Sk.builtin.frozenset(this.sk$asarray());
              }
            }),
            difference: set_proto.difference.d$def,
            intersection: set_proto.intersection.d$def,
            isdisjoint: set_proto.isdisjoint.d$def,
            issubset: set_proto.issubset.d$def,
            issuperset: set_proto.issuperset.d$def,
            // __reduce__: set_proto.__reduce__,
            // __sizeof__: set_proto.__sizeof__,
            symmetric_difference: set_proto.symmetric_difference.d$def,
            union: set_proto.union.d$def
          }
        ),
        classmethods: Sk.generic.classGetItem,
        proto: (
          /**@lends {Sk.builtin.frozenset.prototype}*/
          Object.assign(
            {
              $subtype_new(args, kwargs) {
                const instance = new this.constructor();
                return Sk.misceval.chain(
                  Sk.builtin.frozenset.prototype.tp$new(args),
                  (frozenset) => {
                    instance.v = frozenset.v;
                    return instance;
                  }
                );
              }
            },
            set_private_
          )
        )
      });
      Sk.builtin.frozenset.$emptyset = Object.create(Sk.builtin.frozenset.prototype, {
        v: { value: new Sk.builtin.dict([]), enumerable: true },
        in$repr: { value: false, enumerable: true }
      });
      Sk.exportSymbol("Sk.builtin.frozenset", Sk.builtin.frozenset);
      function numberSlot(f) {
        return function(other) {
          if (!Sk.builtin.checkAnySet(other)) {
            return Sk.builtin.NotImplemented.NotImplemented$;
          }
          return f.call(this, other);
        };
      }
      function entry_or_hashable_set(entry) {
        if (entry instanceof Sk.builtin.set && entry.tp$hash === Sk.builtin.none.none$) {
          entry = new Sk.builtin.frozenset(Sk.misceval.arrayFromIterable(entry));
        }
        return entry;
      }
      var set_iter_ = Sk.abstr.buildIteratorClass("set_iterator", {
        constructor: function set_iter_2(set) {
          this.$index = 0;
          this.$seq = set.sk$asarray();
          this.$orig = set;
        },
        iternext: Sk.generic.iterNextWithArrayCheckSize,
        methods: {
          __length_hint__: Sk.generic.iterLengthHintWithArrayMethodDef
        },
        flags: { sk$unacceptableBase: true }
      });
    }
  });

  // src/print.js
  var require_print = __commonJS({
    "src/print.js"() {
      Sk.builtin.print = function print(args, kwargs) {
        let [sep, end, file] = Sk.abstr.copyKeywordsToNamedArgs(
          "print",
          ["sep", "end", "file", "flush"],
          [],
          kwargs
        );
        if (sep === void 0 || Sk.builtin.checkNone(sep)) {
          sep = " ";
        } else if (Sk.builtin.checkString(sep)) {
          sep = sep.$jsstr();
        } else {
          throw new Sk.builtin.TypeError(
            "sep must be None or a string, not " + Sk.abstr.typeName(sep)
          );
        }
        if (end === void 0 || Sk.builtin.checkNone(end)) {
          end = "\n";
        } else if (Sk.builtin.checkString(end)) {
          end = end.$jsstr();
        } else {
          throw new Sk.builtin.TypeError(
            "end must be None or a string, not " + Sk.abstr.typeName(end)
          );
        }
        let file_write;
        if (file !== void 0 && !Sk.builtin.checkNone(file)) {
          file_write = Sk.abstr.lookupSpecial(file, Sk.builtin.str.$write);
          if (file_write === void 0) {
            throw new Sk.builtin.AttributeError(
              "'" + Sk.abstr.typeName(file) + "' object has no attribute 'write'"
            );
          }
        }
        const output = new Sk.builtin.str(
          args.map((x) => new Sk.builtin.str(x).toString()).join(sep) + end
        );
        if (file_write !== void 0) {
          Sk.misceval.callsimArray(file_write, [output]);
        } else {
          return Sk.misceval.chain(Sk.importModule("sys", false, true), (sys) => {
            file_write = Sk.abstr.lookupSpecial(sys.$d.stdout, Sk.builtin.str.$write);
            return file_write && Sk.misceval.callsimOrSuspendArray(file_write, [output]);
          });
        }
        return Sk.builtin.none.none$;
      };
      Sk.builtin.print.co_fastcall = 1;
    }
  });

  // src/module.js
  var require_module = __commonJS({
    "src/module.js"() {
      Sk.builtin.module = Sk.abstr.buildNativeClass("module", {
        constructor: function module_() {
          this.$d = {};
        },
        slots: {
          tp$doc: "Create a module object.\n\nThe name must be a string; the optional doc argument can have any type.",
          tp$getattr(pyName, canSuspend) {
            let customGetAttr = this.$d["__getattr__"];
            if (customGetAttr) {
              const ret2 = Sk.misceval.callsimArray(customGetAttr, [pyName]);
              if (ret2 !== void 0) {
                return ret2;
              }
            }
            const jsMangled = pyName.$mangled;
            const ret = this.$d[jsMangled];
            if (ret !== void 0) {
              return ret;
            }
            const descr = this.ob$type.$typeLookup(pyName);
            if (descr !== void 0) {
              const f = descr.tp$descr_get;
              if (f) {
                return f.call(descr, this, this.ob$type, canSuspend);
              }
              return descr;
            }
            const getattr = this.$d.__getattr__;
            if (getattr !== void 0) {
              const res = Sk.misceval.tryCatch(
                () => Sk.misceval.callsimOrSuspendArray(getattr, [pyName]),
                (e) => {
                  if (e instanceof Sk.builtin.AttributeError) {
                    return;
                  }
                  throw e;
                }
              );
              return canSuspend ? res : Sk.misceval.retryOptionalSuspensionOrThrow(res);
            }
          },
          tp$setattr: Sk.generic.setAttr,
          tp$new: Sk.generic.new,
          tp$init(args, kwargs) {
            const [name, doc] = Sk.abstr.copyKeywordsToNamedArgs(
              "module",
              ["name", "doc"],
              args,
              kwargs,
              [Sk.builtin.none.none$]
            );
            Sk.builtin.pyCheckType("module", "string", name);
            this.init$dict(name, doc);
          },
          $r() {
            let name = this.get$name();
            if (name !== void 0) {
              const module_reprf = this.get$mod_reprf();
              if (module_reprf !== void 0) {
                return Sk.misceval.callsimOrSuspendArray(module_reprf, [this]);
              }
            }
            name = name === void 0 ? "'?'" : name;
            let extra = this.from$file();
            extra = extra === void 0 ? this.empty_or$loader() : extra;
            return new Sk.builtin.str("<module " + name + extra + ">");
          }
        },
        getsets: {
          __dict__: {
            $get() {
              return new Sk.builtin.mappingproxy(this.$d);
            }
          }
        },
        methods: {
          __dir__: {
            $meth() {
              const dict = this.tp$getattr(Sk.builtin.str.$dict);
              if (!Sk.builtin.checkMapping(dict)) {
                throw new Sk.builtin.TypeError("__dict__ is not a dictionary");
              }
              const dirfunc = dict.mp$lookup(Sk.builtin.str.$dir);
              if (dirfunc !== void 0) {
                return Sk.misceval.callsimOrSuspendArray(dirfunc, []);
              } else {
                return new Sk.builtin.list(Sk.misceval.arrayFromIterable(dict));
              }
            },
            $flags: { NoArgs: true },
            $doc: "__dir__() -> list\nspecialized dir() implementation"
          }
        },
        proto: {
          init$dict(name, doc) {
            this.$d.__name__ = name;
            this.$d.__doc__ = doc;
            this.$d.__package__ = Sk.builtin.none.none$;
            this.$d.__spec__ = Sk.builtin.none.none$;
            this.$d.__loader__ = Sk.builtin.none.none$;
          },
          sk$attrError() {
            let name = this.get$name();
            name = name === void 0 ? "module" : "module " + name;
            if (this.$initializing) {
              name = "(most likely due to a circular import) partially initialized " + name;
            }
            return name;
          },
          get$name() {
            const name = this.tp$getattr(Sk.builtin.str.$name);
            return name && Sk.misceval.objectRepr(name);
          },
          from$file() {
            const file = this.tp$getattr(Sk.builtin.str.$file);
            return file && " from " + Sk.misceval.objectRepr(file);
          },
          empty_or$loader() {
            if (this.$js && this.$js.includes("$builtinmodule")) {
              return " (built-in)";
            }
            const loader = this.tp$getattr(Sk.builtin.str.$loader);
            return loader === void 0 || Sk.builtin.checkNone(loader) ? "" : " (" + Sk.misceval.objectRepr(loader) + ")";
          },
          get$mod_reprf() {
            const loader = this.tp$getattr(Sk.builtin.str.$loader);
            return loader && loader.tp$getattr(this.str$mod_repr);
          },
          str$mod_repr: new Sk.builtin.str("module_repr")
        }
      });
      Sk.exportSymbol("Sk.builtin.module", Sk.builtin.module);
    }
  });

  // src/structseq.js
  var require_structseq = __commonJS({
    "src/structseq.js"() {
      Sk.builtin.structseq_types = {};
      Sk.builtin.make_structseq = function(module2, name, visible_fields, hidden_fields = {}, doc = null) {
        const nm = module2 + "." + name;
        const flds = [];
        const getsets = {};
        Object.keys(visible_fields).forEach((key, i) => {
          flds.push(key);
          getsets[key] = {
            $get() {
              return this.v[i];
            },
            $doc: visible_fields[key]
          };
        });
        const n_flds = flds.length;
        let n_total_flds = n_flds;
        Object.keys(hidden_fields).forEach((key, i) => {
          getsets[key] = {
            $get() {
              return this.$hidden[i] || Sk.builtin.none.none$;
            },
            $doc: hidden_fields[key]
          };
          n_total_flds++;
        });
        var structseq = Sk.abstr.buildNativeClass(nm, {
          constructor: function structseq_constructor(v, hidden) {
            Sk.asserts.assert(this instanceof structseq);
            Sk.builtin.tuple.call(this, v);
            this.$hidden = hidden || [];
          },
          base: Sk.builtin.tuple,
          slots: {
            tp$new(args, kwargs) {
              Sk.abstr.checkOneArg(nm, args, kwargs);
              const arg = Sk.misceval.arrayFromIterable(args[0]);
              if (arg.length < n_flds) {
                throw new Sk.builtin.TypeError(
                  nm + "() takes an at least " + n_flds + "-sequence (" + arg.length + "-sequence given)"
                );
              } else if (arg.length > n_total_flds) {
                throw new Sk.builtin.TypeError(
                  nm + "() takes an at most " + n_total_flds + "-sequence (" + arg.length + "-sequence given)"
                );
              }
              return new structseq(arg.slice(0, n_flds), arg.slice(n_flds));
            },
            tp$doc: doc ? doc : Sk.builtin.none.none$,
            $r() {
              var ret;
              var i;
              var bits;
              if (this.v.length === 0) {
                return new Sk.builtin.str(nm + "()");
              }
              bits = [];
              for (i = 0; i < flds.length; ++i) {
                bits[i] = flds[i] + "=" + Sk.misceval.objectRepr(this.v[i]);
              }
              ret = bits.join(", ");
              if (this.v.length === 1) {
                ret += ",";
              }
              return new Sk.builtin.str(nm + "(" + ret + ")");
            }
          },
          methods: {
            __reduce__: {
              $meth() {
                throw new Sk.builtin.NotImplementedError("__reduce__ is not implemented");
              },
              $flags: { NoArgs: true }
            }
          },
          getsets,
          proto: {
            num_sequence_fields: new Sk.builtin.int_(n_flds)
          }
        });
        return structseq;
      };
      Sk.exportSymbol("Sk.builtin.make_structseq", Sk.builtin.make_structseq);
    }
  });

  // src/generator.js
  var require_generator = __commonJS({
    "src/generator.js"() {
      Sk.builtin.generator = Sk.abstr.buildIteratorClass("generator", {
        constructor: function generator(code, globals, args, closure, closure2) {
          var k;
          var i;
          if (!code) {
            return;
          }
          if (!(this instanceof Sk.builtin.generator)) {
            throw new TypeError("bad internal call to generator, use 'new'");
          }
          this.func_code = code;
          this.func_globals = globals || null;
          this.gi$running = false;
          this.gi$resumeat = 0;
          this.gi$sentvalue = Sk.builtin.none.none$;
          this.gi$locals = {};
          this.gi$cells = {};
          if (args.length > 0) {
            for (i = 0; i < code.co_varnames.length; ++i) {
              this.gi$locals[code.co_varnames[i]] = args[i];
            }
          }
          if (closure2 !== void 0) {
            for (k in closure2) {
              closure[k] = closure2[k];
            }
          }
          this.func_closure = closure;
        },
        slots: {
          $r() {
            return new Sk.builtin.str("<generator object " + this.func_code.co_name.v + ">");
          }
        },
        iternext(canSuspend, yielded) {
          var ret;
          var args;
          var self2 = this;
          if (this.gi$running) {
            throw new Sk.builtin.ValueError("generator already executing");
          }
          this["gi$running"] = true;
          if (yielded === void 0) {
            yielded = Sk.builtin.none.none$;
          }
          this["gi$sentvalue"] = yielded;
          args = [this];
          if (this.func_closure) {
            args.push(this.func_closure);
          }
          ret = this.func_code.apply(this.func_globals, args);
          return (function finishIteration(ret2) {
            if (ret2 instanceof Sk.misceval.Suspension) {
              if (canSuspend) {
                return new Sk.misceval.Suspension(finishIteration, ret2);
              } else {
                ret2 = Sk.misceval.retryOptionalSuspensionOrThrow(ret2);
              }
            }
            self2["gi$running"] = false;
            Sk.asserts.assert(ret2 !== void 0);
            if (Array.isArray(ret2)) {
              self2["gi$resumeat"] = ret2[0];
              ret2 = ret2[1];
            } else {
              self2.gi$ret = ret2;
              return void 0;
            }
            return ret2;
          })(ret);
        },
        methods: {
          send: {
            $meth(value) {
              return Sk.misceval.chain(this.tp$iternext(true, value), (ret) => {
                if (ret === void 0) {
                  const v = this.gi$ret;
                  throw v !== void 0 && v !== Sk.builtin.none.none$ ? new Sk.builtin.StopIteration(v) : new Sk.builtin.StopIteration();
                }
                return ret;
              });
            },
            $flags: { OneArg: true },
            $doc: "send(arg) -> send 'arg' into generator,\nreturn next yielded value or raise StopIteration."
          }
        }
      });
      Sk.exportSymbol("Sk.builtin.generator", Sk.builtin.generator);
      Sk.builtin.makeGenerator = function(next, data) {
        var key;
        var gen = new Sk.builtin.generator(null, null, null);
        gen.tp$iternext = next;
        for (key in data) {
          if (data.hasOwnProperty(key)) {
            gen[key] = data[key];
          }
        }
        return gen;
      };
      Sk.exportSymbol("Sk.builtin.makeGenerator", Sk.builtin.makeGenerator);
    }
  });

  // src/file.js
  var require_file = __commonJS({
    "src/file.js"() {
      var STDOUT_FILENO = 1;
      var STDIN_FILENO = 0;
      var STDERR_FILENO = 2;
      Sk.builtin.file = function(name, mode, buffering, encoding, errors, newline, closefd, opener) {
        var i;
        var elem;
        if (!(this instanceof Sk.builtin.file)) {
          return new Sk.builtin.file(name, mode, buffering);
        }
        this.mode = mode;
        this.name = Sk.ffi.remapToJs(name);
        this.buffering = Sk.ffi.remapToJs(buffering);
        this.encoding = Sk.ffi.remapToJs(encoding);
        this.errors = Sk.ffi.remapToJs(errors);
        if (Sk.builtin.checkNone(newline)) {
          this.newline = "\n";
        } else {
          this.newline = Sk.ffi.remapToJs(newline);
        }
        this.closefd = Sk.ffi.remapToJs(closefd);
        this.opener = Sk.ffi.remapToJs(opener);
        this.closed = false;
        if (this.name === "/dev/stdout") {
          this.data$ = Sk.builtin.none.none$;
          this.fileno = STDOUT_FILENO;
        } else if (this.name === "/dev/stdin") {
          this.fileno = STDIN_FILENO;
        } else if (this.name === "/dev/stderr") {
          this.fileno = STDERR_FILENO;
        } else {
          if (Sk.inBrowser) {
            this.fileno = 10;
            this.data$ = Sk.inBrowser(this.name);
          } else {
            this.fileno = 11;
            this.data$ = Sk.read(name.v);
          }
          this.lineList = splitLines(this.data$, this.newline, Sk.inBrowser);
          this.currentLine = 0;
        }
        this.pos$ = 0;
        this.__class__ = Sk.builtin.file;
        if (Sk.fileopen && this.fileno >= 10) {
          Sk.fileopen(this);
        }
        return this;
      };
      function splitLines(text, newline, inBrowser) {
        if (newline === "") {
          newline = "\n";
        }
        let lineList = text.split(newline);
        if (inBrowser && lineList.length) {
          if (lineList[lineList.length - 1] === "") {
            lineList = lineList.slice(0, -1);
          }
        }
        for (let i = 0; i < lineList.length - 1; i += 1) {
          lineList[i] = lineList[i] + newline;
        }
        return lineList;
      }
      Sk.abstr.setUpInheritance("file", Sk.builtin.file, Sk.builtin.object);
      Sk.abstr.setUpBuiltinMro(Sk.builtin.file);
      Sk.builtin.file.prototype["$r"] = function() {
        return new Sk.builtin.str(
          "<" + (this.closed ? "closed" : "open") + "file '" + this.name + "', mode '" + Sk.ffi.remapToJs(this.mode) + "'>"
        );
      };
      Sk.builtin.file.prototype.tp$iter = function() {
        var allLines = this.lineList;
        var that = this;
        var ret = {
          tp$iter: function() {
            return ret;
          },
          $obj: this,
          $index: this.currentLine,
          $lines: allLines,
          tp$iternext: function() {
            if (that.currentLine >= ret.$lines.length) {
              return void 0;
            }
            return new Sk.builtin.str(ret.$lines[that.currentLine++]);
          }
        };
        return ret;
      };
      Sk.abstr.setUpSlots(Sk.builtin.file);
      Sk.builtin.file.prototype["__enter__"] = new Sk.builtin.func(function __enter__(self2) {
        return self2;
      });
      Sk.builtin.file.prototype["__exit__"] = new Sk.builtin.func(function __exit__(self2) {
        return Sk.misceval.callsimArray(Sk.builtin.file.prototype["close"], [self2]);
      });
      Sk.builtin.file.prototype["close"] = new Sk.builtin.func(function close(self2) {
        self2.closed = true;
        return Sk.builtin.none.none$;
      });
      Sk.builtin.file.prototype["flush"] = new Sk.builtin.func(function flush(self2) {
      });
      Sk.builtin.file.prototype["fileno"] = new Sk.builtin.func(function fileno(self2) {
        return this.fileno;
      });
      Sk.builtin.file.prototype["isatty"] = new Sk.builtin.func(function isatty(self2) {
        return false;
      });
      Sk.builtin.file.prototype["read"] = new Sk.builtin.func(function read(self2, size) {
        var ret;
        var len = self2.data$.length;
        var l_size;
        if (self2.closed) {
          throw new Sk.builtin.ValueError("I/O operation on closed file");
        }
        if (size === void 0) {
          l_size = len;
        } else {
          l_size = Sk.ffi.remapToJs(size);
        }
        ret = new Sk.builtin.str(self2.data$.substr(self2.pos$, l_size));
        if (size === void 0) {
          self2.pos$ = len;
        } else {
          self2.pos$ += Sk.ffi.remapToJs(size);
        }
        if (self2.pos$ >= len) {
          self2.pos$ = len;
        }
        return ret;
      });
      Sk.builtin.file.$readline = function(self2, size, prompt) {
        if (self2.fileno === 0) {
          var x, susp;
          var lprompt = Sk.ffi.remapToJs(prompt);
          lprompt = lprompt ? lprompt : "";
          Sk.misceval.pauseTimer();
          x = Sk.inputfun(lprompt);
          if (x instanceof Promise || x && typeof x.then === "function") {
            susp = new Sk.misceval.Suspension();
            susp.resume = function() {
              if (susp.data.error) {
                throw susp.data.error;
              }
              Sk.misceval.unpauseTimer();
              return new Sk.builtin.str(susp.data.result);
            };
            susp.data = {
              type: "Sk.promise",
              promise: x
            };
            return susp;
          } else {
            Sk.misceval.unpauseTimer();
            return new Sk.builtin.str(x);
          }
        } else {
          var line = "";
          if (self2.currentLine < self2.lineList.length) {
            line = self2.lineList[self2.currentLine];
            self2.currentLine++;
          }
          return new Sk.builtin.str(line);
        }
      };
      Sk.builtin.file.prototype["readline"] = new Sk.builtin.func(function readline(self2, size) {
        return Sk.builtin.file.$readline(self2, size, void 0);
      });
      Sk.builtin.file.prototype["readlines"] = new Sk.builtin.func(function readlines(self2, sizehint) {
        if (self2.fileno === 0) {
          return new Sk.builtin.NotImplementedError(
            "readlines isn't implemented because the web doesn't support Ctrl+D"
          );
        }
        var i;
        var arr = [];
        for (i = self2.currentLine; i < self2.lineList.length; i++) {
          arr.push(new Sk.builtin.str(self2.lineList[i]));
        }
        return new Sk.builtin.list(arr);
      });
      Sk.builtin.file.prototype["seek"] = new Sk.builtin.func(function seek(self2, offset, whence) {
        var l_offset = Sk.ffi.remapToJs(offset);
        if (whence === void 0) {
          whence = 0;
        }
        if (whence === 0) {
          self2.pos$ = l_offset;
        } else if (whence == 1) {
          self2.pos$ = self2.data$.length + l_offset;
        } else if (whence == 2) {
          self2.pos$ = self2.data$.length + l_offset;
        }
        return Sk.builtin.none.none$;
      });
      Sk.builtin.file.prototype["tell"] = new Sk.builtin.func(function tell(self2) {
        return Sk.ffi.remapToPy(self2.pos$);
      });
      Sk.builtin.file.prototype["truncate"] = new Sk.builtin.func(function truncate(self2, size) {
        Sk.asserts.fail();
      });
      Sk.builtin.file.prototype["write"] = new Sk.builtin.func(function write(self2, str) {
        var mode = Sk.ffi.remapToJs(self2.mode);
        if (mode === "w" || mode === "wb" || mode === "a" || mode === "ab") {
          if (Sk.filewrite) {
            if (self2.closed) {
              throw new Sk.builtin.ValueError("I/O operation on closed file");
            }
            if (self2.fileno === 1) {
              Sk.output(Sk.ffi.remapToJs(str));
            } else {
              Sk.filewrite(self2, str);
            }
          } else {
            if (self2.fileno === 1) {
              Sk.output(Sk.ffi.remapToJs(str));
            } else {
              Sk.asserts.fail();
            }
          }
        } else {
          throw new Sk.builtin.IOError("File not open for writing");
        }
        return Sk.builtin.none.none$;
      });
      Sk.exportSymbol("Sk.builtin.file", Sk.builtin.file);
    }
  });

  // src/ffi.js
  var require_ffi = __commonJS({
    "src/ffi.js"() {
      Sk.ffi = Sk.ffi || {};
      Sk.ffi.remapToPy = function(obj) {
        var k;
        var kvs;
        var i;
        var arr;
        if (obj === null || typeof obj === "undefined") {
          return Sk.builtin.none.none$;
        }
        if (obj.ob$type) {
          return obj;
        }
        if (obj instanceof Sk.misceval.Suspension) {
          return obj;
        }
        if (Object.prototype.toString.call(obj) === "[object Array]") {
          arr = [];
          for (i = 0; i < obj.length; ++i) {
            arr.push(Sk.ffi.remapToPy(obj[i]));
          }
          return new Sk.builtin.list(arr);
        }
        if (typeof obj === "object") {
          kvs = [];
          for (k in obj) {
            kvs.push(Sk.ffi.remapToPy(k));
            kvs.push(Sk.ffi.remapToPy(obj[k]));
          }
          return new Sk.builtin.dict(kvs);
        }
        if (typeof obj === "string") {
          return new Sk.builtin.str(obj);
        }
        if (typeof obj === "number") {
          return Sk.builtin.assk$(obj);
        }
        if (typeof obj === "boolean") {
          return new Sk.builtin.bool(obj);
        } else if (typeof obj === "undefined") {
          return Sk.builtin.none.none$;
        }
        if (typeof obj === "function") {
          return new Sk.builtin.func(obj);
        }
        Sk.asserts.fail("unhandled remap type " + typeof obj);
      };
      Sk.exportSymbol("Sk.ffi.remapToPy", Sk.ffi.remapToPy);
      Sk.ffi.remapToJs = function(obj) {
        var i;
        var kAsJs;
        var ret;
        if (obj instanceof Sk.builtin.dict) {
          ret = {};
          obj.$items().forEach(([key, val]) => {
            kAsJs = Sk.ffi.remapToJs(key);
            ret[kAsJs] = Sk.ffi.remapToJs(val);
          });
          return ret;
        } else if (obj instanceof Sk.builtin.list || obj instanceof Sk.builtin.tuple) {
          ret = [];
          for (i = 0; i < obj.v.length; ++i) {
            ret.push(Sk.ffi.remapToJs(obj.v[i]));
          }
          return ret;
        } else if (obj instanceof Sk.builtin.bool) {
          return obj.v ? true : false;
        } else if (obj instanceof Sk.builtin.int_) {
          return Sk.builtin.asnum$(obj);
        } else if (obj instanceof Sk.builtin.float_) {
          return Sk.builtin.asnum$(obj);
        } else if (obj instanceof Sk.builtin.lng) {
          return Sk.builtin.asnum$(obj);
        } else if (typeof obj === "number" || typeof obj === "boolean" || typeof obj === "string") {
          return obj;
        } else if (obj === void 0) {
          return void 0;
        } else {
          return obj.v;
        }
      };
      Sk.exportSymbol("Sk.ffi.remapToJs", Sk.ffi.remapToJs);
      Sk.ffi.callback = function(fn) {
        if (fn === void 0) {
          return fn;
        }
        return function() {
          return Sk.misceval.apply(
            fn,
            void 0,
            void 0,
            void 0,
            Array.prototype.slice.call(arguments, 0)
          );
        };
      };
      Sk.exportSymbol("Sk.ffi.callback", Sk.ffi.callback);
      Sk.ffi.stdwrap = function(type, towrap) {
        var inst = new type();
        inst["v"] = towrap;
        return inst;
      };
      Sk.exportSymbol("Sk.ffi.stdwrap", Sk.ffi.stdwrap);
      Sk.ffi.basicwrap = function(obj) {
        if (obj instanceof Sk.builtin.int_) {
          return Sk.builtin.asnum$(obj);
        }
        if (obj instanceof Sk.builtin.float_) {
          return Sk.builtin.asnum$(obj);
        }
        if (obj instanceof Sk.builtin.lng) {
          return Sk.builtin.asnum$(obj);
        }
        if (typeof obj === "number" || typeof obj === "boolean") {
          return obj;
        }
        if (typeof obj === "string") {
          return new Sk.builtin.str(obj);
        }
        Sk.asserts.fail("unexpected type for basicwrap");
      };
      Sk.exportSymbol("Sk.ffi.basicwrap", Sk.ffi.basicwrap);
      Sk.ffi.unwrapo = function(obj) {
        if (obj === void 0) {
          return void 0;
        }
        return obj["v"];
      };
      Sk.exportSymbol("Sk.ffi.unwrapo", Sk.ffi.unwrapo);
      Sk.ffi.unwrapn = function(obj) {
        if (obj === null) {
          return null;
        }
        return obj["v"];
      };
      Sk.exportSymbol("Sk.ffi.unwrapn", Sk.ffi.unwrapn);
    }
  });

  // src/range.js
  var require_range = __commonJS({
    "src/range.js"() {
      Sk.builtin.range_ = Sk.abstr.buildNativeClass("range", {
        constructor: function range(start, stop, step, lst) {
          this.start = start;
          this.stop = stop;
          this.step = step;
          this.v = lst;
        },
        slots: {
          tp$getattr: Sk.generic.getAttr,
          tp$as_sequence_or_mapping: true,
          tp$doc: "range(stop) -> range object\nrange(start, stop[, step]) -> range object\n\nReturn an object that produces a sequence of integers from start (inclusive)\nto stop (exclusive) by step.  range(i, j) produces i, i+1, i+2, ..., j-1.\nstart defaults to 0, and stop is omitted!  range(4) produces 0, 1, 2, 3.\nThese are exactly the valid indices for a list of 4 elements.\nWhen step is given, it specifies the increment (or decrement).",
          tp$new(args, kwargs) {
            Sk.abstr.checkNoKwargs("range", kwargs);
            Sk.abstr.checkArgsLen("range", args, 1, 3);
            return rangeFromPy(args[0], args[1], args[2]);
          },
          $r() {
            let repr = "range(" + this.start + ", " + this.stop;
            if (this.step != 1) {
              repr += ", " + this.step;
            }
            repr += ")";
            return new Sk.builtin.str(repr);
          },
          tp$richcompare(w, op) {
            if (op !== "Eq" && op !== "NotEq" || w.ob$type !== Sk.builtin.range_) {
              return Sk.builtin.NotImplemented.NotImplemented$;
            }
            w = new Sk.builtin.list(w.v);
            return new Sk.builtin.list(this.v).tp$richcompare(w, op);
          },
          tp$iter() {
            return new range_iter_(this);
          },
          nb$bool() {
            return this.v.length !== 0;
          },
          // sequence and mapping slots
          sq$contains(item) {
            const lst = this.v;
            for (let i = 0; i < lst.length; i++) {
              if (Sk.misceval.richCompareBool(item, lst[i], "Eq")) {
                return true;
              }
            }
            return false;
          },
          sq$length() {
            return this.v.length;
          },
          mp$subscript(index) {
            if (Sk.misceval.isIndex(index)) {
              let i = Sk.misceval.asIndexSized(index);
              if (i < 0) {
                i = this.v.length + i;
              }
              if (i < 0 || i >= this.v.length) {
                throw new Sk.builtin.IndexError("range object index out of range");
              }
              return this.v[i];
            } else if (index.constructor === Sk.builtin.slice) {
              const ret = [];
              const lst = this.v;
              index.sssiter$(lst.length, (i) => {
                ret.push(lst[i]);
              });
              let { start, stop, step } = index.slice$indices(lst.length);
              start = Sk.misceval.asIndex(lst[start]) || this.start;
              stop = Sk.misceval.asIndex(lst[stop]) || this.stop;
              if (typeof this.step === "number") {
                step = step * this.step;
              } else {
                step = JSBI.multiply(this.step, JSBI.BigInt(step));
              }
              return new Sk.builtin.range_(start, stop, step, ret);
            }
            throw new Sk.builtin.TypeError(
              "range indices must be integers or slices, not " + Sk.abstr.typeName(index)
            );
          }
        },
        getsets: {
          start: {
            $get() {
              return new Sk.builtin.int_(this.start);
            }
          },
          step: {
            $get() {
              return new Sk.builtin.int_(this.step);
            }
          },
          stop: {
            $get() {
              return new Sk.builtin.int_(this.stop);
            }
          }
        },
        methods: {
          __reversed__: {
            $meth() {
              return new reverserange_iter_(this);
            },
            $flags: { NoArgs: true },
            $textsig: null,
            $doc: "Return a reverse iterator."
          },
          // __reduce__: {
          //     $meth: methods.__reduce__,
          //     $flags:{},
          //     $textsig: null,
          //     $doc: "" },
          count: {
            $meth(item) {
              let count = 0;
              for (let i = 0; i < this.v.length; i++) {
                if (Sk.misceval.richCompareBool(item, this.v[i], "Eq")) {
                  count++;
                }
              }
              return new Sk.builtin.int_(count);
            },
            $flags: { OneArg: true },
            $textsig: null,
            $doc: "rangeobject.count(value) -> integer -- return number of occurrences of value"
          },
          index: {
            $meth(item) {
              for (let i = 0; i < this.v.length; i++) {
                if (Sk.misceval.richCompareBool(item, this.v[i], "Eq")) {
                  return new Sk.builtin.int_(i);
                }
              }
              throw new Sk.builtin.ValueError(Sk.misceval.objectRepr(item) + "is not in range");
            },
            $flags: { OneArg: true },
            $textsig: null,
            $doc: "rangeobject.index(value, [start, [stop]]) -> integer -- return index of value.\nRaise ValueError if the value is not present."
          }
        },
        proto: {
          sk$asarray() {
            return this.v.slice(0);
          }
        },
        flags: {
          sk$unacceptableBase: true
        }
      });
      function rangeFromPy(start, stop, step) {
        start = start === void 0 ? start : Sk.misceval.asIndexOrThrow(start);
        stop = stop === void 0 ? stop : Sk.misceval.asIndexOrThrow(stop);
        step = step === void 0 ? step : Sk.misceval.asIndexOrThrow(step);
        if (stop === void 0 && step === void 0) {
          stop = start;
          start = 0;
          step = 1;
        } else if (step === void 0) {
          step = 1;
        } else if (step === 0) {
          throw new Sk.builtin.ValueError("range() step argument must not be zero");
        }
        const ret = [];
        if (typeof start === "number" && typeof stop === "number" && typeof step === "number") {
          if (step > 0) {
            for (let i = start; i < stop; i += step) {
              ret.push(new Sk.builtin.int_(i));
            }
          } else {
            for (let i = start; i > stop; i += step) {
              ret.push(new Sk.builtin.int_(i));
            }
          }
        } else {
          let i;
          start = i = JSBI.BigInt(start);
          step = JSBI.BigInt(step);
          stop = JSBI.BigInt(stop);
          if (JSBI.greaterThan(step, JSBI.__ZERO)) {
            while (JSBI.lessThan(i, stop)) {
              ret.push(new Sk.builtin.int_(convertIfSafe(i)));
              i = JSBI.add(i, step);
            }
          } else {
            while (JSBI.greaterThan(i, stop)) {
              ret.push(new Sk.builtin.int_(convertIfSafe(i)));
              i = JSBI.add(i, step);
            }
          }
          start = convertIfSafe(start);
          step = convertIfSafe(step);
          stop = convertIfSafe(stop);
        }
        return new Sk.builtin.range_(start, stop, step, ret);
      }
      var range_iter_ = Sk.abstr.buildIteratorClass("range_iterator", {
        constructor: function range_iter_2(range_obj) {
          this.$index = 0;
          this.$seq = range_obj.v;
        },
        iternext() {
          return this.$seq[this.$index++];
        },
        methods: {
          __length_hint__: Sk.generic.iterLengthHintWithArrayMethodDef
        },
        flags: { sk$unacceptableBase: true }
      });
      var reverserange_iter_ = Sk.abstr.buildIteratorClass("range_reverseiterator", {
        constructor: function range_iter(range_obj) {
          this.$seq = range_obj.v;
          this.$index = this.$seq.length - 1;
        },
        iternext() {
          return this.$seq[this.$index--];
        },
        methods: {
          __length_hint__: Sk.generic.iterReverseLengthHintMethodDef
        },
        flags: { sk$unacceptableBase: true }
      });
      function convertIfSafe(v) {
        if (JSBI.lessThan(v, JSBI.__MAX_SAFE) && JSBI.greaterThan(v, JSBI.__MIN_SAFE)) {
          return JSBI.toNumber(v);
        }
        return v;
      }
      Sk.builtin.range = Sk.builtin.xrange = function range(start, stop, step) {
        const ret = rangeFromPy(start, stop, step);
        return new Sk.builtin.list(ret.v);
      };
    }
  });

  // src/enumerate.js
  var require_enumerate = __commonJS({
    "src/enumerate.js"() {
      Sk.builtin.enumerate = Sk.abstr.buildIteratorClass("enumerate", {
        constructor: function enumerate(iterable, start) {
          if (!(this instanceof Sk.builtin.enumerate)) {
            throw TypeError("Failed to construct 'enumerate': Please use the 'new' operator");
          }
          this.$iterable = iterable;
          this.$index = start;
          return this;
        },
        iternext(canSuspend) {
          const ret = Sk.misceval.chain(this.$iterable.tp$iternext(canSuspend), (i) => {
            if (i === void 0) {
              return void 0;
            }
            return new Sk.builtin.tuple([new Sk.builtin.int_(this.$index++), i]);
          });
          return canSuspend ? ret : Sk.misceval.retryOptionalSuspensionOrThrow(ret);
        },
        slots: {
          tp$doc: "Return an enumerate object.\n\n  iterable\n    an object supporting iteration\n\nThe enumerate object yields pairs containing a count (from start, which\ndefaults to zero) and a value yielded by the iterable argument.\n\nenumerate is useful for obtaining an indexed list:\n    (0, seq[0]), (1, seq[1]), (2, seq[2]), ...",
          tp$new(args, kwargs) {
            let [iterable, start] = Sk.abstr.copyKeywordsToNamedArgs(
              "enumerate",
              ["iterable", "start"],
              args,
              kwargs,
              [new Sk.builtin.int_(0)]
            );
            iterable = Sk.abstr.iter(iterable);
            start = Sk.misceval.asIndexOrThrow(start);
            if (this === Sk.builtin.enumerate.prototype) {
              return new Sk.builtin.enumerate(iterable, start);
            } else {
              const instance = new this.constructor();
              Sk.builtin.enumerate.call(instance, iterable, start);
              return instance;
            }
          }
        },
        classmethods: Sk.generic.classGetItem
      });
      Sk.exportSymbol("Sk.builtin.enumerate", Sk.builtin.enumerate);
    }
  });

  // src/filter.js
  var require_filter = __commonJS({
    "src/filter.js"() {
      Sk.builtin.filter_ = Sk.abstr.buildIteratorClass("filter", {
        constructor: function filter_(func, iterable) {
          this.$func = func;
          this.$iterable = iterable;
        },
        iternext(canSuspend) {
          const ret = Sk.misceval.iterFor(
            this.$iterable,
            (i) => Sk.misceval.chain(
              this.check$filter(i),
              (i2) => i2 ? new Sk.misceval.Break(i2) : void 0
            )
          );
          return canSuspend ? ret : Sk.misceval.retryOptionalSuspensionOrThrow(ret);
        },
        slots: {
          tp$doc: "Return an iterator yielding those items of iterable for which function(item)\nis true. If function is None, return the items that are true.",
          tp$new(args, kwargs) {
            let [func, iterable] = Sk.abstr.copyKeywordsToNamedArgs(
              "filter",
              ["predicate", "iterable"],
              args,
              kwargs,
              []
            );
            func = Sk.builtin.checkNone(func) ? null : func;
            iterable = Sk.abstr.iter(iterable);
            if (this === Sk.builtin.filter_.prototype) {
              return new Sk.builtin.filter_(func, iterable);
            } else {
              const instance = new this.constructor();
              Sk.builtin.filter_.call(instance, func, iterable);
              return instance;
            }
          }
        },
        proto: {
          check$filter(item) {
            let res;
            if (this.$func === null) {
              res = item;
            } else {
              res = Sk.misceval.callsimOrSuspendArray(this.$func, [item]);
            }
            return Sk.misceval.chain(res, (ret) => Sk.misceval.isTrue(ret) ? item : void 0);
          }
        }
      });
      Sk.exportSymbol("Sk.builtin.filter_", Sk.builtin.filter_);
    }
  });

  // src/map.js
  var require_map = __commonJS({
    "src/map.js"() {
      Sk.builtin.map_ = Sk.abstr.buildIteratorClass("map", {
        constructor: function map_(func, iters) {
          this.$func = func;
          this.$iters = iters;
        },
        iternext(canSuspend) {
          const args = [];
          const ret = Sk.misceval.chain(
            Sk.misceval.iterArray(
              this.$iters,
              (it) => Sk.misceval.chain(it.tp$iternext(canSuspend), (i) => {
                if (i === void 0) {
                  return new Sk.misceval.Break(true);
                }
                args.push(i);
              })
            ),
            (endmap) => endmap ? void 0 : Sk.misceval.callsimOrSuspendArray(this.$func, args)
          );
          return canSuspend ? ret : Sk.misceval.retryOptionalSuspensionOrThrow(ret);
        },
        slots: {
          tp$doc: "map(func, *iterables) --> map object\n\nMake an iterator that computes the function using arguments from\neach of the iterables.  Stops when the shortest iterable is exhausted.",
          tp$new(args, kwargs) {
            if (this === Sk.builtin.map_.prototype) {
              Sk.abstr.checkNoKwargs("map", kwargs);
            }
            Sk.abstr.checkArgsLen("map", args, 2);
            const func = args[0];
            const iters = [];
            for (let i = 1; i < args.length; i++) {
              iters.push(Sk.abstr.iter(args[i]));
            }
            if (this === Sk.builtin.map_.prototype) {
              return new Sk.builtin.map_(func, iters);
            } else {
              const instance = new this.constructor();
              Sk.builtin.map_.call(instance, func, iters);
              return instance;
            }
          }
        }
      });
      Sk.exportSymbol("Sk.builtin.map_", Sk.builtin.map_);
    }
  });

  // src/reversed.js
  var require_reversed = __commonJS({
    "src/reversed.js"() {
      Sk.builtin.reversed = Sk.abstr.buildIteratorClass("reversed", {
        constructor: function reversed(seq) {
          this.$idx = seq.sq$length() - 1;
          this.$seq = seq;
          return this;
        },
        iternext(canSuspend) {
          if (this.$idx < 0) {
            return void 0;
          }
          const ret = Sk.misceval.tryCatch(
            () => Sk.abstr.objectGetItem(this.$seq, new Sk.builtin.int_(this.$idx--), canSuspend),
            (e) => {
              if (e instanceof Sk.builtin.IndexError) {
                this.$idx = -1;
                return void 0;
              } else {
                throw e;
              }
            }
          );
          return canSuspend ? ret : Sk.misceval.retryOptionalSuspensionOrThrow(ret);
        },
        slots: {
          tp$doc: "Return a reverse iterator over the values of the given sequence.",
          tp$new(args, kwargs) {
            if (this === Sk.builtin.reversed.prototype) {
              Sk.abstr.checkNoKwargs("reversed", kwargs);
            }
            Sk.abstr.checkArgsLen("reversed", args, 1, 1);
            let seq = args[0];
            const special = Sk.abstr.lookupSpecial(seq, Sk.builtin.str.$reversed);
            if (special !== void 0) {
              return Sk.misceval.callsimArray(special, []);
            } else if (!Sk.builtin.checkSequence(seq) || Sk.abstr.lookupSpecial(seq, Sk.builtin.str.$len) === void 0) {
              throw new Sk.builtin.TypeError(
                "'" + Sk.abstr.typeName(seq) + "' object is not a sequence"
              );
            }
            if (this === Sk.builtin.reversed.prototype) {
              return new Sk.builtin.reversed(seq);
            } else {
              const instance = new this.constructor();
              Sk.builtin.reversed.call(instance, seq);
              return instance;
            }
          }
        },
        methods: {
          __length_hint__: {
            $meth: function __length_hint__() {
              return this.$idx >= 0 ? new Sk.builtin.int_(this.$idx) : new Sk.builtin.int_(0);
            },
            $flags: { NoArgs: true }
          }
        }
      });
    }
  });

  // src/zip.js
  var require_zip = __commonJS({
    "src/zip.js"() {
      Sk.builtin.zip_ = Sk.abstr.buildIteratorClass("zip", {
        constructor: function zip_(iters) {
          this.$iters = iters;
          if (iters.length === 0) {
            this.tp$iternext = () => void 0;
          }
        },
        iternext(canSuspend) {
          const tup = [];
          const ret = Sk.misceval.chain(
            Sk.misceval.iterArray(
              this.$iters,
              (it) => Sk.misceval.chain(it.tp$iternext(canSuspend), (i) => {
                if (i === void 0) {
                  return new Sk.misceval.Break(true);
                }
                tup.push(i);
              })
            ),
            (endzip) => endzip ? void 0 : new Sk.builtin.tuple(tup)
          );
          return canSuspend ? ret : Sk.misceval.retryOptionalSuspensionOrThrow(ret);
        },
        slots: {
          tp$doc: "zip(iter1 [,iter2 [...]]) --> zip object\n\nReturn a zip object whose .__next__() method returns a tuple where\nthe i-th element comes from the i-th iterable argument.  The .__next__()\nmethod continues until the shortest iterable in the argument sequence\nis exhausted and then it raises StopIteration.",
          tp$new(args, kwargs) {
            if (this === Sk.builtin.zip_.prototype) {
              Sk.abstr.checkNoKwargs("zip", kwargs);
            }
            const iters = [];
            for (let i = 0; i < args.length; i++) {
              try {
                iters.push(Sk.abstr.iter(args[i]));
              } catch (e) {
                if (e instanceof Sk.builtin.TypeError) {
                  throw new Sk.builtin.TypeError(
                    "zip argument #" + (i + 1) + " must support iteration"
                  );
                } else {
                  throw e;
                }
              }
            }
            if (this === Sk.builtin.zip_.prototype) {
              return new Sk.builtin.zip_(iters);
            } else {
              const instance = new this.constructor();
              Sk.builtin.zip_.call(instance, iters);
              return instance;
            }
          }
        }
      });
      Sk.exportSymbol("Sk.builtin.zip_", Sk.builtin.zip_);
    }
  });

  // src/token.js
  var require_token = __commonJS({
    "src/token.js"() {
      var __all__ = ["tok_name", "ISTERMINAL", "ISNONTERMINAL", "ISEOF"];
      var tokens2 = {
        T_ENDMARKER: 0,
        T_NAME: 1,
        T_NUMBER: 2,
        T_STRING: 3,
        T_NEWLINE: 4,
        T_INDENT: 5,
        T_DEDENT: 6,
        T_LPAR: 7,
        T_RPAR: 8,
        T_LSQB: 9,
        T_RSQB: 10,
        T_COLON: 11,
        T_COMMA: 12,
        T_SEMI: 13,
        T_PLUS: 14,
        T_MINUS: 15,
        T_STAR: 16,
        T_SLASH: 17,
        T_VBAR: 18,
        T_AMPER: 19,
        T_LESS: 20,
        T_GREATER: 21,
        T_EQUAL: 22,
        T_DOT: 23,
        T_PERCENT: 24,
        T_LBRACE: 25,
        T_RBRACE: 26,
        T_EQEQUAL: 27,
        T_NOTEQUAL: 28,
        T_LESSEQUAL: 29,
        T_GREATEREQUAL: 30,
        T_TILDE: 31,
        T_CIRCUMFLEX: 32,
        T_LEFTSHIFT: 33,
        T_RIGHTSHIFT: 34,
        T_DOUBLESTAR: 35,
        T_PLUSEQUAL: 36,
        T_MINEQUAL: 37,
        T_STAREQUAL: 38,
        T_SLASHEQUAL: 39,
        T_PERCENTEQUAL: 40,
        T_AMPEREQUAL: 41,
        T_VBAREQUAL: 42,
        T_CIRCUMFLEXEQUAL: 43,
        T_LEFTSHIFTEQUAL: 44,
        T_RIGHTSHIFTEQUAL: 45,
        T_DOUBLESTAREQUAL: 46,
        T_DOUBLESLASH: 47,
        T_DOUBLESLASHEQUAL: 48,
        T_AT: 49,
        T_ATEQUAL: 50,
        T_RARROW: 51,
        T_ELLIPSIS: 52,
        T_OP: 53,
        T_AWAIT: 54,
        T_ASYNC: 55,
        T_ERRORTOKEN: 56,
        //special cases
        T_NT_OFFSET: 256,
        T_N_TOKENS: 60,
        //taken from tokenize.py
        T_COMMENT: 57,
        T_NL: 58,
        T_ENCODING: 59
      };
      var EXACT_TOKEN_TYPES = {
        "!=": tokens2.T_NOTEQUAL,
        "%": tokens2.T_PERCENT,
        "%=": tokens2.T_PERCENTEQUAL,
        "&": tokens2.T_AMPER,
        "&=": tokens2.T_AMPEREQUAL,
        "(": tokens2.T_LPAR,
        ")": tokens2.T_RPAR,
        "*": tokens2.T_STAR,
        "**": tokens2.T_DOUBLESTAR,
        "**=": tokens2.T_DOUBLESTAREQUAL,
        "*=": tokens2.T_STAREQUAL,
        "+": tokens2.T_PLUS,
        "+=": tokens2.T_PLUSEQUAL,
        ",": tokens2.T_COMMA,
        "-": tokens2.T_MINUS,
        "-=": tokens2.T_MINEQUAL,
        "->": tokens2.T_RARROW,
        ".": tokens2.T_DOT,
        "...": tokens2.T_ELLIPSIS,
        "/": tokens2.T_SLASH,
        "//": tokens2.T_DOUBLESLASH,
        "//=": tokens2.T_DOUBLESLASHEQUAL,
        "/=": tokens2.T_SLASHEQUAL,
        ":": tokens2.T_COLON,
        // ":=": tokens.T_COLONEQUAL, // currently not listed in tokens
        ";": tokens2.T_SEMI,
        "<": tokens2.T_LESS,
        "<<": tokens2.T_LEFTSHIFT,
        "<<=": tokens2.T_LEFTSHIFTEQUAL,
        "<=": tokens2.T_LESSEQUAL,
        "=": tokens2.T_EQUAL,
        "==": tokens2.T_EQEQUAL,
        ">": tokens2.T_GREATER,
        ">=": tokens2.T_GREATEREQUAL,
        ">>": tokens2.T_RIGHTSHIFT,
        ">>=": tokens2.T_RIGHTSHIFTEQUAL,
        "@": tokens2.T_AT,
        "@=": tokens2.T_ATEQUAL,
        "[": tokens2.T_LSQB,
        "]": tokens2.T_RSQB,
        "^": tokens2.T_CIRCUMFLEX,
        "^=": tokens2.T_CIRCUMFLEXEQUAL,
        "{": tokens2.T_LBRACE,
        "|": tokens2.T_VBAR,
        "|=": tokens2.T_VBAREQUAL,
        "}": tokens2.T_RBRACE,
        "~": tokens2.T_TILDE
      };
      var tok_name = {};
      (function() {
        for (var i in tokens2) {
          tok_name[tokens2[i]] = i;
        }
      })();
      __all__.concat(
        Object.keys(tok_name).map(function(k) {
          return tok_name[k];
        })
      );
      function ISTERMINAL(x) {
        return x < tokens2.T_NT_OFFSET;
      }
      function ISNONTERMINAL(x) {
        return x >= tokens2.T_NT_OFFSET;
      }
      function ISEOF(x) {
        return x == tokens2.T_ENDMARKER;
      }
      Sk.token = {};
      Sk.token.tokens = tokens2;
      Sk.token.tok_name = tok_name;
      Sk.token.EXACT_TOKEN_TYPES = EXACT_TOKEN_TYPES;
      Sk.token.ISTERMINAL = ISTERMINAL;
      Sk.token.ISNONTERMINAL = ISNONTERMINAL;
      Sk.token.ISEOF = ISEOF;
      Sk.exportSymbol("Sk.token", Sk.token);
      Sk.exportSymbol("Sk.token.tokens", Sk.token.tokens);
      Sk.exportSymbol("Sk.token.tok_name", Sk.token.tok_name);
      Sk.exportSymbol("Sk.token.EXACT_TOKEN_TYPES");
      Sk.exportSymbol("Sk.token.ISTERMINAL", Sk.token.ISTERMINAL);
      Sk.exportSymbol("Sk.token.ISNONTERMINAL", Sk.token.ISNONTERMINAL);
      Sk.exportSymbol("Sk.token.ISEOF", Sk.token.ISEOF);
    }
  });

  // support/polyfills/Unicode.js
  var Unicode, Unicode_default;
  var init_Unicode = __esm({
    "support/polyfills/Unicode.js"() {
      Unicode = {
        /* Strings to match Unicode characters in the BMP according to their Unicode category.
           Extracted from Unicode specification, version 5.0.0, source:
           http://unicode.org/versions/Unicode5.0.0/
        */
        /*
            Abbr    Long                Description
            Lu  Uppercase_Letter        an uppercase letter
            Ll  Lowercase_Letter        a lowercase letter
            Lt  Titlecase_Letter        a digraphic character, with first part uppercase
            LC  Cased_Letter            Lu | Ll | Lt
            Lm  Modifier_Letter         a modifier letter
            Lo  Other_Letter            other letters, including syllables and ideographs
            L   Letter                  Lu | Ll | Lt | Lm | Lo
            Mn  Nonspacing_Mark         a nonspacing combining mark (zero advance width)
            Mc  Spacing_Mark            a spacing combining mark (positive advance width)
            Me  Enclosing_Mark          an enclosing combining mark
            M   Mark                    Mn | Mc | Me
            Nd  Decimal_Number          a decimal digit
            Nl  Letter_Number           a letterlike numeric character
            No  Other_Number            a numeric character of other type
            N   Number                  Nd | Nl | No
            Pc  Connector_Punctuation   a connecting punctuation mark, like a tie
            Pd  Dash_Punctuation        a dash or hyphen punctuation mark
            Ps  Open_Punctuation        an opening punctuation mark (of a pair)
            Pe  Close_Punctuation       a closing punctuation mark (of a pair)
            Pi  Initial_Punctuation     an initial quotation mark
            Pf  Final_Punctuation       a final quotation mark
            Po  Other_Punctuation       a punctuation mark of other type
            P   Punctuation             Pc | Pd | Ps | Pe | Pi | Pf | Po
            Sm  Math_Symbol             a symbol of mathematical use
            Sc  Currency_Symbol         a currency sign
            Sk  Modifier_Symbol         a non-letterlike modifier symbol
            So  Other_Symbol            a symbol of other type
            S   Symbol                  Sm | Sc | Sk | So
            Zs  Space_Separator         a space character (of various non-zero widths)
            Zl  Line_Separator          U+2028 LINE SEPARATOR only
            Zp  Paragraph_Separator     U+2029 PARAGRAPH SEPARATOR only
            Z   Separator               Zs | Zl | Zp
            Cc  Control                 a C0 or C1 control code
            Cf  Format                  a format control character
            Cs  Surrogate               a surrogate code point
            Co  Private_Use             a private-use character
            Cn  Unassigned              a reserved unassigned code point or a noncharacter
            C   Other                   Cc | Cf | Cs | Co | Cn
        */
        /* Alpha Sorted
            Abbr    Long                Description
            C   Other                   Cc | Cf | Cs | Co | Cn
            Cc  Control                 a C0 or C1 control code
            Cf  Format                  a format control character
            Cn  Unassigned              a reserved unassigned code point or a noncharacter
            Co  Private_Use             a private-use character
            Cs  Surrogate               a surrogate code point
            L   Letter                  Lu | Ll | Lt | Lm | Lo
            LC  Cased_Letter            Lu | Ll | Lt
            Ll  Lowercase_Letter        a lowercase letter
            Lm  Modifier_Letter         a modifier letter
            Lo  Other_Letter            other letters, including syllables and ideographs
            Lt  Titlecase_Letter        a digraphic character, with first part uppercase
            Lu  Uppercase_Letter        an uppercase letter
            M   Mark                    Mn | Mc | Me
            Mc  Spacing_Mark            a spacing combining mark (positive advance width)
            Me  Enclosing_Mark          an enclosing combining mark
            Mn  Nonspacing_Mark         a nonspacing combining mark (zero advance width)
            N   Number                  Nd | Nl | No
            Nd  Decimal_Number          a decimal digit
            Nl  Letter_Number           a letterlike numeric character
            No  Other_Number            a numeric character of other type
            P   Punctuation             Pc | Pd | Ps | Pe | Pi | Pf | Po
            Pc  Connector_Punctuation   a connecting punctuation mark, like a tie
            Pd  Dash_Punctuation        a dash or hyphen punctuation mark
            Pe  Close_Punctuation       a closing punctuation mark (of a pair)
            Pf  Final_Punctuation       a final quotation mark
            Pi  Initial_Punctuation     an initial quotation mark
            Po  Other_Punctuation       a punctuation mark of other type
            Ps  Open_Punctuation        an opening punctuation mark (of a pair)
            S   Symbol                  Sm | Sc | Sk | So
            Sc  Currency_Symbol         a currency sign
            Sk  Modifier_Symbol         a non-letterlike modifier symbol
            Sm  Math_Symbol             a symbol of mathematical use
            So  Other_Symbol            a symbol of other type
            Z   Separator               Zs | Zl | Zp
            Zl  Line_Separator          U+2028 LINE SEPARATOR only
            Zp  Paragraph_Separator     U+2029 PARAGRAPH SEPARATOR only
            Zs  Space_Separator         a space character (of various non-zero widths)
        */
        Cc: "\\0-\\x1F\\x7F-\\x9F",
        Cf: "\\xAD\\u0600-\\u0605\\u061C\\u06DD\\u070F\\u08E2\\u180E\\u200B-\\u200F\\u202A-\\u202E\\u2060-\\u2064\\u2066-\\u206F\\uFEFF\\uFFF9-\\uFFFB",
        Co: "\\uE000-\\uF8FF",
        Cs: "\\uD800-\\uDFFF",
        Ll: "a-z\\xB5\\xDF-\\xF6\\xF8-\\xFF\\u0101\\u0103\\u0105\\u0107\\u0109\\u010B\\u010D\\u010F\\u0111\\u0113\\u0115\\u0117\\u0119\\u011B\\u011D\\u011F\\u0121\\u0123\\u0125\\u0127\\u0129\\u012B\\u012D\\u012F\\u0131\\u0133\\u0135\\u0137\\u0138\\u013A\\u013C\\u013E\\u0140\\u0142\\u0144\\u0146\\u0148\\u0149\\u014B\\u014D\\u014F\\u0151\\u0153\\u0155\\u0157\\u0159\\u015B\\u015D\\u015F\\u0161\\u0163\\u0165\\u0167\\u0169\\u016B\\u016D\\u016F\\u0171\\u0173\\u0175\\u0177\\u017A\\u017C\\u017E-\\u0180\\u0183\\u0185\\u0188\\u018C\\u018D\\u0192\\u0195\\u0199-\\u019B\\u019E\\u01A1\\u01A3\\u01A5\\u01A8\\u01AA\\u01AB\\u01AD\\u01B0\\u01B4\\u01B6\\u01B9\\u01BA\\u01BD-\\u01BF\\u01C6\\u01C9\\u01CC\\u01CE\\u01D0\\u01D2\\u01D4\\u01D6\\u01D8\\u01DA\\u01DC\\u01DD\\u01DF\\u01E1\\u01E3\\u01E5\\u01E7\\u01E9\\u01EB\\u01ED\\u01EF\\u01F0\\u01F3\\u01F5\\u01F9\\u01FB\\u01FD\\u01FF\\u0201\\u0203\\u0205\\u0207\\u0209\\u020B\\u020D\\u020F\\u0211\\u0213\\u0215\\u0217\\u0219\\u021B\\u021D\\u021F\\u0221\\u0223\\u0225\\u0227\\u0229\\u022B\\u022D\\u022F\\u0231\\u0233-\\u0239\\u023C\\u023F\\u0240\\u0242\\u0247\\u0249\\u024B\\u024D\\u024F-\\u0293\\u0295-\\u02AF\\u0371\\u0373\\u0377\\u037B-\\u037D\\u0390\\u03AC-\\u03CE\\u03D0\\u03D1\\u03D5-\\u03D7\\u03D9\\u03DB\\u03DD\\u03DF\\u03E1\\u03E3\\u03E5\\u03E7\\u03E9\\u03EB\\u03ED\\u03EF-\\u03F3\\u03F5\\u03F8\\u03FB\\u03FC\\u0430-\\u045F\\u0461\\u0463\\u0465\\u0467\\u0469\\u046B\\u046D\\u046F\\u0471\\u0473\\u0475\\u0477\\u0479\\u047B\\u047D\\u047F\\u0481\\u048B\\u048D\\u048F\\u0491\\u0493\\u0495\\u0497\\u0499\\u049B\\u049D\\u049F\\u04A1\\u04A3\\u04A5\\u04A7\\u04A9\\u04AB\\u04AD\\u04AF\\u04B1\\u04B3\\u04B5\\u04B7\\u04B9\\u04BB\\u04BD\\u04BF\\u04C2\\u04C4\\u04C6\\u04C8\\u04CA\\u04CC\\u04CE\\u04CF\\u04D1\\u04D3\\u04D5\\u04D7\\u04D9\\u04DB\\u04DD\\u04DF\\u04E1\\u04E3\\u04E5\\u04E7\\u04E9\\u04EB\\u04ED\\u04EF\\u04F1\\u04F3\\u04F5\\u04F7\\u04F9\\u04FB\\u04FD\\u04FF\\u0501\\u0503\\u0505\\u0507\\u0509\\u050B\\u050D\\u050F\\u0511\\u0513\\u0515\\u0517\\u0519\\u051B\\u051D\\u051F\\u0521\\u0523\\u0525\\u0527\\u0529\\u052B\\u052D\\u052F\\u0560-\\u0588\\u10D0-\\u10FA\\u10FD-\\u10FF\\u13F8-\\u13FD\\u1C80-\\u1C88\\u1D00-\\u1D2B\\u1D6B-\\u1D77\\u1D79-\\u1D9A\\u1E01\\u1E03\\u1E05\\u1E07\\u1E09\\u1E0B\\u1E0D\\u1E0F\\u1E11\\u1E13\\u1E15\\u1E17\\u1E19\\u1E1B\\u1E1D\\u1E1F\\u1E21\\u1E23\\u1E25\\u1E27\\u1E29\\u1E2B\\u1E2D\\u1E2F\\u1E31\\u1E33\\u1E35\\u1E37\\u1E39\\u1E3B\\u1E3D\\u1E3F\\u1E41\\u1E43\\u1E45\\u1E47\\u1E49\\u1E4B\\u1E4D\\u1E4F\\u1E51\\u1E53\\u1E55\\u1E57\\u1E59\\u1E5B\\u1E5D\\u1E5F\\u1E61\\u1E63\\u1E65\\u1E67\\u1E69\\u1E6B\\u1E6D\\u1E6F\\u1E71\\u1E73\\u1E75\\u1E77\\u1E79\\u1E7B\\u1E7D\\u1E7F\\u1E81\\u1E83\\u1E85\\u1E87\\u1E89\\u1E8B\\u1E8D\\u1E8F\\u1E91\\u1E93\\u1E95-\\u1E9D\\u1E9F\\u1EA1\\u1EA3\\u1EA5\\u1EA7\\u1EA9\\u1EAB\\u1EAD\\u1EAF\\u1EB1\\u1EB3\\u1EB5\\u1EB7\\u1EB9\\u1EBB\\u1EBD\\u1EBF\\u1EC1\\u1EC3\\u1EC5\\u1EC7\\u1EC9\\u1ECB\\u1ECD\\u1ECF\\u1ED1\\u1ED3\\u1ED5\\u1ED7\\u1ED9\\u1EDB\\u1EDD\\u1EDF\\u1EE1\\u1EE3\\u1EE5\\u1EE7\\u1EE9\\u1EEB\\u1EED\\u1EEF\\u1EF1\\u1EF3\\u1EF5\\u1EF7\\u1EF9\\u1EFB\\u1EFD\\u1EFF-\\u1F07\\u1F10-\\u1F15\\u1F20-\\u1F27\\u1F30-\\u1F37\\u1F40-\\u1F45\\u1F50-\\u1F57\\u1F60-\\u1F67\\u1F70-\\u1F7D\\u1F80-\\u1F87\\u1F90-\\u1F97\\u1FA0-\\u1FA7\\u1FB0-\\u1FB4\\u1FB6\\u1FB7\\u1FBE\\u1FC2-\\u1FC4\\u1FC6\\u1FC7\\u1FD0-\\u1FD3\\u1FD6\\u1FD7\\u1FE0-\\u1FE7\\u1FF2-\\u1FF4\\u1FF6\\u1FF7\\u210A\\u210E\\u210F\\u2113\\u212F\\u2134\\u2139\\u213C\\u213D\\u2146-\\u2149\\u214E\\u2184\\u2C30-\\u2C5E\\u2C61\\u2C65\\u2C66\\u2C68\\u2C6A\\u2C6C\\u2C71\\u2C73\\u2C74\\u2C76-\\u2C7B\\u2C81\\u2C83\\u2C85\\u2C87\\u2C89\\u2C8B\\u2C8D\\u2C8F\\u2C91\\u2C93\\u2C95\\u2C97\\u2C99\\u2C9B\\u2C9D\\u2C9F\\u2CA1\\u2CA3\\u2CA5\\u2CA7\\u2CA9\\u2CAB\\u2CAD\\u2CAF\\u2CB1\\u2CB3\\u2CB5\\u2CB7\\u2CB9\\u2CBB\\u2CBD\\u2CBF\\u2CC1\\u2CC3\\u2CC5\\u2CC7\\u2CC9\\u2CCB\\u2CCD\\u2CCF\\u2CD1\\u2CD3\\u2CD5\\u2CD7\\u2CD9\\u2CDB\\u2CDD\\u2CDF\\u2CE1\\u2CE3\\u2CE4\\u2CEC\\u2CEE\\u2CF3\\u2D00-\\u2D25\\u2D27\\u2D2D\\uA641\\uA643\\uA645\\uA647\\uA649\\uA64B\\uA64D\\uA64F\\uA651\\uA653\\uA655\\uA657\\uA659\\uA65B\\uA65D\\uA65F\\uA661\\uA663\\uA665\\uA667\\uA669\\uA66B\\uA66D\\uA681\\uA683\\uA685\\uA687\\uA689\\uA68B\\uA68D\\uA68F\\uA691\\uA693\\uA695\\uA697\\uA699\\uA69B\\uA723\\uA725\\uA727\\uA729\\uA72B\\uA72D\\uA72F-\\uA731\\uA733\\uA735\\uA737\\uA739\\uA73B\\uA73D\\uA73F\\uA741\\uA743\\uA745\\uA747\\uA749\\uA74B\\uA74D\\uA74F\\uA751\\uA753\\uA755\\uA757\\uA759\\uA75B\\uA75D\\uA75F\\uA761\\uA763\\uA765\\uA767\\uA769\\uA76B\\uA76D\\uA76F\\uA771-\\uA778\\uA77A\\uA77C\\uA77F\\uA781\\uA783\\uA785\\uA787\\uA78C\\uA78E\\uA791\\uA793-\\uA795\\uA797\\uA799\\uA79B\\uA79D\\uA79F\\uA7A1\\uA7A3\\uA7A5\\uA7A7\\uA7A9\\uA7AF\\uA7B5\\uA7B7\\uA7B9\\uA7BB\\uA7BD\\uA7BF\\uA7C3\\uA7C8\\uA7CA\\uA7F6\\uA7FA\\uAB30-\\uAB5A\\uAB60-\\uAB68\\uAB70-\\uABBF\\uFB00-\\uFB06\\uFB13-\\uFB17\\uFF41-\\uFF5A",
        Lm: "\\u02B0-\\u02C1\\u02C6-\\u02D1\\u02E0-\\u02E4\\u02EC\\u02EE\\u0374\\u037A\\u0559\\u0640\\u06E5\\u06E6\\u07F4\\u07F5\\u07FA\\u081A\\u0824\\u0828\\u0971\\u0E46\\u0EC6\\u10FC\\u17D7\\u1843\\u1AA7\\u1C78-\\u1C7D\\u1D2C-\\u1D6A\\u1D78\\u1D9B-\\u1DBF\\u2071\\u207F\\u2090-\\u209C\\u2C7C\\u2C7D\\u2D6F\\u2E2F\\u3005\\u3031-\\u3035\\u303B\\u309D\\u309E\\u30FC-\\u30FE\\uA015\\uA4F8-\\uA4FD\\uA60C\\uA67F\\uA69C\\uA69D\\uA717-\\uA71F\\uA770\\uA788\\uA7F8\\uA7F9\\uA9CF\\uA9E6\\uAA70\\uAADD\\uAAF3\\uAAF4\\uAB5C-\\uAB5F\\uAB69\\uFF70\\uFF9E\\uFF9F",
        Lo: "\\xAA\\xBA\\u01BB\\u01C0-\\u01C3\\u0294\\u05D0-\\u05EA\\u05EF-\\u05F2\\u0620-\\u063F\\u0641-\\u064A\\u066E\\u066F\\u0671-\\u06D3\\u06D5\\u06EE\\u06EF\\u06FA-\\u06FC\\u06FF\\u0710\\u0712-\\u072F\\u074D-\\u07A5\\u07B1\\u07CA-\\u07EA\\u0800-\\u0815\\u0840-\\u0858\\u0860-\\u086A\\u08A0-\\u08B4\\u08B6-\\u08C7\\u0904-\\u0939\\u093D\\u0950\\u0958-\\u0961\\u0972-\\u0980\\u0985-\\u098C\\u098F\\u0990\\u0993-\\u09A8\\u09AA-\\u09B0\\u09B2\\u09B6-\\u09B9\\u09BD\\u09CE\\u09DC\\u09DD\\u09DF-\\u09E1\\u09F0\\u09F1\\u09FC\\u0A05-\\u0A0A\\u0A0F\\u0A10\\u0A13-\\u0A28\\u0A2A-\\u0A30\\u0A32\\u0A33\\u0A35\\u0A36\\u0A38\\u0A39\\u0A59-\\u0A5C\\u0A5E\\u0A72-\\u0A74\\u0A85-\\u0A8D\\u0A8F-\\u0A91\\u0A93-\\u0AA8\\u0AAA-\\u0AB0\\u0AB2\\u0AB3\\u0AB5-\\u0AB9\\u0ABD\\u0AD0\\u0AE0\\u0AE1\\u0AF9\\u0B05-\\u0B0C\\u0B0F\\u0B10\\u0B13-\\u0B28\\u0B2A-\\u0B30\\u0B32\\u0B33\\u0B35-\\u0B39\\u0B3D\\u0B5C\\u0B5D\\u0B5F-\\u0B61\\u0B71\\u0B83\\u0B85-\\u0B8A\\u0B8E-\\u0B90\\u0B92-\\u0B95\\u0B99\\u0B9A\\u0B9C\\u0B9E\\u0B9F\\u0BA3\\u0BA4\\u0BA8-\\u0BAA\\u0BAE-\\u0BB9\\u0BD0\\u0C05-\\u0C0C\\u0C0E-\\u0C10\\u0C12-\\u0C28\\u0C2A-\\u0C39\\u0C3D\\u0C58-\\u0C5A\\u0C60\\u0C61\\u0C80\\u0C85-\\u0C8C\\u0C8E-\\u0C90\\u0C92-\\u0CA8\\u0CAA-\\u0CB3\\u0CB5-\\u0CB9\\u0CBD\\u0CDE\\u0CE0\\u0CE1\\u0CF1\\u0CF2\\u0D04-\\u0D0C\\u0D0E-\\u0D10\\u0D12-\\u0D3A\\u0D3D\\u0D4E\\u0D54-\\u0D56\\u0D5F-\\u0D61\\u0D7A-\\u0D7F\\u0D85-\\u0D96\\u0D9A-\\u0DB1\\u0DB3-\\u0DBB\\u0DBD\\u0DC0-\\u0DC6\\u0E01-\\u0E30\\u0E32\\u0E33\\u0E40-\\u0E45\\u0E81\\u0E82\\u0E84\\u0E86-\\u0E8A\\u0E8C-\\u0EA3\\u0EA5\\u0EA7-\\u0EB0\\u0EB2\\u0EB3\\u0EBD\\u0EC0-\\u0EC4\\u0EDC-\\u0EDF\\u0F00\\u0F40-\\u0F47\\u0F49-\\u0F6C\\u0F88-\\u0F8C\\u1000-\\u102A\\u103F\\u1050-\\u1055\\u105A-\\u105D\\u1061\\u1065\\u1066\\u106E-\\u1070\\u1075-\\u1081\\u108E\\u1100-\\u1248\\u124A-\\u124D\\u1250-\\u1256\\u1258\\u125A-\\u125D\\u1260-\\u1288\\u128A-\\u128D\\u1290-\\u12B0\\u12B2-\\u12B5\\u12B8-\\u12BE\\u12C0\\u12C2-\\u12C5\\u12C8-\\u12D6\\u12D8-\\u1310\\u1312-\\u1315\\u1318-\\u135A\\u1380-\\u138F\\u1401-\\u166C\\u166F-\\u167F\\u1681-\\u169A\\u16A0-\\u16EA\\u16F1-\\u16F8\\u1700-\\u170C\\u170E-\\u1711\\u1720-\\u1731\\u1740-\\u1751\\u1760-\\u176C\\u176E-\\u1770\\u1780-\\u17B3\\u17DC\\u1820-\\u1842\\u1844-\\u1878\\u1880-\\u1884\\u1887-\\u18A8\\u18AA\\u18B0-\\u18F5\\u1900-\\u191E\\u1950-\\u196D\\u1970-\\u1974\\u1980-\\u19AB\\u19B0-\\u19C9\\u1A00-\\u1A16\\u1A20-\\u1A54\\u1B05-\\u1B33\\u1B45-\\u1B4B\\u1B83-\\u1BA0\\u1BAE\\u1BAF\\u1BBA-\\u1BE5\\u1C00-\\u1C23\\u1C4D-\\u1C4F\\u1C5A-\\u1C77\\u1CE9-\\u1CEC\\u1CEE-\\u1CF3\\u1CF5\\u1CF6\\u1CFA\\u2135-\\u2138\\u2D30-\\u2D67\\u2D80-\\u2D96\\u2DA0-\\u2DA6\\u2DA8-\\u2DAE\\u2DB0-\\u2DB6\\u2DB8-\\u2DBE\\u2DC0-\\u2DC6\\u2DC8-\\u2DCE\\u2DD0-\\u2DD6\\u2DD8-\\u2DDE\\u3006\\u303C\\u3041-\\u3096\\u309F\\u30A1-\\u30FA\\u30FF\\u3105-\\u312F\\u3131-\\u318E\\u31A0-\\u31BF\\u31F0-\\u31FF\\u3400-\\u4DBF\\u4E00-\\u9FFC\\uA000-\\uA014\\uA016-\\uA48C\\uA4D0-\\uA4F7\\uA500-\\uA60B\\uA610-\\uA61F\\uA62A\\uA62B\\uA66E\\uA6A0-\\uA6E5\\uA78F\\uA7F7\\uA7FB-\\uA801\\uA803-\\uA805\\uA807-\\uA80A\\uA80C-\\uA822\\uA840-\\uA873\\uA882-\\uA8B3\\uA8F2-\\uA8F7\\uA8FB\\uA8FD\\uA8FE\\uA90A-\\uA925\\uA930-\\uA946\\uA960-\\uA97C\\uA984-\\uA9B2\\uA9E0-\\uA9E4\\uA9E7-\\uA9EF\\uA9FA-\\uA9FE\\uAA00-\\uAA28\\uAA40-\\uAA42\\uAA44-\\uAA4B\\uAA60-\\uAA6F\\uAA71-\\uAA76\\uAA7A\\uAA7E-\\uAAAF\\uAAB1\\uAAB5\\uAAB6\\uAAB9-\\uAABD\\uAAC0\\uAAC2\\uAADB\\uAADC\\uAAE0-\\uAAEA\\uAAF2\\uAB01-\\uAB06\\uAB09-\\uAB0E\\uAB11-\\uAB16\\uAB20-\\uAB26\\uAB28-\\uAB2E\\uABC0-\\uABE2\\uAC00-\\uD7A3\\uD7B0-\\uD7C6\\uD7CB-\\uD7FB\\uF900-\\uFA6D\\uFA70-\\uFAD9\\uFB1D\\uFB1F-\\uFB28\\uFB2A-\\uFB36\\uFB38-\\uFB3C\\uFB3E\\uFB40\\uFB41\\uFB43\\uFB44\\uFB46-\\uFBB1\\uFBD3-\\uFD3D\\uFD50-\\uFD8F\\uFD92-\\uFDC7\\uFDF0-\\uFDFB\\uFE70-\\uFE74\\uFE76-\\uFEFC\\uFF66-\\uFF6F\\uFF71-\\uFF9D\\uFFA0-\\uFFBE\\uFFC2-\\uFFC7\\uFFCA-\\uFFCF\\uFFD2-\\uFFD7\\uFFDA-\\uFFDC",
        Lt: "\\u01C5\\u01C8\\u01CB\\u01F2\\u1F88-\\u1F8F\\u1F98-\\u1F9F\\u1FA8-\\u1FAF\\u1FBC\\u1FCC\\u1FFC",
        Lu: "A-Z\\xC0-\\xD6\\xD8-\\xDE\\u0100\\u0102\\u0104\\u0106\\u0108\\u010A\\u010C\\u010E\\u0110\\u0112\\u0114\\u0116\\u0118\\u011A\\u011C\\u011E\\u0120\\u0122\\u0124\\u0126\\u0128\\u012A\\u012C\\u012E\\u0130\\u0132\\u0134\\u0136\\u0139\\u013B\\u013D\\u013F\\u0141\\u0143\\u0145\\u0147\\u014A\\u014C\\u014E\\u0150\\u0152\\u0154\\u0156\\u0158\\u015A\\u015C\\u015E\\u0160\\u0162\\u0164\\u0166\\u0168\\u016A\\u016C\\u016E\\u0170\\u0172\\u0174\\u0176\\u0178\\u0179\\u017B\\u017D\\u0181\\u0182\\u0184\\u0186\\u0187\\u0189-\\u018B\\u018E-\\u0191\\u0193\\u0194\\u0196-\\u0198\\u019C\\u019D\\u019F\\u01A0\\u01A2\\u01A4\\u01A6\\u01A7\\u01A9\\u01AC\\u01AE\\u01AF\\u01B1-\\u01B3\\u01B5\\u01B7\\u01B8\\u01BC\\u01C4\\u01C7\\u01CA\\u01CD\\u01CF\\u01D1\\u01D3\\u01D5\\u01D7\\u01D9\\u01DB\\u01DE\\u01E0\\u01E2\\u01E4\\u01E6\\u01E8\\u01EA\\u01EC\\u01EE\\u01F1\\u01F4\\u01F6-\\u01F8\\u01FA\\u01FC\\u01FE\\u0200\\u0202\\u0204\\u0206\\u0208\\u020A\\u020C\\u020E\\u0210\\u0212\\u0214\\u0216\\u0218\\u021A\\u021C\\u021E\\u0220\\u0222\\u0224\\u0226\\u0228\\u022A\\u022C\\u022E\\u0230\\u0232\\u023A\\u023B\\u023D\\u023E\\u0241\\u0243-\\u0246\\u0248\\u024A\\u024C\\u024E\\u0370\\u0372\\u0376\\u037F\\u0386\\u0388-\\u038A\\u038C\\u038E\\u038F\\u0391-\\u03A1\\u03A3-\\u03AB\\u03CF\\u03D2-\\u03D4\\u03D8\\u03DA\\u03DC\\u03DE\\u03E0\\u03E2\\u03E4\\u03E6\\u03E8\\u03EA\\u03EC\\u03EE\\u03F4\\u03F7\\u03F9\\u03FA\\u03FD-\\u042F\\u0460\\u0462\\u0464\\u0466\\u0468\\u046A\\u046C\\u046E\\u0470\\u0472\\u0474\\u0476\\u0478\\u047A\\u047C\\u047E\\u0480\\u048A\\u048C\\u048E\\u0490\\u0492\\u0494\\u0496\\u0498\\u049A\\u049C\\u049E\\u04A0\\u04A2\\u04A4\\u04A6\\u04A8\\u04AA\\u04AC\\u04AE\\u04B0\\u04B2\\u04B4\\u04B6\\u04B8\\u04BA\\u04BC\\u04BE\\u04C0\\u04C1\\u04C3\\u04C5\\u04C7\\u04C9\\u04CB\\u04CD\\u04D0\\u04D2\\u04D4\\u04D6\\u04D8\\u04DA\\u04DC\\u04DE\\u04E0\\u04E2\\u04E4\\u04E6\\u04E8\\u04EA\\u04EC\\u04EE\\u04F0\\u04F2\\u04F4\\u04F6\\u04F8\\u04FA\\u04FC\\u04FE\\u0500\\u0502\\u0504\\u0506\\u0508\\u050A\\u050C\\u050E\\u0510\\u0512\\u0514\\u0516\\u0518\\u051A\\u051C\\u051E\\u0520\\u0522\\u0524\\u0526\\u0528\\u052A\\u052C\\u052E\\u0531-\\u0556\\u10A0-\\u10C5\\u10C7\\u10CD\\u13A0-\\u13F5\\u1C90-\\u1CBA\\u1CBD-\\u1CBF\\u1E00\\u1E02\\u1E04\\u1E06\\u1E08\\u1E0A\\u1E0C\\u1E0E\\u1E10\\u1E12\\u1E14\\u1E16\\u1E18\\u1E1A\\u1E1C\\u1E1E\\u1E20\\u1E22\\u1E24\\u1E26\\u1E28\\u1E2A\\u1E2C\\u1E2E\\u1E30\\u1E32\\u1E34\\u1E36\\u1E38\\u1E3A\\u1E3C\\u1E3E\\u1E40\\u1E42\\u1E44\\u1E46\\u1E48\\u1E4A\\u1E4C\\u1E4E\\u1E50\\u1E52\\u1E54\\u1E56\\u1E58\\u1E5A\\u1E5C\\u1E5E\\u1E60\\u1E62\\u1E64\\u1E66\\u1E68\\u1E6A\\u1E6C\\u1E6E\\u1E70\\u1E72\\u1E74\\u1E76\\u1E78\\u1E7A\\u1E7C\\u1E7E\\u1E80\\u1E82\\u1E84\\u1E86\\u1E88\\u1E8A\\u1E8C\\u1E8E\\u1E90\\u1E92\\u1E94\\u1E9E\\u1EA0\\u1EA2\\u1EA4\\u1EA6\\u1EA8\\u1EAA\\u1EAC\\u1EAE\\u1EB0\\u1EB2\\u1EB4\\u1EB6\\u1EB8\\u1EBA\\u1EBC\\u1EBE\\u1EC0\\u1EC2\\u1EC4\\u1EC6\\u1EC8\\u1ECA\\u1ECC\\u1ECE\\u1ED0\\u1ED2\\u1ED4\\u1ED6\\u1ED8\\u1EDA\\u1EDC\\u1EDE\\u1EE0\\u1EE2\\u1EE4\\u1EE6\\u1EE8\\u1EEA\\u1EEC\\u1EEE\\u1EF0\\u1EF2\\u1EF4\\u1EF6\\u1EF8\\u1EFA\\u1EFC\\u1EFE\\u1F08-\\u1F0F\\u1F18-\\u1F1D\\u1F28-\\u1F2F\\u1F38-\\u1F3F\\u1F48-\\u1F4D\\u1F59\\u1F5B\\u1F5D\\u1F5F\\u1F68-\\u1F6F\\u1FB8-\\u1FBB\\u1FC8-\\u1FCB\\u1FD8-\\u1FDB\\u1FE8-\\u1FEC\\u1FF8-\\u1FFB\\u2102\\u2107\\u210B-\\u210D\\u2110-\\u2112\\u2115\\u2119-\\u211D\\u2124\\u2126\\u2128\\u212A-\\u212D\\u2130-\\u2133\\u213E\\u213F\\u2145\\u2183\\u2C00-\\u2C2E\\u2C60\\u2C62-\\u2C64\\u2C67\\u2C69\\u2C6B\\u2C6D-\\u2C70\\u2C72\\u2C75\\u2C7E-\\u2C80\\u2C82\\u2C84\\u2C86\\u2C88\\u2C8A\\u2C8C\\u2C8E\\u2C90\\u2C92\\u2C94\\u2C96\\u2C98\\u2C9A\\u2C9C\\u2C9E\\u2CA0\\u2CA2\\u2CA4\\u2CA6\\u2CA8\\u2CAA\\u2CAC\\u2CAE\\u2CB0\\u2CB2\\u2CB4\\u2CB6\\u2CB8\\u2CBA\\u2CBC\\u2CBE\\u2CC0\\u2CC2\\u2CC4\\u2CC6\\u2CC8\\u2CCA\\u2CCC\\u2CCE\\u2CD0\\u2CD2\\u2CD4\\u2CD6\\u2CD8\\u2CDA\\u2CDC\\u2CDE\\u2CE0\\u2CE2\\u2CEB\\u2CED\\u2CF2\\uA640\\uA642\\uA644\\uA646\\uA648\\uA64A\\uA64C\\uA64E\\uA650\\uA652\\uA654\\uA656\\uA658\\uA65A\\uA65C\\uA65E\\uA660\\uA662\\uA664\\uA666\\uA668\\uA66A\\uA66C\\uA680\\uA682\\uA684\\uA686\\uA688\\uA68A\\uA68C\\uA68E\\uA690\\uA692\\uA694\\uA696\\uA698\\uA69A\\uA722\\uA724\\uA726\\uA728\\uA72A\\uA72C\\uA72E\\uA732\\uA734\\uA736\\uA738\\uA73A\\uA73C\\uA73E\\uA740\\uA742\\uA744\\uA746\\uA748\\uA74A\\uA74C\\uA74E\\uA750\\uA752\\uA754\\uA756\\uA758\\uA75A\\uA75C\\uA75E\\uA760\\uA762\\uA764\\uA766\\uA768\\uA76A\\uA76C\\uA76E\\uA779\\uA77B\\uA77D\\uA77E\\uA780\\uA782\\uA784\\uA786\\uA78B\\uA78D\\uA790\\uA792\\uA796\\uA798\\uA79A\\uA79C\\uA79E\\uA7A0\\uA7A2\\uA7A4\\uA7A6\\uA7A8\\uA7AA-\\uA7AE\\uA7B0-\\uA7B4\\uA7B6\\uA7B8\\uA7BA\\uA7BC\\uA7BE\\uA7C2\\uA7C4-\\uA7C7\\uA7C9\\uA7F5\\uFF21-\\uFF3A",
        M: "\\u0300-\\u036F\\u0483-\\u0489\\u0591-\\u05BD\\u05BF\\u05C1\\u05C2\\u05C4\\u05C5\\u05C7\\u0610-\\u061A\\u064B-\\u065F\\u0670\\u06D6-\\u06DC\\u06DF-\\u06E4\\u06E7\\u06E8\\u06EA-\\u06ED\\u0711\\u0730-\\u074A\\u07A6-\\u07B0\\u07EB-\\u07F3\\u07FD\\u0816-\\u0819\\u081B-\\u0823\\u0825-\\u0827\\u0829-\\u082D\\u0859-\\u085B\\u08D3-\\u08E1\\u08E3-\\u0903\\u093A-\\u093C\\u093E-\\u094F\\u0951-\\u0957\\u0962\\u0963\\u0981-\\u0983\\u09BC\\u09BE-\\u09C4\\u09C7\\u09C8\\u09CB-\\u09CD\\u09D7\\u09E2\\u09E3\\u09FE\\u0A01-\\u0A03\\u0A3C\\u0A3E-\\u0A42\\u0A47\\u0A48\\u0A4B-\\u0A4D\\u0A51\\u0A70\\u0A71\\u0A75\\u0A81-\\u0A83\\u0ABC\\u0ABE-\\u0AC5\\u0AC7-\\u0AC9\\u0ACB-\\u0ACD\\u0AE2\\u0AE3\\u0AFA-\\u0AFF\\u0B01-\\u0B03\\u0B3C\\u0B3E-\\u0B44\\u0B47\\u0B48\\u0B4B-\\u0B4D\\u0B55-\\u0B57\\u0B62\\u0B63\\u0B82\\u0BBE-\\u0BC2\\u0BC6-\\u0BC8\\u0BCA-\\u0BCD\\u0BD7\\u0C00-\\u0C04\\u0C3E-\\u0C44\\u0C46-\\u0C48\\u0C4A-\\u0C4D\\u0C55\\u0C56\\u0C62\\u0C63\\u0C81-\\u0C83\\u0CBC\\u0CBE-\\u0CC4\\u0CC6-\\u0CC8\\u0CCA-\\u0CCD\\u0CD5\\u0CD6\\u0CE2\\u0CE3\\u0D00-\\u0D03\\u0D3B\\u0D3C\\u0D3E-\\u0D44\\u0D46-\\u0D48\\u0D4A-\\u0D4D\\u0D57\\u0D62\\u0D63\\u0D81-\\u0D83\\u0DCA\\u0DCF-\\u0DD4\\u0DD6\\u0DD8-\\u0DDF\\u0DF2\\u0DF3\\u0E31\\u0E34-\\u0E3A\\u0E47-\\u0E4E\\u0EB1\\u0EB4-\\u0EBC\\u0EC8-\\u0ECD\\u0F18\\u0F19\\u0F35\\u0F37\\u0F39\\u0F3E\\u0F3F\\u0F71-\\u0F84\\u0F86\\u0F87\\u0F8D-\\u0F97\\u0F99-\\u0FBC\\u0FC6\\u102B-\\u103E\\u1056-\\u1059\\u105E-\\u1060\\u1062-\\u1064\\u1067-\\u106D\\u1071-\\u1074\\u1082-\\u108D\\u108F\\u109A-\\u109D\\u135D-\\u135F\\u1712-\\u1714\\u1732-\\u1734\\u1752\\u1753\\u1772\\u1773\\u17B4-\\u17D3\\u17DD\\u180B-\\u180D\\u1885\\u1886\\u18A9\\u1920-\\u192B\\u1930-\\u193B\\u1A17-\\u1A1B\\u1A55-\\u1A5E\\u1A60-\\u1A7C\\u1A7F\\u1AB0-\\u1AC0\\u1B00-\\u1B04\\u1B34-\\u1B44\\u1B6B-\\u1B73\\u1B80-\\u1B82\\u1BA1-\\u1BAD\\u1BE6-\\u1BF3\\u1C24-\\u1C37\\u1CD0-\\u1CD2\\u1CD4-\\u1CE8\\u1CED\\u1CF4\\u1CF7-\\u1CF9\\u1DC0-\\u1DF9\\u1DFB-\\u1DFF\\u20D0-\\u20F0\\u2CEF-\\u2CF1\\u2D7F\\u2DE0-\\u2DFF\\u302A-\\u302F\\u3099\\u309A\\uA66F-\\uA672\\uA674-\\uA67D\\uA69E\\uA69F\\uA6F0\\uA6F1\\uA802\\uA806\\uA80B\\uA823-\\uA827\\uA82C\\uA880\\uA881\\uA8B4-\\uA8C5\\uA8E0-\\uA8F1\\uA8FF\\uA926-\\uA92D\\uA947-\\uA953\\uA980-\\uA983\\uA9B3-\\uA9C0\\uA9E5\\uAA29-\\uAA36\\uAA43\\uAA4C\\uAA4D\\uAA7B-\\uAA7D\\uAAB0\\uAAB2-\\uAAB4\\uAAB7\\uAAB8\\uAABE\\uAABF\\uAAC1\\uAAEB-\\uAAEF\\uAAF5\\uAAF6\\uABE3-\\uABEA\\uABEC\\uABED\\uFB1E\\uFE00-\\uFE0F\\uFE20-\\uFE2F",
        Mc: "\\u0903\\u093B\\u093E-\\u0940\\u0949-\\u094C\\u094E\\u094F\\u0982\\u0983\\u09BE-\\u09C0\\u09C7\\u09C8\\u09CB\\u09CC\\u09D7\\u0A03\\u0A3E-\\u0A40\\u0A83\\u0ABE-\\u0AC0\\u0AC9\\u0ACB\\u0ACC\\u0B02\\u0B03\\u0B3E\\u0B40\\u0B47\\u0B48\\u0B4B\\u0B4C\\u0B57\\u0BBE\\u0BBF\\u0BC1\\u0BC2\\u0BC6-\\u0BC8\\u0BCA-\\u0BCC\\u0BD7\\u0C01-\\u0C03\\u0C41-\\u0C44\\u0C82\\u0C83\\u0CBE\\u0CC0-\\u0CC4\\u0CC7\\u0CC8\\u0CCA\\u0CCB\\u0CD5\\u0CD6\\u0D02\\u0D03\\u0D3E-\\u0D40\\u0D46-\\u0D48\\u0D4A-\\u0D4C\\u0D57\\u0D82\\u0D83\\u0DCF-\\u0DD1\\u0DD8-\\u0DDF\\u0DF2\\u0DF3\\u0F3E\\u0F3F\\u0F7F\\u102B\\u102C\\u1031\\u1038\\u103B\\u103C\\u1056\\u1057\\u1062-\\u1064\\u1067-\\u106D\\u1083\\u1084\\u1087-\\u108C\\u108F\\u109A-\\u109C\\u17B6\\u17BE-\\u17C5\\u17C7\\u17C8\\u1923-\\u1926\\u1929-\\u192B\\u1930\\u1931\\u1933-\\u1938\\u1A19\\u1A1A\\u1A55\\u1A57\\u1A61\\u1A63\\u1A64\\u1A6D-\\u1A72\\u1B04\\u1B35\\u1B3B\\u1B3D-\\u1B41\\u1B43\\u1B44\\u1B82\\u1BA1\\u1BA6\\u1BA7\\u1BAA\\u1BE7\\u1BEA-\\u1BEC\\u1BEE\\u1BF2\\u1BF3\\u1C24-\\u1C2B\\u1C34\\u1C35\\u1CE1\\u1CF7\\u302E\\u302F\\uA823\\uA824\\uA827\\uA880\\uA881\\uA8B4-\\uA8C3\\uA952\\uA953\\uA983\\uA9B4\\uA9B5\\uA9BA\\uA9BB\\uA9BE-\\uA9C0\\uAA2F\\uAA30\\uAA33\\uAA34\\uAA4D\\uAA7B\\uAA7D\\uAAEB\\uAAEE\\uAAEF\\uAAF5\\uABE3\\uABE4\\uABE6\\uABE7\\uABE9\\uABEA\\uABEC",
        Me: "\\u0488\\u0489\\u1ABE\\u20DD-\\u20E0\\u20E2-\\u20E4\\uA670-\\uA672",
        Mn: "\\u0300-\\u036F\\u0483-\\u0487\\u0591-\\u05BD\\u05BF\\u05C1\\u05C2\\u05C4\\u05C5\\u05C7\\u0610-\\u061A\\u064B-\\u065F\\u0670\\u06D6-\\u06DC\\u06DF-\\u06E4\\u06E7\\u06E8\\u06EA-\\u06ED\\u0711\\u0730-\\u074A\\u07A6-\\u07B0\\u07EB-\\u07F3\\u07FD\\u0816-\\u0819\\u081B-\\u0823\\u0825-\\u0827\\u0829-\\u082D\\u0859-\\u085B\\u08D3-\\u08E1\\u08E3-\\u0902\\u093A\\u093C\\u0941-\\u0948\\u094D\\u0951-\\u0957\\u0962\\u0963\\u0981\\u09BC\\u09C1-\\u09C4\\u09CD\\u09E2\\u09E3\\u09FE\\u0A01\\u0A02\\u0A3C\\u0A41\\u0A42\\u0A47\\u0A48\\u0A4B-\\u0A4D\\u0A51\\u0A70\\u0A71\\u0A75\\u0A81\\u0A82\\u0ABC\\u0AC1-\\u0AC5\\u0AC7\\u0AC8\\u0ACD\\u0AE2\\u0AE3\\u0AFA-\\u0AFF\\u0B01\\u0B3C\\u0B3F\\u0B41-\\u0B44\\u0B4D\\u0B55\\u0B56\\u0B62\\u0B63\\u0B82\\u0BC0\\u0BCD\\u0C00\\u0C04\\u0C3E-\\u0C40\\u0C46-\\u0C48\\u0C4A-\\u0C4D\\u0C55\\u0C56\\u0C62\\u0C63\\u0C81\\u0CBC\\u0CBF\\u0CC6\\u0CCC\\u0CCD\\u0CE2\\u0CE3\\u0D00\\u0D01\\u0D3B\\u0D3C\\u0D41-\\u0D44\\u0D4D\\u0D62\\u0D63\\u0D81\\u0DCA\\u0DD2-\\u0DD4\\u0DD6\\u0E31\\u0E34-\\u0E3A\\u0E47-\\u0E4E\\u0EB1\\u0EB4-\\u0EBC\\u0EC8-\\u0ECD\\u0F18\\u0F19\\u0F35\\u0F37\\u0F39\\u0F71-\\u0F7E\\u0F80-\\u0F84\\u0F86\\u0F87\\u0F8D-\\u0F97\\u0F99-\\u0FBC\\u0FC6\\u102D-\\u1030\\u1032-\\u1037\\u1039\\u103A\\u103D\\u103E\\u1058\\u1059\\u105E-\\u1060\\u1071-\\u1074\\u1082\\u1085\\u1086\\u108D\\u109D\\u135D-\\u135F\\u1712-\\u1714\\u1732-\\u1734\\u1752\\u1753\\u1772\\u1773\\u17B4\\u17B5\\u17B7-\\u17BD\\u17C6\\u17C9-\\u17D3\\u17DD\\u180B-\\u180D\\u1885\\u1886\\u18A9\\u1920-\\u1922\\u1927\\u1928\\u1932\\u1939-\\u193B\\u1A17\\u1A18\\u1A1B\\u1A56\\u1A58-\\u1A5E\\u1A60\\u1A62\\u1A65-\\u1A6C\\u1A73-\\u1A7C\\u1A7F\\u1AB0-\\u1ABD\\u1ABF\\u1AC0\\u1B00-\\u1B03\\u1B34\\u1B36-\\u1B3A\\u1B3C\\u1B42\\u1B6B-\\u1B73\\u1B80\\u1B81\\u1BA2-\\u1BA5\\u1BA8\\u1BA9\\u1BAB-\\u1BAD\\u1BE6\\u1BE8\\u1BE9\\u1BED\\u1BEF-\\u1BF1\\u1C2C-\\u1C33\\u1C36\\u1C37\\u1CD0-\\u1CD2\\u1CD4-\\u1CE0\\u1CE2-\\u1CE8\\u1CED\\u1CF4\\u1CF8\\u1CF9\\u1DC0-\\u1DF9\\u1DFB-\\u1DFF\\u20D0-\\u20DC\\u20E1\\u20E5-\\u20F0\\u2CEF-\\u2CF1\\u2D7F\\u2DE0-\\u2DFF\\u302A-\\u302D\\u3099\\u309A\\uA66F\\uA674-\\uA67D\\uA69E\\uA69F\\uA6F0\\uA6F1\\uA802\\uA806\\uA80B\\uA825\\uA826\\uA82C\\uA8C4\\uA8C5\\uA8E0-\\uA8F1\\uA8FF\\uA926-\\uA92D\\uA947-\\uA951\\uA980-\\uA982\\uA9B3\\uA9B6-\\uA9B9\\uA9BC\\uA9BD\\uA9E5\\uAA29-\\uAA2E\\uAA31\\uAA32\\uAA35\\uAA36\\uAA43\\uAA4C\\uAA7C\\uAAB0\\uAAB2-\\uAAB4\\uAAB7\\uAAB8\\uAABE\\uAABF\\uAAC1\\uAAEC\\uAAED\\uAAF6\\uABE5\\uABE8\\uABED\\uFB1E\\uFE00-\\uFE0F\\uFE20-\\uFE2F",
        Nd: "0-9\\u0660-\\u0669\\u06F0-\\u06F9\\u07C0-\\u07C9\\u0966-\\u096F\\u09E6-\\u09EF\\u0A66-\\u0A6F\\u0AE6-\\u0AEF\\u0B66-\\u0B6F\\u0BE6-\\u0BEF\\u0C66-\\u0C6F\\u0CE6-\\u0CEF\\u0D66-\\u0D6F\\u0DE6-\\u0DEF\\u0E50-\\u0E59\\u0ED0-\\u0ED9\\u0F20-\\u0F29\\u1040-\\u1049\\u1090-\\u1099\\u17E0-\\u17E9\\u1810-\\u1819\\u1946-\\u194F\\u19D0-\\u19D9\\u1A80-\\u1A89\\u1A90-\\u1A99\\u1B50-\\u1B59\\u1BB0-\\u1BB9\\u1C40-\\u1C49\\u1C50-\\u1C59\\uA620-\\uA629\\uA8D0-\\uA8D9\\uA900-\\uA909\\uA9D0-\\uA9D9\\uA9F0-\\uA9F9\\uAA50-\\uAA59\\uABF0-\\uABF9\\uFF10-\\uFF19",
        Nl: "\\u16EE-\\u16F0\\u2160-\\u2182\\u2185-\\u2188\\u3007\\u3021-\\u3029\\u3038-\\u303A\\uA6E6-\\uA6EF",
        No: "\\xB2\\xB3\\xB9\\xBC-\\xBE\\u09F4-\\u09F9\\u0B72-\\u0B77\\u0BF0-\\u0BF2\\u0C78-\\u0C7E\\u0D58-\\u0D5E\\u0D70-\\u0D78\\u0F2A-\\u0F33\\u1369-\\u137C\\u17F0-\\u17F9\\u19DA\\u2070\\u2074-\\u2079\\u2080-\\u2089\\u2150-\\u215F\\u2189\\u2460-\\u249B\\u24EA-\\u24FF\\u2776-\\u2793\\u2CFD\\u3192-\\u3195\\u3220-\\u3229\\u3248-\\u324F\\u3251-\\u325F\\u3280-\\u3289\\u32B1-\\u32BF\\uA830-\\uA835",
        Pc: "_\\u203F\\u2040\\u2054\\uFE33\\uFE34\\uFE4D-\\uFE4F\\uFF3F",
        Pd: "\\-\\u058A\\u05BE\\u1400\\u1806\\u2010-\\u2015\\u2E17\\u2E1A\\u2E3A\\u2E3B\\u2E40\\u301C\\u3030\\u30A0\\uFE31\\uFE32\\uFE58\\uFE63\\uFF0D",
        Pe: "\\)\\]\\}\\u0F3B\\u0F3D\\u169C\\u2046\\u207E\\u208E\\u2309\\u230B\\u232A\\u2769\\u276B\\u276D\\u276F\\u2771\\u2773\\u2775\\u27C6\\u27E7\\u27E9\\u27EB\\u27ED\\u27EF\\u2984\\u2986\\u2988\\u298A\\u298C\\u298E\\u2990\\u2992\\u2994\\u2996\\u2998\\u29D9\\u29DB\\u29FD\\u2E23\\u2E25\\u2E27\\u2E29\\u3009\\u300B\\u300D\\u300F\\u3011\\u3015\\u3017\\u3019\\u301B\\u301E\\u301F\\uFD3E\\uFE18\\uFE36\\uFE38\\uFE3A\\uFE3C\\uFE3E\\uFE40\\uFE42\\uFE44\\uFE48\\uFE5A\\uFE5C\\uFE5E\\uFF09\\uFF3D\\uFF5D\\uFF60\\uFF63",
        Pf: "\\xBB\\u2019\\u201D\\u203A\\u2E03\\u2E05\\u2E0A\\u2E0D\\u2E1D\\u2E21",
        Pi: "\\xAB\\u2018\\u201B\\u201C\\u201F\\u2039\\u2E02\\u2E04\\u2E09\\u2E0C\\u2E1C\\u2E20",
        Po: "!-#%-'\\*,\\.\\/:;\\?@\\xA1\\xA7\\xB6\\xB7\\xBF\\u037E\\u0387\\u055A-\\u055F\\u0589\\u05C0\\u05C3\\u05C6\\u05F3\\u05F4\\u0609\\u060A\\u060C\\u060D\\u061B\\u061E\\u061F\\u066A-\\u066D\\u06D4\\u0700-\\u070D\\u07F7-\\u07F9\\u0830-\\u083E\\u085E\\u0964\\u0965\\u0970\\u09FD\\u0A76\\u0AF0\\u0C77\\u0C84\\u0DF4\\u0E4F\\u0E5A\\u0E5B\\u0F04-\\u0F12\\u0F14\\u0F85\\u0FD0-\\u0FD4\\u0FD9\\u0FDA\\u104A-\\u104F\\u10FB\\u1360-\\u1368\\u166E\\u16EB-\\u16ED\\u1735\\u1736\\u17D4-\\u17D6\\u17D8-\\u17DA\\u1800-\\u1805\\u1807-\\u180A\\u1944\\u1945\\u1A1E\\u1A1F\\u1AA0-\\u1AA6\\u1AA8-\\u1AAD\\u1B5A-\\u1B60\\u1BFC-\\u1BFF\\u1C3B-\\u1C3F\\u1C7E\\u1C7F\\u1CC0-\\u1CC7\\u1CD3\\u2016\\u2017\\u2020-\\u2027\\u2030-\\u2038\\u203B-\\u203E\\u2041-\\u2043\\u2047-\\u2051\\u2053\\u2055-\\u205E\\u2CF9-\\u2CFC\\u2CFE\\u2CFF\\u2D70\\u2E00\\u2E01\\u2E06-\\u2E08\\u2E0B\\u2E0E-\\u2E16\\u2E18\\u2E19\\u2E1B\\u2E1E\\u2E1F\\u2E2A-\\u2E2E\\u2E30-\\u2E39\\u2E3C-\\u2E3F\\u2E41\\u2E43-\\u2E4F\\u2E52\\u3001-\\u3003\\u303D\\u30FB\\uA4FE\\uA4FF\\uA60D-\\uA60F\\uA673\\uA67E\\uA6F2-\\uA6F7\\uA874-\\uA877\\uA8CE\\uA8CF\\uA8F8-\\uA8FA\\uA8FC\\uA92E\\uA92F\\uA95F\\uA9C1-\\uA9CD\\uA9DE\\uA9DF\\uAA5C-\\uAA5F\\uAADE\\uAADF\\uAAF0\\uAAF1\\uABEB\\uFE10-\\uFE16\\uFE19\\uFE30\\uFE45\\uFE46\\uFE49-\\uFE4C\\uFE50-\\uFE52\\uFE54-\\uFE57\\uFE5F-\\uFE61\\uFE68\\uFE6A\\uFE6B\\uFF01-\\uFF03\\uFF05-\\uFF07\\uFF0A\\uFF0C\\uFF0E\\uFF0F\\uFF1A\\uFF1B\\uFF1F\\uFF20\\uFF3C\\uFF61\\uFF64\\uFF65",
        Ps: "\\(\\[\\{\\u0F3A\\u0F3C\\u169B\\u201A\\u201E\\u2045\\u207D\\u208D\\u2308\\u230A\\u2329\\u2768\\u276A\\u276C\\u276E\\u2770\\u2772\\u2774\\u27C5\\u27E6\\u27E8\\u27EA\\u27EC\\u27EE\\u2983\\u2985\\u2987\\u2989\\u298B\\u298D\\u298F\\u2991\\u2993\\u2995\\u2997\\u29D8\\u29DA\\u29FC\\u2E22\\u2E24\\u2E26\\u2E28\\u2E42\\u3008\\u300A\\u300C\\u300E\\u3010\\u3014\\u3016\\u3018\\u301A\\u301D\\uFD3F\\uFE17\\uFE35\\uFE37\\uFE39\\uFE3B\\uFE3D\\uFE3F\\uFE41\\uFE43\\uFE47\\uFE59\\uFE5B\\uFE5D\\uFF08\\uFF3B\\uFF5B\\uFF5F\\uFF62",
        Sc: "\\$\\xA2-\\xA5\\u058F\\u060B\\u07FE\\u07FF\\u09F2\\u09F3\\u09FB\\u0AF1\\u0BF9\\u0E3F\\u17DB\\u20A0-\\u20BF\\uA838\\uFDFC\\uFE69\\uFF04\\uFFE0\\uFFE1\\uFFE5\\uFFE6",
        Sk: "\\^`\\xA8\\xAF\\xB4\\xB8\\u02C2-\\u02C5\\u02D2-\\u02DF\\u02E5-\\u02EB\\u02ED\\u02EF-\\u02FF\\u0375\\u0384\\u0385\\u1FBD\\u1FBF-\\u1FC1\\u1FCD-\\u1FCF\\u1FDD-\\u1FDF\\u1FED-\\u1FEF\\u1FFD\\u1FFE\\u309B\\u309C\\uA700-\\uA716\\uA720\\uA721\\uA789\\uA78A\\uAB5B\\uAB6A\\uAB6B\\uFBB2-\\uFBC1\\uFF3E\\uFF40\\uFFE3",
        Sm: "\\+<->\\|~\\xAC\\xB1\\xD7\\xF7\\u03F6\\u0606-\\u0608\\u2044\\u2052\\u207A-\\u207C\\u208A-\\u208C\\u2118\\u2140-\\u2144\\u214B\\u2190-\\u2194\\u219A\\u219B\\u21A0\\u21A3\\u21A6\\u21AE\\u21CE\\u21CF\\u21D2\\u21D4\\u21F4-\\u22FF\\u2320\\u2321\\u237C\\u239B-\\u23B3\\u23DC-\\u23E1\\u25B7\\u25C1\\u25F8-\\u25FF\\u266F\\u27C0-\\u27C4\\u27C7-\\u27E5\\u27F0-\\u27FF\\u2900-\\u2982\\u2999-\\u29D7\\u29DC-\\u29FB\\u29FE-\\u2AFF\\u2B30-\\u2B44\\u2B47-\\u2B4C\\uFB29\\uFE62\\uFE64-\\uFE66\\uFF0B\\uFF1C-\\uFF1E\\uFF5C\\uFF5E\\uFFE2\\uFFE9-\\uFFEC",
        So: "\\xA6\\xA9\\xAE\\xB0\\u0482\\u058D\\u058E\\u060E\\u060F\\u06DE\\u06E9\\u06FD\\u06FE\\u07F6\\u09FA\\u0B70\\u0BF3-\\u0BF8\\u0BFA\\u0C7F\\u0D4F\\u0D79\\u0F01-\\u0F03\\u0F13\\u0F15-\\u0F17\\u0F1A-\\u0F1F\\u0F34\\u0F36\\u0F38\\u0FBE-\\u0FC5\\u0FC7-\\u0FCC\\u0FCE\\u0FCF\\u0FD5-\\u0FD8\\u109E\\u109F\\u1390-\\u1399\\u166D\\u1940\\u19DE-\\u19FF\\u1B61-\\u1B6A\\u1B74-\\u1B7C\\u2100\\u2101\\u2103-\\u2106\\u2108\\u2109\\u2114\\u2116\\u2117\\u211E-\\u2123\\u2125\\u2127\\u2129\\u212E\\u213A\\u213B\\u214A\\u214C\\u214D\\u214F\\u218A\\u218B\\u2195-\\u2199\\u219C-\\u219F\\u21A1\\u21A2\\u21A4\\u21A5\\u21A7-\\u21AD\\u21AF-\\u21CD\\u21D0\\u21D1\\u21D3\\u21D5-\\u21F3\\u2300-\\u2307\\u230C-\\u231F\\u2322-\\u2328\\u232B-\\u237B\\u237D-\\u239A\\u23B4-\\u23DB\\u23E2-\\u2426\\u2440-\\u244A\\u249C-\\u24E9\\u2500-\\u25B6\\u25B8-\\u25C0\\u25C2-\\u25F7\\u2600-\\u266E\\u2670-\\u2767\\u2794-\\u27BF\\u2800-\\u28FF\\u2B00-\\u2B2F\\u2B45\\u2B46\\u2B4D-\\u2B73\\u2B76-\\u2B95\\u2B97-\\u2BFF\\u2CE5-\\u2CEA\\u2E50\\u2E51\\u2E80-\\u2E99\\u2E9B-\\u2EF3\\u2F00-\\u2FD5\\u2FF0-\\u2FFB\\u3004\\u3012\\u3013\\u3020\\u3036\\u3037\\u303E\\u303F\\u3190\\u3191\\u3196-\\u319F\\u31C0-\\u31E3\\u3200-\\u321E\\u322A-\\u3247\\u3250\\u3260-\\u327F\\u328A-\\u32B0\\u32C0-\\u33FF\\u4DC0-\\u4DFF\\uA490-\\uA4C6\\uA828-\\uA82B\\uA836\\uA837\\uA839\\uAA77-\\uAA79\\uFDFD\\uFFE4\\uFFE8\\uFFED\\uFFEE\\uFFFC\\uFFFD",
        Zl: "\\u2028",
        Zp: "\\u2029",
        Zs: " \\xA0\\u1680\\u2000-\\u200A\\u202F\\u205F\\u3000"
      };
      Unicode.C = Unicode.Cc + Unicode.Cf + Unicode.Cs + Unicode.Co;
      Unicode.L = Unicode.Lu + Unicode.Ll + Unicode.Lt + Unicode.Lm + Unicode.Mn + //Added 2014-05-29 due to some letters in names not being recognized.
      //This is where accent marks are individually combined instead of using an explicit character.
      Unicode.Lo;
      Unicode.LC = Unicode.Lu + Unicode.Ll + Unicode.Lt;
      Unicode.M = Unicode.Mn + Unicode.Mc + Unicode.Me;
      Unicode.N = Unicode.Nd + Unicode.Nl + Unicode.No;
      Unicode.P = Unicode.Pc + Unicode.Pd + Unicode.Ps + Unicode.Pe + Unicode.Pi + Unicode.Pf + Unicode.Po;
      Unicode.S = Unicode.Sm + Unicode.Sc + Unicode.Sk + Unicode.So;
      Unicode.Z = Unicode.Zs + Unicode.Zl + Unicode.Zp;
      Unicode.w = "_" + Unicode.L + Unicode.N;
      Unicode.b = "(?:[" + Unicode.w + "](?:[^" + Unicode.w + "]|$)|(?:^|[^" + Unicode.w + "])[" + Unicode.w + "])";
      Unicode.bOut = "(?=[^" + Unicode.w + "]|$)";
      Unicode.bIn = "(?:^|[^" + Unicode.w + "])";
      Unicode.bInCapture = "(?:^|([^" + Unicode.w + "]))";
      Unicode.B = "(?:[" + Unicode.w + "][" + Unicode.w + "]|[^" + Unicode.w + "][^" + Unicode.w + "])";
      Unicode.d = Unicode.N;
      Unicode_default = Unicode;
    }
  });

  // src/tokenize.js
  var tokenize_exports = {};
  function TokenInfo(type, string, start, end, line) {
    this.type = type;
    this.string = string;
    this.start = start;
    this.end = end;
    this.line = line;
  }
  function group(x) {
    var args = Array.prototype.slice.call(arguments);
    return "(" + args.join("|") + ")";
  }
  function any(x) {
    return group.apply(null, arguments) + "*";
  }
  function maybe(x) {
    return group.apply(null, arguments) + "?";
  }
  function regexEscape(string) {
    return string && reHasRegExpChar.test(string) ? string.replace(reRegExpChar, "\\$&") : string;
  }
  function contains(a, obj) {
    var i = a.length;
    while (i--) {
      if (a[i] === obj) {
        return true;
      }
    }
    return false;
  }
  function rstrip(input, what) {
    var i;
    for (i = input.length; i > 0; --i) {
      if (what.indexOf(input.charAt(i - 1)) === -1) {
        break;
      }
    }
    return input.substring(0, i);
  }
  function isidentifier(str) {
    var normalized = str.normalize("NFKC");
    return IS_IDENTIFIER_REGEX.test(normalized);
  }
  function _all_string_prefixes() {
    return [
      "",
      "FR",
      "RF",
      "Br",
      "BR",
      "Fr",
      "r",
      "B",
      "R",
      "b",
      "bR",
      "f",
      "rb",
      "rB",
      "F",
      "Rf",
      "U",
      "rF",
      "u",
      "RB",
      "br",
      "fR",
      "fr",
      "rf",
      "Rb"
    ];
  }
  function setupTokens(py3) {
    if (py3) {
      delete Sk.token.EXACT_TOKEN_TYPES["<>"];
    } else {
      Sk.token.EXACT_TOKEN_TYPES["<>"] = Sk.token.tokens.T_NOTEQUAL;
    }
    EXACT_TOKENS_SORTED = Object.keys(Sk.token.EXACT_TOKEN_TYPES).sort();
    Special = group.apply(
      this,
      EXACT_TOKENS_SORTED.reverse().map(function(t) {
        return regexEscape(t);
      })
    );
    Funny = group("\\r?\\n", Special);
  }
  function _setupTokenRegexes() {
    var LSuffix = !Sk.__future__.python3 ? "(?:L?)" : "";
    var Hexnumber = "0[xX](?:_?[0-9a-fA-F])+" + LSuffix;
    var Binnumber = "0[bB](?:_?[01])+" + LSuffix;
    var Octnumber = "0([oO])(?:_?[0-7])+" + LSuffix;
    var SilentOctnumber = "0([oO]?)(?:_?[0-7])+" + LSuffix;
    var Decnumber = "(?:0(?:_?0)*|[1-9](?:_?[0-9])*)" + LSuffix;
    var Intnumber = group(
      Hexnumber,
      Binnumber,
      Sk.__future__.silent_octal_literal ? SilentOctnumber : Octnumber,
      Decnumber
    );
    var Number_ = group(Imagnumber, Floatnumber, Intnumber);
    var PseudoToken = Whitespace + group(PseudoExtras, Number_, Funny, ContStr, Name);
    PseudoTokenRegex = new RegExp(PseudoToken);
  }
  function _tokenize(readline, encoding, yield_, filename) {
    var lnum = 0, parenlev = 0, continued = 0, numchars = "0123456789", contstr = "", needcont = 0, contline = null, indents = [0], spos = [0, 0], epos = [0, 0], capos = null, endprog = void 0, strstart = void 0, end = void 0, pseudomatch = void 0;
    if (encoding !== void 0) {
      if (encoding == "utf-8-sig") {
        encoding = "utf-8";
      }
      yield_(new TokenInfo(tokens.T_ENCODING, encoding, [0, 0], [0, 0], ""));
    }
    var last_line = "";
    var line = "";
    while (true) {
      try {
        last_line = line;
        line = readline();
      } catch (Exception) {
        line = "";
      }
      lnum += 1;
      var pos = 0;
      var max = line.length;
      if (contstr) {
        if (!line) {
          throw new TokenError(
            "EOF in multi-line string",
            filename,
            last_line,
            ...spos,
            ...epos
          );
        }
        endprog.lastIndex = 0;
        var endmatch = endprog.exec(line);
        if (endmatch) {
          pos = end = endmatch[0].length;
          yield_(
            new TokenInfo(
              tokens.T_STRING,
              contstr + line.substring(0, end),
              strstart,
              [lnum, end],
              contline + line
            )
          );
          contstr = "";
          needcont = 0;
          contline = null;
        } else if (needcont && line.substring(line.length - 2) !== "\\\n" && line.substring(line.length - 3) !== "\\\r\n") {
          yield_(
            new TokenInfo(
              tokens.T_ERRORTOKEN,
              contstr + line,
              strstart,
              [lnum, line.length],
              contline
            )
          );
          contstr = "";
          contline = null;
          continue;
        } else {
          contstr = contstr + line;
          contline = contline + line;
          continue;
        }
      } else if (parenlev == 0 && !continued) {
        if (!line) {
          break;
        }
        var column = 0;
        while (pos < max) {
          if (line[pos] == " ") {
            column += 1;
          } else if (line[pos] == "	") {
            column = Math.floor(column / tabsize + 1) * tabsize;
          } else if (line[pos] == "\f") {
            column = 0;
          } else {
            break;
          }
          pos += 1;
        }
        if (pos == max) {
          break;
        }
        if (contains("#\r\n", line[pos])) {
          if (line[pos] == "#") {
            var comment_token = rstrip(line.substring(pos), "\r\n");
            yield_(
              new TokenInfo(
                tokens.T_COMMENT,
                comment_token,
                [lnum, pos],
                [lnum, pos + comment_token.length],
                line
              )
            );
            pos += comment_token.length;
          }
          yield_(
            new TokenInfo(
              tokens.T_NL,
              line.substring(pos),
              [lnum, pos],
              [lnum, line.length],
              line
            )
          );
          continue;
        }
        if (column > indents[indents.length - 1]) {
          indents.push(column);
          yield_(
            new TokenInfo(
              tokens.T_INDENT,
              line.substring(pos),
              [lnum, 0],
              [lnum, pos],
              line
            )
          );
        }
        while (column < indents[indents.length - 1]) {
          if (!contains(indents, column)) {
            throw new IndentationError(
              "unindent does not match any outer indentation level",
              filename,
              spos[0],
              ...spos,
              ...epos
            );
          }
          indents = indents.slice(0, -1);
          yield_(new TokenInfo(tokens.T_DEDENT, "", [lnum, pos], [lnum, pos], line));
        }
      } else {
        if (!line) {
          throw new TokenError(
            "EOF in multi-line statement",
            filename,
            last_line,
            ...spos,
            ...epos
          );
        }
        continued = 0;
      }
      while (pos < max) {
        capos = line.charAt(pos);
        while (capos === " " || capos === "\f" || capos === "	") {
          pos += 1;
          capos = line.charAt(pos);
        }
        pseudomatch = PseudoTokenRegex.exec(line.substring(pos));
        if (pseudomatch) {
          var start = pos;
          var end = start + pseudomatch[1].length;
          spos = [lnum, start];
          epos = [lnum, end];
          var pos = end;
          if (start == end) {
            continue;
          }
          var token = line.substring(start, end);
          var initial = line[start];
          if (contains(numchars, initial) || // ordinary number
          initial == "." && token != "." && token != "...") {
            yield_(new TokenInfo(tokens.T_NUMBER, token, spos, epos, line));
          } else if (contains("\r\n", initial)) {
            if (parenlev > 0) {
              yield_(new TokenInfo(tokens.T_NL, token, spos, epos, line));
            } else {
              yield_(new TokenInfo(tokens.T_NEWLINE, token, spos, epos, line));
            }
          } else if (initial == "#") {
            yield_(new TokenInfo(tokens.T_COMMENT, token, spos, epos, line));
          } else if (contains(triple_quoted, token)) {
            endprog = endpats[token];
            endmatch = endprog.exec(line.substring(pos));
            if (endmatch) {
              pos = endmatch[0].length + pos;
              token = line.substring(start, pos);
              yield_(new TokenInfo(tokens.T_STRING, token, spos, [lnum, pos], line));
            } else {
              strstart = [lnum, start];
              contstr = line.substring(start);
              contline = line;
              break;
            }
          } else if (contains(single_quoted, initial) || contains(single_quoted, token.substring(0, 2)) || contains(single_quoted, token.substring(0, 3))) {
            if (token[token.length - 1] == "\n") {
              strstart = [lnum, start];
              endprog = endpats[initial] || endpats[token[1]] || endpats[token[2]];
              contstr = line.substring(start);
              needcont = 1;
              contline = line;
              break;
            } else {
              yield_(new TokenInfo(tokens.T_STRING, token, spos, epos, line));
            }
          } else if (isidentifier(initial)) {
            yield_(new TokenInfo(tokens.T_NAME, token, spos, epos, line));
          } else if (initial == "\\") {
            continued = 1;
          } else {
            if (contains("([{", initial)) {
              parenlev += 1;
            } else if (contains(")]}", initial)) {
              parenlev -= 1;
            }
            yield_(new TokenInfo(tokens.T_OP, token, spos, epos, line));
          }
        } else {
          yield_(
            new TokenInfo(
              tokens.T_ERRORTOKEN,
              line[pos],
              [lnum, pos],
              [lnum, pos + 1],
              line
            )
          );
          pos += 1;
        }
      }
    }
    if (last_line && !contains("\r\n", last_line[last_line.length - 1])) {
      yield_(
        new TokenInfo(
          tokens.T_NEWLINE,
          "",
          [lnum - 1, last_line.length],
          [lnum - 1, last_line.length + 1],
          ""
        )
      );
    }
    for (var i in indents.slice(1)) {
      yield_(new TokenInfo(tokens.T_DEDENT, "", [lnum, 0], [lnum, 0], ""));
    }
    yield_(new TokenInfo(tokens.T_ENDMARKER, "", [lnum, 0], [lnum, 0], ""));
  }
  var tokens, TokenError, IndentationError, reRegExpChar, reHasRegExpChar, Lu, Ll, Lt, Lm, Lo, Nl, Mn, Mc, Nd, Pc, the_underscore, Other_ID_Start, Other_ID_Continue, id_start, id_continue, IDENTIFIER, IS_IDENTIFIER_REGEX, Whitespace, Comment_, Ignore, Name, Exponent, Pointfloat, Expfloat, Floatnumber, Imagnumber, StringPrefix, Single, Double, Single3, Double3, Triple, String_, EXACT_TOKENS_SORTED, Special, Funny, ContStr, PseudoExtras, endpats, prefixes, single_quoted, triple_quoted, tabsize, PseudoTokenRegex;
  var init_tokenize = __esm({
    "src/tokenize.js"() {
      init_Unicode();
      tokens = Sk.token.tokens;
      TokenError = Sk.builtin.SyntaxError;
      IndentationError = Sk.builtin.IndentationError;
      TokenInfo.prototype.exact_type = function() {
        if (this.type == tokens.T_OP && this.string in Sk.token.EXACT_TOKEN_TYPES) {
          return Sk.token.EXACT_TOKEN_TYPES[this.string];
        } else {
          return this.type;
        }
      };
      reRegExpChar = /[\\^$.*+?()[\]{}|]/g;
      reHasRegExpChar = RegExp(reRegExpChar.source);
      ({ Lu, Ll, Lt, Lm, Lo, Nl, Mn, Mc, Nd, Pc } = Unicode_default);
      the_underscore = "_";
      Other_ID_Start = "\\u1885-\\u1886\\u2118\\u212E\\u309B-\\u309C";
      Other_ID_Continue = "\\u00B7\\u0387\\u1369-\\u1371\\u19DA";
      id_start = Lu + Ll + Lt + Lm + Lo + Nl + the_underscore + Other_ID_Start;
      id_continue = id_start + Mn + Mc + Nd + Pc + Other_ID_Continue;
      IDENTIFIER = "[" + id_start + "]+[" + id_continue + "]*";
      IS_IDENTIFIER_REGEX = new RegExp("^" + IDENTIFIER + "$");
      Sk.token.isIdentifier = isidentifier;
      Whitespace = "[ \\f\\t]*";
      Comment_ = "#[^\\r\\n]*";
      Ignore = Whitespace + any("\\\\\\r?\\n" + Whitespace) + maybe(Comment_);
      Name = IDENTIFIER;
      Exponent = "[eE][-+]?[0-9](?:_?[0-9])*";
      Pointfloat = group("[0-9](?:_?[0-9])*\\.(?:[0-9](?:_?[0-9])*)?", "\\.[0-9](?:_?[0-9])*") + maybe(Exponent);
      Expfloat = "[0-9](?:_?[0-9])*" + Exponent;
      Floatnumber = group(Pointfloat, Expfloat);
      Imagnumber = group("[0-9](?:_?[0-9])*[jJ]", Floatnumber + "[jJ]");
      StringPrefix = group.apply(null, _all_string_prefixes());
      Single = "^[^'\\\\]*(?:\\\\.[^'\\\\]*)*'";
      Double = '^[^"\\\\]*(?:\\\\.[^"\\\\]*)*"';
      Single3 = "^[^'\\\\]*(?:(?:\\\\.|'(?!''))[^'\\\\]*)*'''";
      Double3 = '^[^"\\\\]*(?:(?:\\\\.|"(?!""))[^"\\\\]*)*"""';
      Triple = group(StringPrefix + "'''", StringPrefix + '"""');
      String_ = group(
        StringPrefix + "'[^\\n'\\\\]*(?:\\\\.[^\\n'\\\\]*)*'",
        StringPrefix + '"[^\\n"\\\\]*(?:\\\\.[^\\n"\\\\]*)*"'
      );
      setupTokens(true);
      Sk.token.setupTokens = setupTokens;
      ContStr = group(
        StringPrefix + "'[^\\n'\\\\]*(?:\\\\.[^\\n'\\\\]*)*" + group("'", "\\\\\\r?\\n"),
        StringPrefix + '"[^\\n"\\\\]*(?:\\\\.[^\\n"\\\\]*)*' + group('"', "\\\\\\r?\\n")
      );
      PseudoExtras = group("\\\\\\r?\\n|$", Comment_, Triple);
      endpats = {};
      prefixes = _all_string_prefixes();
      for (let _prefix of prefixes) {
        endpats[_prefix + "'"] = RegExp(Single);
        endpats[_prefix + '"'] = RegExp(Double);
        endpats[_prefix + "'''"] = RegExp(Single3);
        endpats[_prefix + '"""'] = RegExp(Double3);
      }
      single_quoted = [];
      triple_quoted = [];
      for (let t of prefixes) {
        single_quoted.push(t + '"');
        single_quoted.push(t + "'");
        triple_quoted.push(t + '"""');
        triple_quoted.push(t + "'''");
      }
      tabsize = 8;
      Sk._setupTokenRegexes = _setupTokenRegexes;
      Sk.exportSymbol("Sk._setupTokenRegexes", Sk._setupTokenRegexes);
      Sk._tokenize = _tokenize;
      Sk._tokenize.Floatnumber = Floatnumber;
      Sk.exportSymbol("Sk._tokenize", Sk._tokenize);
    }
  });

  // gen/parse_tables.js
  var require_parse_tables = __commonJS({
    "gen/parse_tables.js"() {
      Sk.OpMap = {
        "(": Sk.token.tokens.T_LPAR,
        ")": Sk.token.tokens.T_RPAR,
        "[": Sk.token.tokens.T_LSQB,
        "]": Sk.token.tokens.T_RSQB,
        ":": Sk.token.tokens.T_COLON,
        ",": Sk.token.tokens.T_COMMA,
        ";": Sk.token.tokens.T_SEMI,
        "+": Sk.token.tokens.T_PLUS,
        "-": Sk.token.tokens.T_MINUS,
        "*": Sk.token.tokens.T_STAR,
        "/": Sk.token.tokens.T_SLASH,
        "|": Sk.token.tokens.T_VBAR,
        "&": Sk.token.tokens.T_AMPER,
        "<": Sk.token.tokens.T_LESS,
        ">": Sk.token.tokens.T_GREATER,
        "=": Sk.token.tokens.T_EQUAL,
        ".": Sk.token.tokens.T_DOT,
        "%": Sk.token.tokens.T_PERCENT,
        "`": Sk.token.tokens.T_BACKQUOTE,
        "{": Sk.token.tokens.T_LBRACE,
        "}": Sk.token.tokens.T_RBRACE,
        "@": Sk.token.tokens.T_AT,
        "@=": Sk.token.tokens.T_ATEQUAL,
        "==": Sk.token.tokens.T_EQEQUAL,
        "!=": Sk.token.tokens.T_NOTEQUAL,
        "<>": Sk.token.tokens.T_NOTEQUAL,
        "<=": Sk.token.tokens.T_LESSEQUAL,
        ">=": Sk.token.tokens.T_GREATEREQUAL,
        "~": Sk.token.tokens.T_TILDE,
        "^": Sk.token.tokens.T_CIRCUMFLEX,
        "<<": Sk.token.tokens.T_LEFTSHIFT,
        ">>": Sk.token.tokens.T_RIGHTSHIFT,
        "**": Sk.token.tokens.T_DOUBLESTAR,
        "+=": Sk.token.tokens.T_PLUSEQUAL,
        "-=": Sk.token.tokens.T_MINEQUAL,
        "*=": Sk.token.tokens.T_STAREQUAL,
        "/=": Sk.token.tokens.T_SLASHEQUAL,
        "%=": Sk.token.tokens.T_PERCENTEQUAL,
        "&=": Sk.token.tokens.T_AMPEREQUAL,
        "|=": Sk.token.tokens.T_VBAREQUAL,
        "^=": Sk.token.tokens.T_CIRCUMFLEXEQUAL,
        "<<=": Sk.token.tokens.T_LEFTSHIFTEQUAL,
        ">>=": Sk.token.tokens.T_RIGHTSHIFTEQUAL,
        "**=": Sk.token.tokens.T_DOUBLESTAREQUAL,
        "//": Sk.token.tokens.T_DOUBLESLASH,
        "//=": Sk.token.tokens.T_DOUBLESLASHEQUAL,
        "->": Sk.token.tokens.T_RARROW,
        "...": Sk.token.tokens.T_ELLIPSIS
      };
      Sk.ParseTables = {
        sym: {
          and_expr: 257,
          and_test: 258,
          annassign: 259,
          arglist: 260,
          argument: 261,
          arith_expr: 262,
          assert_stmt: 263,
          async_funcdef: 264,
          async_stmt: 265,
          atom: 266,
          atom_expr: 267,
          augassign: 268,
          break_stmt: 269,
          classdef: 270,
          comp_for: 271,
          comp_if: 272,
          comp_iter: 273,
          comp_op: 274,
          comparison: 275,
          compound_stmt: 276,
          continue_stmt: 277,
          debugger_stmt: 278,
          decorated: 279,
          decorator: 280,
          decorators: 281,
          del_stmt: 282,
          dictorsetmaker: 283,
          dotted_as_name: 284,
          dotted_as_names: 285,
          dotted_name: 286,
          encoding_decl: 287,
          eval_input: 288,
          except_clause: 289,
          expr: 290,
          expr_stmt: 291,
          exprlist: 292,
          factor: 293,
          file_input: 294,
          flow_stmt: 295,
          for_stmt: 296,
          funcdef: 297,
          global_stmt: 298,
          if_stmt: 299,
          import_as_name: 300,
          import_as_names: 301,
          import_from: 302,
          import_name: 303,
          import_stmt: 304,
          lambdef: 305,
          lambdef_nocond: 306,
          nonlocal_stmt: 307,
          not_test: 308,
          or_test: 309,
          parameters: 310,
          pass_stmt: 311,
          power: 312,
          print_stmt: 313,
          raise_stmt: 314,
          return_stmt: 315,
          shift_expr: 316,
          simple_stmt: 317,
          single_input: 256,
          sliceop: 318,
          small_stmt: 319,
          star_expr: 320,
          stmt: 321,
          subscript: 322,
          subscriptlist: 323,
          suite: 324,
          term: 325,
          test: 326,
          test_nocond: 327,
          testlist: 328,
          testlist_comp: 329,
          testlist_star_expr: 330,
          tfpdef: 331,
          trailer: 332,
          try_stmt: 333,
          typedargslist: 334,
          varargslist: 335,
          vfpdef: 336,
          while_stmt: 337,
          with_item: 338,
          with_stmt: 339,
          xor_expr: 340,
          yield_arg: 341,
          yield_expr: 342,
          yield_stmt: 343
        },
        number2symbol: {
          256: "single_input",
          257: "and_expr",
          258: "and_test",
          259: "annassign",
          260: "arglist",
          261: "argument",
          262: "arith_expr",
          263: "assert_stmt",
          264: "async_funcdef",
          265: "async_stmt",
          266: "atom",
          267: "atom_expr",
          268: "augassign",
          269: "break_stmt",
          270: "classdef",
          271: "comp_for",
          272: "comp_if",
          273: "comp_iter",
          274: "comp_op",
          275: "comparison",
          276: "compound_stmt",
          277: "continue_stmt",
          278: "debugger_stmt",
          279: "decorated",
          280: "decorator",
          281: "decorators",
          282: "del_stmt",
          283: "dictorsetmaker",
          284: "dotted_as_name",
          285: "dotted_as_names",
          286: "dotted_name",
          287: "encoding_decl",
          288: "eval_input",
          289: "except_clause",
          290: "expr",
          291: "expr_stmt",
          292: "exprlist",
          293: "factor",
          294: "file_input",
          295: "flow_stmt",
          296: "for_stmt",
          297: "funcdef",
          298: "global_stmt",
          299: "if_stmt",
          300: "import_as_name",
          301: "import_as_names",
          302: "import_from",
          303: "import_name",
          304: "import_stmt",
          305: "lambdef",
          306: "lambdef_nocond",
          307: "nonlocal_stmt",
          308: "not_test",
          309: "or_test",
          310: "parameters",
          311: "pass_stmt",
          312: "power",
          313: "print_stmt",
          314: "raise_stmt",
          315: "return_stmt",
          316: "shift_expr",
          317: "simple_stmt",
          318: "sliceop",
          319: "small_stmt",
          320: "star_expr",
          321: "stmt",
          322: "subscript",
          323: "subscriptlist",
          324: "suite",
          325: "term",
          326: "test",
          327: "test_nocond",
          328: "testlist",
          329: "testlist_comp",
          330: "testlist_star_expr",
          331: "tfpdef",
          332: "trailer",
          333: "try_stmt",
          334: "typedargslist",
          335: "varargslist",
          336: "vfpdef",
          337: "while_stmt",
          338: "with_item",
          339: "with_stmt",
          340: "xor_expr",
          341: "yield_arg",
          342: "yield_expr",
          343: "yield_stmt"
        },
        dfas: {
          256: [
            [[[1, 1], [2, 1], [3, 2]], [[0, 1]], [[2, 1]]],
            {
              2: 1,
              4: 1,
              5: 1,
              6: 1,
              7: 1,
              8: 1,
              9: 1,
              10: 1,
              11: 1,
              12: 1,
              13: 1,
              14: 1,
              15: 1,
              16: 1,
              17: 1,
              18: 1,
              19: 1,
              20: 1,
              21: 1,
              22: 1,
              23: 1,
              24: 1,
              25: 1,
              26: 1,
              27: 1,
              28: 1,
              29: 1,
              30: 1,
              31: 1,
              32: 1,
              33: 1,
              34: 1,
              35: 1,
              36: 1,
              37: 1,
              38: 1,
              39: 1,
              40: 1,
              41: 1,
              42: 1,
              43: 1
            }
          ],
          257: [
            [[[44, 1]], [[45, 0], [0, 1]]],
            {
              6: 1,
              7: 1,
              9: 1,
              11: 1,
              12: 1,
              19: 1,
              22: 1,
              25: 1,
              29: 1,
              30: 1,
              33: 1,
              35: 1,
              38: 1,
              43: 1
            }
          ],
          258: [
            [[[46, 1]], [[47, 0], [0, 1]]],
            {
              6: 1,
              7: 1,
              8: 1,
              9: 1,
              11: 1,
              12: 1,
              19: 1,
              22: 1,
              25: 1,
              29: 1,
              30: 1,
              33: 1,
              35: 1,
              38: 1,
              43: 1
            }
          ],
          259: [
            [[[48, 1]], [[49, 2]], [[50, 3], [0, 2]], [[49, 4]], [[0, 4]]],
            { 48: 1 }
          ],
          260: [
            [[[51, 1]], [[52, 2], [0, 1]], [[51, 1], [0, 2]]],
            {
              6: 1,
              7: 1,
              8: 1,
              9: 1,
              11: 1,
              12: 1,
              14: 1,
              15: 1,
              19: 1,
              22: 1,
              25: 1,
              29: 1,
              30: 1,
              33: 1,
              35: 1,
              38: 1,
              43: 1,
              53: 1
            }
          ],
          261: [
            [
              [[49, 1], [15, 2], [53, 2]],
              [[50, 2], [54, 3], [0, 1]],
              [[49, 3]],
              [[0, 3]]
            ],
            {
              6: 1,
              7: 1,
              8: 1,
              9: 1,
              11: 1,
              12: 1,
              14: 1,
              15: 1,
              19: 1,
              22: 1,
              25: 1,
              29: 1,
              30: 1,
              33: 1,
              35: 1,
              38: 1,
              43: 1,
              53: 1
            }
          ],
          262: [
            [[[55, 1]], [[30, 0], [43, 0], [0, 1]]],
            {
              6: 1,
              7: 1,
              9: 1,
              11: 1,
              12: 1,
              19: 1,
              22: 1,
              25: 1,
              29: 1,
              30: 1,
              33: 1,
              35: 1,
              38: 1,
              43: 1
            }
          ],
          263: [
            [[[24, 1]], [[49, 2]], [[52, 3], [0, 2]], [[49, 4]], [[0, 4]]],
            { 24: 1 }
          ],
          264: [[[[10, 1]], [[56, 2]], [[0, 2]]], { 10: 1 }],
          265: [[[[10, 1]], [[57, 2], [56, 2], [58, 2]], [[0, 2]]], { 10: 1 }],
          266: [
            [
              [
                [6, 1],
                [25, 1],
                [33, 1],
                [9, 1],
                [11, 1],
                [12, 2],
                [35, 3],
                [38, 4],
                [19, 1],
                [7, 5]
              ],
              [[0, 1]],
              [[59, 1], [60, 6]],
              [[61, 1], [62, 7], [63, 7]],
              [[64, 1], [63, 8]],
              [[7, 5], [0, 5]],
              [[59, 1]],
              [[61, 1]],
              [[64, 1]]
            ],
            { 6: 1, 7: 1, 9: 1, 11: 1, 12: 1, 19: 1, 25: 1, 33: 1, 35: 1, 38: 1 }
          ],
          267: [
            [[[29, 1], [65, 2]], [[65, 2]], [[66, 2], [0, 2]]],
            {
              6: 1,
              7: 1,
              9: 1,
              11: 1,
              12: 1,
              19: 1,
              25: 1,
              29: 1,
              33: 1,
              35: 1,
              38: 1
            }
          ],
          268: [
            [
              [
                [67, 1],
                [68, 1],
                [69, 1],
                [70, 1],
                [71, 1],
                [72, 1],
                [73, 1],
                [74, 1],
                [75, 1],
                [76, 1],
                [77, 1],
                [78, 1],
                [79, 1]
              ],
              [[0, 1]]
            ],
            {
              67: 1,
              68: 1,
              69: 1,
              70: 1,
              71: 1,
              72: 1,
              73: 1,
              74: 1,
              75: 1,
              76: 1,
              77: 1,
              78: 1,
              79: 1
            }
          ],
          269: [[[[39, 1]], [[0, 1]]], { 39: 1 }],
          270: [
            [
              [[13, 1]],
              [[25, 2]],
              [[48, 3], [35, 4]],
              [[80, 5]],
              [[61, 6], [81, 7]],
              [[0, 5]],
              [[48, 3]],
              [[61, 6]]
            ],
            { 13: 1 }
          ],
          271: [
            [
              [[10, 1], [34, 2]],
              [[34, 2]],
              [[82, 3]],
              [[83, 4]],
              [[84, 5]],
              [[85, 6], [0, 5]],
              [[0, 6]]
            ],
            { 10: 1, 34: 1 }
          ],
          272: [[[[37, 1]], [[86, 2]], [[85, 3], [0, 2]], [[0, 3]]], { 37: 1 }],
          273: [[[[87, 1], [54, 1]], [[0, 1]]], { 10: 1, 34: 1, 37: 1 }],
          274: [
            [
              [
                [88, 1],
                [89, 1],
                [8, 2],
                [90, 1],
                [88, 1],
                [83, 1],
                [91, 1],
                [92, 3],
                [93, 1],
                [94, 1]
              ],
              [[0, 1]],
              [[83, 1]],
              [[8, 1], [0, 3]]
            ],
            { 8: 1, 83: 1, 88: 1, 89: 1, 90: 1, 91: 1, 92: 1, 93: 1, 94: 1 }
          ],
          275: [
            [[[95, 1]], [[96, 0], [0, 1]]],
            {
              6: 1,
              7: 1,
              9: 1,
              11: 1,
              12: 1,
              19: 1,
              22: 1,
              25: 1,
              29: 1,
              30: 1,
              33: 1,
              35: 1,
              38: 1,
              43: 1
            }
          ],
          276: [
            [
              [
                [97, 1],
                [98, 1],
                [58, 1],
                [99, 1],
                [57, 1],
                [100, 1],
                [56, 1],
                [101, 1],
                [102, 1]
              ],
              [[0, 1]]
            ],
            { 4: 1, 10: 1, 13: 1, 20: 1, 21: 1, 34: 1, 37: 1, 41: 1, 42: 1 }
          ],
          277: [[[[40, 1]], [[0, 1]]], { 40: 1 }],
          278: [[[[17, 1]], [[0, 1]]], { 17: 1 }],
          279: [[[[103, 1]], [[56, 2], [104, 2], [99, 2]], [[0, 2]]], { 41: 1 }],
          280: [
            [
              [[41, 1]],
              [[105, 2]],
              [[2, 4], [35, 3]],
              [[61, 5], [81, 6]],
              [[0, 4]],
              [[2, 4]],
              [[61, 5]]
            ],
            { 41: 1 }
          ],
          281: [[[[106, 1]], [[106, 1], [0, 1]]], { 41: 1 }],
          282: [[[[27, 1]], [[82, 2]], [[0, 2]]], { 27: 1 }],
          283: [
            [
              [[49, 1], [107, 2], [53, 3]],
              [[48, 4], [54, 5], [52, 6], [0, 1]],
              [[54, 5], [52, 6], [0, 2]],
              [[95, 7]],
              [[49, 7]],
              [[0, 5]],
              [[49, 8], [107, 8], [0, 6]],
              [[54, 5], [52, 9], [0, 7]],
              [[52, 6], [0, 8]],
              [[49, 10], [53, 11], [0, 9]],
              [[48, 12]],
              [[95, 13]],
              [[49, 13]],
              [[52, 9], [0, 13]]
            ],
            {
              6: 1,
              7: 1,
              8: 1,
              9: 1,
              11: 1,
              12: 1,
              14: 1,
              15: 1,
              19: 1,
              22: 1,
              25: 1,
              29: 1,
              30: 1,
              33: 1,
              35: 1,
              38: 1,
              43: 1,
              53: 1
            }
          ],
          284: [[[[105, 1]], [[108, 2], [0, 1]], [[25, 3]], [[0, 3]]], { 25: 1 }],
          285: [[[[109, 1]], [[52, 0], [0, 1]]], { 25: 1 }],
          286: [[[[25, 1]], [[110, 0], [0, 1]]], { 25: 1 }],
          287: [[[[25, 1]], [[0, 1]]], { 25: 1 }],
          288: [
            [[[111, 1]], [[2, 1], [112, 2]], [[0, 2]]],
            {
              6: 1,
              7: 1,
              8: 1,
              9: 1,
              11: 1,
              12: 1,
              14: 1,
              19: 1,
              22: 1,
              25: 1,
              29: 1,
              30: 1,
              33: 1,
              35: 1,
              38: 1,
              43: 1
            }
          ],
          289: [
            [
              [[113, 1]],
              [[49, 2], [0, 1]],
              [[108, 3], [52, 3], [0, 2]],
              [[49, 4]],
              [[0, 4]]
            ],
            { 113: 1 }
          ],
          290: [
            [[[114, 1]], [[115, 0], [0, 1]]],
            {
              6: 1,
              7: 1,
              9: 1,
              11: 1,
              12: 1,
              19: 1,
              22: 1,
              25: 1,
              29: 1,
              30: 1,
              33: 1,
              35: 1,
              38: 1,
              43: 1
            }
          ],
          291: [
            [
              [[116, 1]],
              [[117, 2], [50, 3], [118, 4], [0, 1]],
              [[111, 4], [62, 4]],
              [[116, 5], [62, 5]],
              [[0, 4]],
              [[50, 3], [0, 5]]
            ],
            {
              6: 1,
              7: 1,
              8: 1,
              9: 1,
              11: 1,
              12: 1,
              14: 1,
              15: 1,
              19: 1,
              22: 1,
              25: 1,
              29: 1,
              30: 1,
              33: 1,
              35: 1,
              38: 1,
              43: 1
            }
          ],
          292: [
            [[[95, 1], [107, 1]], [[52, 2], [0, 1]], [[95, 1], [107, 1], [0, 2]]],
            {
              6: 1,
              7: 1,
              9: 1,
              11: 1,
              12: 1,
              15: 1,
              19: 1,
              22: 1,
              25: 1,
              29: 1,
              30: 1,
              33: 1,
              35: 1,
              38: 1,
              43: 1
            }
          ],
          293: [
            [[[119, 2], [30, 1], [22, 1], [43, 1]], [[120, 2]], [[0, 2]]],
            {
              6: 1,
              7: 1,
              9: 1,
              11: 1,
              12: 1,
              19: 1,
              22: 1,
              25: 1,
              29: 1,
              30: 1,
              33: 1,
              35: 1,
              38: 1,
              43: 1
            }
          ],
          294: [
            [[[2, 0], [112, 1], [121, 0]], [[0, 1]]],
            {
              2: 1,
              4: 1,
              5: 1,
              6: 1,
              7: 1,
              8: 1,
              9: 1,
              10: 1,
              11: 1,
              12: 1,
              13: 1,
              14: 1,
              15: 1,
              16: 1,
              17: 1,
              18: 1,
              19: 1,
              20: 1,
              21: 1,
              22: 1,
              23: 1,
              24: 1,
              25: 1,
              26: 1,
              27: 1,
              28: 1,
              29: 1,
              30: 1,
              31: 1,
              32: 1,
              33: 1,
              34: 1,
              35: 1,
              36: 1,
              37: 1,
              38: 1,
              39: 1,
              40: 1,
              41: 1,
              42: 1,
              43: 1,
              112: 1
            }
          ],
          295: [
            [[[122, 1], [123, 1], [124, 1], [125, 1], [126, 1]], [[0, 1]]],
            { 5: 1, 23: 1, 31: 1, 39: 1, 40: 1 }
          ],
          296: [
            [
              [[34, 1]],
              [[82, 2]],
              [[83, 3]],
              [[111, 4]],
              [[48, 5]],
              [[80, 6]],
              [[127, 7], [0, 6]],
              [[48, 8]],
              [[80, 9]],
              [[0, 9]]
            ],
            { 34: 1 }
          ],
          297: [
            [
              [[4, 1]],
              [[25, 2]],
              [[128, 3]],
              [[48, 4], [129, 5]],
              [[80, 6]],
              [[49, 7]],
              [[0, 6]],
              [[48, 4]]
            ],
            { 4: 1 }
          ],
          298: [[[[26, 1]], [[25, 2]], [[52, 1], [0, 2]]], { 26: 1 }],
          299: [
            [
              [[37, 1]],
              [[49, 2]],
              [[48, 3]],
              [[80, 4]],
              [[127, 5], [130, 1], [0, 4]],
              [[48, 6]],
              [[80, 7]],
              [[0, 7]]
            ],
            { 37: 1 }
          ],
          300: [[[[25, 1]], [[108, 2], [0, 1]], [[25, 3]], [[0, 3]]], { 25: 1 }],
          301: [[[[131, 1]], [[52, 2], [0, 1]], [[131, 1], [0, 2]]], { 25: 1 }],
          302: [
            [
              [[36, 1]],
              [[105, 2], [19, 3], [110, 3]],
              [[32, 4]],
              [[105, 2], [19, 3], [32, 4], [110, 3]],
              [[132, 5], [15, 5], [35, 6]],
              [[0, 5]],
              [[132, 7]],
              [[61, 5]]
            ],
            { 36: 1 }
          ],
          303: [[[[32, 1]], [[133, 2]], [[0, 2]]], { 32: 1 }],
          304: [[[[134, 1], [135, 1]], [[0, 1]]], { 32: 1, 36: 1 }],
          305: [
            [[[14, 1]], [[48, 2], [136, 3]], [[49, 4]], [[48, 2]], [[0, 4]]],
            { 14: 1 }
          ],
          306: [
            [[[14, 1]], [[48, 2], [136, 3]], [[86, 4]], [[48, 2]], [[0, 4]]],
            { 14: 1 }
          ],
          307: [[[[18, 1]], [[25, 2]], [[52, 1], [0, 2]]], { 18: 1 }],
          308: [
            [[[8, 1], [137, 2]], [[46, 2]], [[0, 2]]],
            {
              6: 1,
              7: 1,
              8: 1,
              9: 1,
              11: 1,
              12: 1,
              19: 1,
              22: 1,
              25: 1,
              29: 1,
              30: 1,
              33: 1,
              35: 1,
              38: 1,
              43: 1
            }
          ],
          309: [
            [[[138, 1]], [[139, 0], [0, 1]]],
            {
              6: 1,
              7: 1,
              8: 1,
              9: 1,
              11: 1,
              12: 1,
              19: 1,
              22: 1,
              25: 1,
              29: 1,
              30: 1,
              33: 1,
              35: 1,
              38: 1,
              43: 1
            }
          ],
          310: [[[[35, 1]], [[61, 2], [140, 3]], [[0, 2]], [[61, 2]]], { 35: 1 }],
          311: [[[[28, 1]], [[0, 1]]], { 28: 1 }],
          312: [
            [[[141, 1]], [[53, 2], [0, 1]], [[120, 3]], [[0, 3]]],
            {
              6: 1,
              7: 1,
              9: 1,
              11: 1,
              12: 1,
              19: 1,
              25: 1,
              29: 1,
              33: 1,
              35: 1,
              38: 1
            }
          ],
          313: [
            [
              [[16, 1]],
              [[49, 2], [142, 3], [0, 1]],
              [[52, 4], [0, 2]],
              [[49, 5]],
              [[49, 2], [0, 4]],
              [[52, 6], [0, 5]],
              [[49, 7]],
              [[52, 8], [0, 7]],
              [[49, 7], [0, 8]]
            ],
            { 16: 1 }
          ],
          314: [
            [
              [[5, 1]],
              [[49, 2], [0, 1]],
              [[36, 3], [52, 3], [0, 2]],
              [[49, 4]],
              [[52, 5], [0, 4]],
              [[49, 6]],
              [[0, 6]]
            ],
            { 5: 1 }
          ],
          315: [[[[23, 1]], [[111, 2], [0, 1]], [[0, 2]]], { 23: 1 }],
          316: [
            [[[143, 1]], [[144, 0], [142, 0], [0, 1]]],
            {
              6: 1,
              7: 1,
              9: 1,
              11: 1,
              12: 1,
              19: 1,
              22: 1,
              25: 1,
              29: 1,
              30: 1,
              33: 1,
              35: 1,
              38: 1,
              43: 1
            }
          ],
          317: [
            [[[145, 1]], [[2, 2], [146, 3]], [[0, 2]], [[145, 1], [2, 2]]],
            {
              5: 1,
              6: 1,
              7: 1,
              8: 1,
              9: 1,
              11: 1,
              12: 1,
              14: 1,
              15: 1,
              16: 1,
              17: 1,
              18: 1,
              19: 1,
              22: 1,
              23: 1,
              24: 1,
              25: 1,
              26: 1,
              27: 1,
              28: 1,
              29: 1,
              30: 1,
              31: 1,
              32: 1,
              33: 1,
              35: 1,
              36: 1,
              38: 1,
              39: 1,
              40: 1,
              43: 1
            }
          ],
          318: [[[[48, 1]], [[49, 2], [0, 1]], [[0, 2]]], { 48: 1 }],
          319: [
            [
              [
                [147, 1],
                [148, 1],
                [149, 1],
                [150, 1],
                [151, 1],
                [152, 1],
                [153, 1],
                [154, 1],
                [155, 1],
                [156, 1]
              ],
              [[0, 1]]
            ],
            {
              5: 1,
              6: 1,
              7: 1,
              8: 1,
              9: 1,
              11: 1,
              12: 1,
              14: 1,
              15: 1,
              16: 1,
              17: 1,
              18: 1,
              19: 1,
              22: 1,
              23: 1,
              24: 1,
              25: 1,
              26: 1,
              27: 1,
              28: 1,
              29: 1,
              30: 1,
              31: 1,
              32: 1,
              33: 1,
              35: 1,
              36: 1,
              38: 1,
              39: 1,
              40: 1,
              43: 1
            }
          ],
          320: [[[[15, 1]], [[95, 2]], [[0, 2]]], { 15: 1 }],
          321: [
            [[[1, 1], [3, 1]], [[0, 1]]],
            {
              4: 1,
              5: 1,
              6: 1,
              7: 1,
              8: 1,
              9: 1,
              10: 1,
              11: 1,
              12: 1,
              13: 1,
              14: 1,
              15: 1,
              16: 1,
              17: 1,
              18: 1,
              19: 1,
              20: 1,
              21: 1,
              22: 1,
              23: 1,
              24: 1,
              25: 1,
              26: 1,
              27: 1,
              28: 1,
              29: 1,
              30: 1,
              31: 1,
              32: 1,
              33: 1,
              34: 1,
              35: 1,
              36: 1,
              37: 1,
              38: 1,
              39: 1,
              40: 1,
              41: 1,
              42: 1,
              43: 1
            }
          ],
          322: [
            [
              [[49, 1], [48, 2]],
              [[48, 2], [0, 1]],
              [[49, 3], [157, 4], [0, 2]],
              [[157, 4], [0, 3]],
              [[0, 4]]
            ],
            {
              6: 1,
              7: 1,
              8: 1,
              9: 1,
              11: 1,
              12: 1,
              14: 1,
              19: 1,
              22: 1,
              25: 1,
              29: 1,
              30: 1,
              33: 1,
              35: 1,
              38: 1,
              43: 1,
              48: 1
            }
          ],
          323: [
            [[[158, 1]], [[52, 2], [0, 1]], [[158, 1], [0, 2]]],
            {
              6: 1,
              7: 1,
              8: 1,
              9: 1,
              11: 1,
              12: 1,
              14: 1,
              19: 1,
              22: 1,
              25: 1,
              29: 1,
              30: 1,
              33: 1,
              35: 1,
              38: 1,
              43: 1,
              48: 1
            }
          ],
          324: [
            [
              [[1, 1], [2, 2]],
              [[0, 1]],
              [[159, 3]],
              [[121, 4]],
              [[160, 1], [121, 4]]
            ],
            {
              2: 1,
              5: 1,
              6: 1,
              7: 1,
              8: 1,
              9: 1,
              11: 1,
              12: 1,
              14: 1,
              15: 1,
              16: 1,
              17: 1,
              18: 1,
              19: 1,
              22: 1,
              23: 1,
              24: 1,
              25: 1,
              26: 1,
              27: 1,
              28: 1,
              29: 1,
              30: 1,
              31: 1,
              32: 1,
              33: 1,
              35: 1,
              36: 1,
              38: 1,
              39: 1,
              40: 1,
              43: 1
            }
          ],
          325: [
            [[[120, 1]], [[161, 0], [15, 0], [162, 0], [41, 0], [163, 0], [0, 1]]],
            {
              6: 1,
              7: 1,
              9: 1,
              11: 1,
              12: 1,
              19: 1,
              22: 1,
              25: 1,
              29: 1,
              30: 1,
              33: 1,
              35: 1,
              38: 1,
              43: 1
            }
          ],
          326: [
            [
              [[84, 1], [164, 2]],
              [[37, 3], [0, 1]],
              [[0, 2]],
              [[84, 4]],
              [[127, 5]],
              [[49, 2]]
            ],
            {
              6: 1,
              7: 1,
              8: 1,
              9: 1,
              11: 1,
              12: 1,
              14: 1,
              19: 1,
              22: 1,
              25: 1,
              29: 1,
              30: 1,
              33: 1,
              35: 1,
              38: 1,
              43: 1
            }
          ],
          327: [
            [[[165, 1], [84, 1]], [[0, 1]]],
            {
              6: 1,
              7: 1,
              8: 1,
              9: 1,
              11: 1,
              12: 1,
              14: 1,
              19: 1,
              22: 1,
              25: 1,
              29: 1,
              30: 1,
              33: 1,
              35: 1,
              38: 1,
              43: 1
            }
          ],
          328: [
            [[[49, 1]], [[52, 2], [0, 1]], [[49, 1], [0, 2]]],
            {
              6: 1,
              7: 1,
              8: 1,
              9: 1,
              11: 1,
              12: 1,
              14: 1,
              19: 1,
              22: 1,
              25: 1,
              29: 1,
              30: 1,
              33: 1,
              35: 1,
              38: 1,
              43: 1
            }
          ],
          329: [
            [
              [[49, 1], [107, 1]],
              [[54, 2], [52, 3], [0, 1]],
              [[0, 2]],
              [[49, 4], [107, 4], [0, 3]],
              [[52, 3], [0, 4]]
            ],
            {
              6: 1,
              7: 1,
              8: 1,
              9: 1,
              11: 1,
              12: 1,
              14: 1,
              15: 1,
              19: 1,
              22: 1,
              25: 1,
              29: 1,
              30: 1,
              33: 1,
              35: 1,
              38: 1,
              43: 1
            }
          ],
          330: [
            [[[49, 1], [107, 1]], [[52, 2], [0, 1]], [[49, 1], [107, 1], [0, 2]]],
            {
              6: 1,
              7: 1,
              8: 1,
              9: 1,
              11: 1,
              12: 1,
              14: 1,
              15: 1,
              19: 1,
              22: 1,
              25: 1,
              29: 1,
              30: 1,
              33: 1,
              35: 1,
              38: 1,
              43: 1
            }
          ],
          331: [[[[25, 1]], [[48, 2], [0, 1]], [[49, 3]], [[0, 3]]], { 25: 1 }],
          332: [
            [
              [[35, 1], [110, 2], [38, 3]],
              [[61, 4], [81, 5]],
              [[25, 4]],
              [[166, 6]],
              [[0, 4]],
              [[61, 4]],
              [[64, 4]]
            ],
            { 35: 1, 38: 1, 110: 1 }
          ],
          333: [
            [
              [[20, 1]],
              [[48, 2]],
              [[80, 3]],
              [[167, 4], [168, 5]],
              [[48, 6]],
              [[48, 7]],
              [[80, 8]],
              [[80, 9]],
              [[167, 4], [127, 10], [168, 5], [0, 8]],
              [[0, 9]],
              [[48, 11]],
              [[80, 12]],
              [[168, 5], [0, 12]]
            ],
            { 20: 1 }
          ],
          334: [
            [
              [[15, 1], [169, 2], [53, 3]],
              [[169, 4], [52, 5], [0, 1]],
              [[50, 6], [52, 7], [0, 2]],
              [[169, 8]],
              [[52, 5], [0, 4]],
              [[169, 9], [53, 3], [0, 5]],
              [[49, 10]],
              [[15, 11], [169, 2], [53, 3], [0, 7]],
              [[52, 12], [0, 8]],
              [[50, 13], [52, 5], [0, 9]],
              [[52, 7], [0, 10]],
              [[169, 14], [52, 15], [0, 11]],
              [[0, 12]],
              [[49, 4]],
              [[52, 15], [0, 14]],
              [[169, 16], [53, 3], [0, 15]],
              [[50, 17], [52, 15], [0, 16]],
              [[49, 14]]
            ],
            { 15: 1, 25: 1, 53: 1 }
          ],
          335: [
            [
              [[15, 1], [53, 2], [170, 3]],
              [[170, 5], [52, 4], [0, 1]],
              [[170, 6]],
              [[50, 7], [52, 8], [0, 3]],
              [[53, 2], [170, 9], [0, 4]],
              [[52, 4], [0, 5]],
              [[52, 10], [0, 6]],
              [[49, 11]],
              [[15, 12], [53, 2], [170, 3], [0, 8]],
              [[50, 13], [52, 4], [0, 9]],
              [[0, 10]],
              [[52, 8], [0, 11]],
              [[52, 15], [170, 14], [0, 12]],
              [[49, 5]],
              [[52, 15], [0, 14]],
              [[53, 2], [170, 16], [0, 15]],
              [[50, 17], [52, 15], [0, 16]],
              [[49, 14]]
            ],
            { 15: 1, 25: 1, 53: 1 }
          ],
          336: [[[[25, 1]], [[0, 1]]], { 25: 1 }],
          337: [
            [
              [[21, 1]],
              [[49, 2]],
              [[48, 3]],
              [[80, 4]],
              [[127, 5], [0, 4]],
              [[48, 6]],
              [[80, 7]],
              [[0, 7]]
            ],
            { 21: 1 }
          ],
          338: [
            [[[49, 1]], [[108, 2], [0, 1]], [[95, 3]], [[0, 3]]],
            {
              6: 1,
              7: 1,
              8: 1,
              9: 1,
              11: 1,
              12: 1,
              14: 1,
              19: 1,
              22: 1,
              25: 1,
              29: 1,
              30: 1,
              33: 1,
              35: 1,
              38: 1,
              43: 1
            }
          ],
          339: [
            [[[42, 1]], [[171, 2]], [[48, 3], [52, 1]], [[80, 4]], [[0, 4]]],
            { 42: 1 }
          ],
          340: [
            [[[172, 1]], [[173, 0], [0, 1]]],
            {
              6: 1,
              7: 1,
              9: 1,
              11: 1,
              12: 1,
              19: 1,
              22: 1,
              25: 1,
              29: 1,
              30: 1,
              33: 1,
              35: 1,
              38: 1,
              43: 1
            }
          ],
          341: [
            [[[111, 2], [36, 1]], [[49, 2]], [[0, 2]]],
            {
              6: 1,
              7: 1,
              8: 1,
              9: 1,
              11: 1,
              12: 1,
              14: 1,
              19: 1,
              22: 1,
              25: 1,
              29: 1,
              30: 1,
              33: 1,
              35: 1,
              36: 1,
              38: 1,
              43: 1
            }
          ],
          342: [[[[31, 1]], [[174, 2], [0, 1]], [[0, 2]]], { 31: 1 }],
          343: [[[[62, 1]], [[0, 1]]], { 31: 1 }]
        },
        states: [
          [[[1, 1], [2, 1], [3, 2]], [[0, 1]], [[2, 1]]],
          [[[44, 1]], [[45, 0], [0, 1]]],
          [[[46, 1]], [[47, 0], [0, 1]]],
          [[[48, 1]], [[49, 2]], [[50, 3], [0, 2]], [[49, 4]], [[0, 4]]],
          [[[51, 1]], [[52, 2], [0, 1]], [[51, 1], [0, 2]]],
          [
            [[49, 1], [15, 2], [53, 2]],
            [[50, 2], [54, 3], [0, 1]],
            [[49, 3]],
            [[0, 3]]
          ],
          [[[55, 1]], [[30, 0], [43, 0], [0, 1]]],
          [[[24, 1]], [[49, 2]], [[52, 3], [0, 2]], [[49, 4]], [[0, 4]]],
          [[[10, 1]], [[56, 2]], [[0, 2]]],
          [[[10, 1]], [[57, 2], [56, 2], [58, 2]], [[0, 2]]],
          [
            [
              [6, 1],
              [25, 1],
              [33, 1],
              [9, 1],
              [11, 1],
              [12, 2],
              [35, 3],
              [38, 4],
              [19, 1],
              [7, 5]
            ],
            [[0, 1]],
            [[59, 1], [60, 6]],
            [[61, 1], [62, 7], [63, 7]],
            [[64, 1], [63, 8]],
            [[7, 5], [0, 5]],
            [[59, 1]],
            [[61, 1]],
            [[64, 1]]
          ],
          [[[29, 1], [65, 2]], [[65, 2]], [[66, 2], [0, 2]]],
          [
            [
              [67, 1],
              [68, 1],
              [69, 1],
              [70, 1],
              [71, 1],
              [72, 1],
              [73, 1],
              [74, 1],
              [75, 1],
              [76, 1],
              [77, 1],
              [78, 1],
              [79, 1]
            ],
            [[0, 1]]
          ],
          [[[39, 1]], [[0, 1]]],
          [
            [[13, 1]],
            [[25, 2]],
            [[48, 3], [35, 4]],
            [[80, 5]],
            [[61, 6], [81, 7]],
            [[0, 5]],
            [[48, 3]],
            [[61, 6]]
          ],
          [
            [[10, 1], [34, 2]],
            [[34, 2]],
            [[82, 3]],
            [[83, 4]],
            [[84, 5]],
            [[85, 6], [0, 5]],
            [[0, 6]]
          ],
          [[[37, 1]], [[86, 2]], [[85, 3], [0, 2]], [[0, 3]]],
          [[[87, 1], [54, 1]], [[0, 1]]],
          [
            [
              [88, 1],
              [89, 1],
              [8, 2],
              [90, 1],
              [88, 1],
              [83, 1],
              [91, 1],
              [92, 3],
              [93, 1],
              [94, 1]
            ],
            [[0, 1]],
            [[83, 1]],
            [[8, 1], [0, 3]]
          ],
          [[[95, 1]], [[96, 0], [0, 1]]],
          [
            [
              [97, 1],
              [98, 1],
              [58, 1],
              [99, 1],
              [57, 1],
              [100, 1],
              [56, 1],
              [101, 1],
              [102, 1]
            ],
            [[0, 1]]
          ],
          [[[40, 1]], [[0, 1]]],
          [[[17, 1]], [[0, 1]]],
          [[[103, 1]], [[56, 2], [104, 2], [99, 2]], [[0, 2]]],
          [
            [[41, 1]],
            [[105, 2]],
            [[2, 4], [35, 3]],
            [[61, 5], [81, 6]],
            [[0, 4]],
            [[2, 4]],
            [[61, 5]]
          ],
          [[[106, 1]], [[106, 1], [0, 1]]],
          [[[27, 1]], [[82, 2]], [[0, 2]]],
          [
            [[49, 1], [107, 2], [53, 3]],
            [[48, 4], [54, 5], [52, 6], [0, 1]],
            [[54, 5], [52, 6], [0, 2]],
            [[95, 7]],
            [[49, 7]],
            [[0, 5]],
            [[49, 8], [107, 8], [0, 6]],
            [[54, 5], [52, 9], [0, 7]],
            [[52, 6], [0, 8]],
            [[49, 10], [53, 11], [0, 9]],
            [[48, 12]],
            [[95, 13]],
            [[49, 13]],
            [[52, 9], [0, 13]]
          ],
          [[[105, 1]], [[108, 2], [0, 1]], [[25, 3]], [[0, 3]]],
          [[[109, 1]], [[52, 0], [0, 1]]],
          [[[25, 1]], [[110, 0], [0, 1]]],
          [[[25, 1]], [[0, 1]]],
          [[[111, 1]], [[2, 1], [112, 2]], [[0, 2]]],
          [
            [[113, 1]],
            [[49, 2], [0, 1]],
            [[108, 3], [52, 3], [0, 2]],
            [[49, 4]],
            [[0, 4]]
          ],
          [[[114, 1]], [[115, 0], [0, 1]]],
          [
            [[116, 1]],
            [[117, 2], [50, 3], [118, 4], [0, 1]],
            [[111, 4], [62, 4]],
            [[116, 5], [62, 5]],
            [[0, 4]],
            [[50, 3], [0, 5]]
          ],
          [[[95, 1], [107, 1]], [[52, 2], [0, 1]], [[95, 1], [107, 1], [0, 2]]],
          [[[119, 2], [30, 1], [22, 1], [43, 1]], [[120, 2]], [[0, 2]]],
          [[[2, 0], [112, 1], [121, 0]], [[0, 1]]],
          [[[122, 1], [123, 1], [124, 1], [125, 1], [126, 1]], [[0, 1]]],
          [
            [[34, 1]],
            [[82, 2]],
            [[83, 3]],
            [[111, 4]],
            [[48, 5]],
            [[80, 6]],
            [[127, 7], [0, 6]],
            [[48, 8]],
            [[80, 9]],
            [[0, 9]]
          ],
          [
            [[4, 1]],
            [[25, 2]],
            [[128, 3]],
            [[48, 4], [129, 5]],
            [[80, 6]],
            [[49, 7]],
            [[0, 6]],
            [[48, 4]]
          ],
          [[[26, 1]], [[25, 2]], [[52, 1], [0, 2]]],
          [
            [[37, 1]],
            [[49, 2]],
            [[48, 3]],
            [[80, 4]],
            [[127, 5], [130, 1], [0, 4]],
            [[48, 6]],
            [[80, 7]],
            [[0, 7]]
          ],
          [[[25, 1]], [[108, 2], [0, 1]], [[25, 3]], [[0, 3]]],
          [[[131, 1]], [[52, 2], [0, 1]], [[131, 1], [0, 2]]],
          [
            [[36, 1]],
            [[105, 2], [19, 3], [110, 3]],
            [[32, 4]],
            [[105, 2], [19, 3], [32, 4], [110, 3]],
            [[132, 5], [15, 5], [35, 6]],
            [[0, 5]],
            [[132, 7]],
            [[61, 5]]
          ],
          [[[32, 1]], [[133, 2]], [[0, 2]]],
          [[[134, 1], [135, 1]], [[0, 1]]],
          [[[14, 1]], [[48, 2], [136, 3]], [[49, 4]], [[48, 2]], [[0, 4]]],
          [[[14, 1]], [[48, 2], [136, 3]], [[86, 4]], [[48, 2]], [[0, 4]]],
          [[[18, 1]], [[25, 2]], [[52, 1], [0, 2]]],
          [[[8, 1], [137, 2]], [[46, 2]], [[0, 2]]],
          [[[138, 1]], [[139, 0], [0, 1]]],
          [[[35, 1]], [[61, 2], [140, 3]], [[0, 2]], [[61, 2]]],
          [[[28, 1]], [[0, 1]]],
          [[[141, 1]], [[53, 2], [0, 1]], [[120, 3]], [[0, 3]]],
          [
            [[16, 1]],
            [[49, 2], [142, 3], [0, 1]],
            [[52, 4], [0, 2]],
            [[49, 5]],
            [[49, 2], [0, 4]],
            [[52, 6], [0, 5]],
            [[49, 7]],
            [[52, 8], [0, 7]],
            [[49, 7], [0, 8]]
          ],
          [
            [[5, 1]],
            [[49, 2], [0, 1]],
            [[36, 3], [52, 3], [0, 2]],
            [[49, 4]],
            [[52, 5], [0, 4]],
            [[49, 6]],
            [[0, 6]]
          ],
          [[[23, 1]], [[111, 2], [0, 1]], [[0, 2]]],
          [[[143, 1]], [[144, 0], [142, 0], [0, 1]]],
          [[[145, 1]], [[2, 2], [146, 3]], [[0, 2]], [[145, 1], [2, 2]]],
          [[[48, 1]], [[49, 2], [0, 1]], [[0, 2]]],
          [
            [
              [147, 1],
              [148, 1],
              [149, 1],
              [150, 1],
              [151, 1],
              [152, 1],
              [153, 1],
              [154, 1],
              [155, 1],
              [156, 1]
            ],
            [[0, 1]]
          ],
          [[[15, 1]], [[95, 2]], [[0, 2]]],
          [[[1, 1], [3, 1]], [[0, 1]]],
          [
            [[49, 1], [48, 2]],
            [[48, 2], [0, 1]],
            [[49, 3], [157, 4], [0, 2]],
            [[157, 4], [0, 3]],
            [[0, 4]]
          ],
          [[[158, 1]], [[52, 2], [0, 1]], [[158, 1], [0, 2]]],
          [[[1, 1], [2, 2]], [[0, 1]], [[159, 3]], [[121, 4]], [[160, 1], [121, 4]]],
          [[[120, 1]], [[161, 0], [15, 0], [162, 0], [41, 0], [163, 0], [0, 1]]],
          [
            [[84, 1], [164, 2]],
            [[37, 3], [0, 1]],
            [[0, 2]],
            [[84, 4]],
            [[127, 5]],
            [[49, 2]]
          ],
          [[[165, 1], [84, 1]], [[0, 1]]],
          [[[49, 1]], [[52, 2], [0, 1]], [[49, 1], [0, 2]]],
          [
            [[49, 1], [107, 1]],
            [[54, 2], [52, 3], [0, 1]],
            [[0, 2]],
            [[49, 4], [107, 4], [0, 3]],
            [[52, 3], [0, 4]]
          ],
          [[[49, 1], [107, 1]], [[52, 2], [0, 1]], [[49, 1], [107, 1], [0, 2]]],
          [[[25, 1]], [[48, 2], [0, 1]], [[49, 3]], [[0, 3]]],
          [
            [[35, 1], [110, 2], [38, 3]],
            [[61, 4], [81, 5]],
            [[25, 4]],
            [[166, 6]],
            [[0, 4]],
            [[61, 4]],
            [[64, 4]]
          ],
          [
            [[20, 1]],
            [[48, 2]],
            [[80, 3]],
            [[167, 4], [168, 5]],
            [[48, 6]],
            [[48, 7]],
            [[80, 8]],
            [[80, 9]],
            [[167, 4], [127, 10], [168, 5], [0, 8]],
            [[0, 9]],
            [[48, 11]],
            [[80, 12]],
            [[168, 5], [0, 12]]
          ],
          [
            [[15, 1], [169, 2], [53, 3]],
            [[169, 4], [52, 5], [0, 1]],
            [[50, 6], [52, 7], [0, 2]],
            [[169, 8]],
            [[52, 5], [0, 4]],
            [[169, 9], [53, 3], [0, 5]],
            [[49, 10]],
            [[15, 11], [169, 2], [53, 3], [0, 7]],
            [[52, 12], [0, 8]],
            [[50, 13], [52, 5], [0, 9]],
            [[52, 7], [0, 10]],
            [[169, 14], [52, 15], [0, 11]],
            [[0, 12]],
            [[49, 4]],
            [[52, 15], [0, 14]],
            [[169, 16], [53, 3], [0, 15]],
            [[50, 17], [52, 15], [0, 16]],
            [[49, 14]]
          ],
          [
            [[15, 1], [53, 2], [170, 3]],
            [[170, 5], [52, 4], [0, 1]],
            [[170, 6]],
            [[50, 7], [52, 8], [0, 3]],
            [[53, 2], [170, 9], [0, 4]],
            [[52, 4], [0, 5]],
            [[52, 10], [0, 6]],
            [[49, 11]],
            [[15, 12], [53, 2], [170, 3], [0, 8]],
            [[50, 13], [52, 4], [0, 9]],
            [[0, 10]],
            [[52, 8], [0, 11]],
            [[52, 15], [170, 14], [0, 12]],
            [[49, 5]],
            [[52, 15], [0, 14]],
            [[53, 2], [170, 16], [0, 15]],
            [[50, 17], [52, 15], [0, 16]],
            [[49, 14]]
          ],
          [[[25, 1]], [[0, 1]]],
          [
            [[21, 1]],
            [[49, 2]],
            [[48, 3]],
            [[80, 4]],
            [[127, 5], [0, 4]],
            [[48, 6]],
            [[80, 7]],
            [[0, 7]]
          ],
          [[[49, 1]], [[108, 2], [0, 1]], [[95, 3]], [[0, 3]]],
          [[[42, 1]], [[171, 2]], [[48, 3], [52, 1]], [[80, 4]], [[0, 4]]],
          [[[172, 1]], [[173, 0], [0, 1]]],
          [[[111, 2], [36, 1]], [[49, 2]], [[0, 2]]],
          [[[31, 1]], [[174, 2], [0, 1]], [[0, 2]]],
          [[[62, 1]], [[0, 1]]]
        ],
        labels: [
          [0, "EMPTY"],
          [317, null],
          [4, null],
          [276, null],
          [1, "def"],
          [1, "raise"],
          [1, "True"],
          [3, null],
          [1, "not"],
          [1, "null"],
          [55, null],
          [2, null],
          [25, null],
          [1, "class"],
          [1, "lambda"],
          [16, null],
          [1, "print"],
          [1, "debugger"],
          [1, "nonlocal"],
          [52, null],
          [1, "try"],
          [1, "while"],
          [31, null],
          [1, "return"],
          [1, "assert"],
          [1, null],
          [1, "global"],
          [1, "del"],
          [1, "pass"],
          [54, null],
          [15, null],
          [1, "yield"],
          [1, "import"],
          [1, "False"],
          [1, "for"],
          [7, null],
          [1, "from"],
          [1, "if"],
          [9, null],
          [1, "break"],
          [1, "continue"],
          [49, null],
          [1, "with"],
          [14, null],
          [316, null],
          [19, null],
          [308, null],
          [1, "and"],
          [11, null],
          [326, null],
          [22, null],
          [261, null],
          [12, null],
          [35, null],
          [271, null],
          [325, null],
          [297, null],
          [339, null],
          [296, null],
          [26, null],
          [283, null],
          [8, null],
          [342, null],
          [329, null],
          [10, null],
          [266, null],
          [332, null],
          [45, null],
          [38, null],
          [40, null],
          [50, null],
          [46, null],
          [41, null],
          [42, null],
          [36, null],
          [43, null],
          [48, null],
          [44, null],
          [37, null],
          [39, null],
          [324, null],
          [260, null],
          [292, null],
          [1, "in"],
          [309, null],
          [273, null],
          [327, null],
          [272, null],
          [28, null],
          [21, null],
          [27, null],
          [29, null],
          [1, "is"],
          [30, null],
          [20, null],
          [290, null],
          [274, null],
          [333, null],
          [299, null],
          [270, null],
          [337, null],
          [279, null],
          [265, null],
          [281, null],
          [264, null],
          [286, null],
          [280, null],
          [320, null],
          [1, "as"],
          [284, null],
          [23, null],
          [328, null],
          [0, null],
          [1, "except"],
          [340, null],
          [18, null],
          [330, null],
          [268, null],
          [259, null],
          [312, null],
          [293, null],
          [321, null],
          [269, null],
          [277, null],
          [314, null],
          [315, null],
          [343, null],
          [1, "else"],
          [310, null],
          [51, null],
          [1, "elif"],
          [300, null],
          [301, null],
          [285, null],
          [303, null],
          [302, null],
          [335, null],
          [275, null],
          [258, null],
          [1, "or"],
          [334, null],
          [267, null],
          [34, null],
          [262, null],
          [33, null],
          [319, null],
          [13, null],
          [295, null],
          [263, null],
          [291, null],
          [311, null],
          [307, null],
          [313, null],
          [282, null],
          [298, null],
          [304, null],
          [278, null],
          [318, null],
          [322, null],
          [5, null],
          [6, null],
          [47, null],
          [17, null],
          [24, null],
          [305, null],
          [306, null],
          [323, null],
          [289, null],
          [1, "finally"],
          [331, null],
          [336, null],
          [338, null],
          [257, null],
          [32, null],
          [341, null]
        ],
        keywords: {
          "False": 33,
          "null": 9,
          "True": 6,
          "and": 47,
          "as": 108,
          "assert": 24,
          "break": 39,
          "class": 13,
          "continue": 40,
          "debugger": 17,
          "def": 4,
          "del": 27,
          "elif": 130,
          "else": 127,
          "except": 113,
          "finally": 168,
          "for": 34,
          "from": 36,
          "global": 26,
          "if": 37,
          "import": 32,
          "in": 83,
          "is": 92,
          "lambda": 14,
          "nonlocal": 18,
          "not": 8,
          "or": 139,
          "pass": 28,
          "print": 16,
          "raise": 5,
          "return": 23,
          "try": 20,
          "while": 21,
          "with": 42,
          "yield": 31
        },
        tokens: {
          0: 112,
          1: 25,
          2: 11,
          3: 7,
          4: 2,
          5: 159,
          6: 160,
          7: 35,
          8: 61,
          9: 38,
          10: 64,
          11: 48,
          12: 52,
          13: 146,
          14: 43,
          15: 30,
          16: 15,
          17: 162,
          18: 115,
          19: 45,
          20: 94,
          21: 89,
          22: 50,
          23: 110,
          24: 163,
          25: 12,
          26: 59,
          27: 90,
          28: 88,
          29: 91,
          30: 93,
          31: 22,
          32: 173,
          33: 144,
          34: 142,
          35: 53,
          36: 74,
          37: 78,
          38: 68,
          39: 79,
          40: 69,
          41: 72,
          42: 73,
          43: 75,
          44: 77,
          45: 67,
          46: 71,
          47: 161,
          48: 76,
          49: 41,
          50: 70,
          51: 129,
          52: 19,
          54: 29,
          55: 10
        },
        start: 256
      };
    }
  });

  // src/parser.js
  var require_parser = __commonJS({
    "src/parser.js"() {
      function Parser(filename, grammar) {
        this.filename = filename;
        this.grammar = grammar;
        this.comments = {};
        this.p_flags = 0;
        return this;
      }
      Parser.FUTURE_PRINT_FUNCTION = "print_function";
      Parser.FUTURE_UNICODE_LITERALS = "unicode_literals";
      Parser.FUTURE_DIVISION = "division";
      Parser.FUTURE_ABSOLUTE_IMPORT = "absolute_import";
      Parser.FUTURE_WITH_STATEMENT = "with_statement";
      Parser.FUTURE_NESTED_SCOPES = "nested_scopes";
      Parser.FUTURE_GENERATORS = "generators";
      Parser.CO_FUTURE_PRINT_FUNCTION = 65536;
      Parser.CO_FUTURE_UNICODE_LITERALS = 131072;
      Parser.CO_FUTURE_DIVISON = 8192;
      Parser.CO_FUTURE_ABSOLUTE_IMPORT = 16384;
      Parser.CO_FUTURE_WITH_STATEMENT = 32768;
      Parser.prototype.setup = function(start) {
        var stackentry;
        var newnode;
        start = start || this.grammar.start;
        newnode = {
          type: start,
          value: null,
          context: null,
          children: []
        };
        stackentry = {
          dfa: this.grammar.dfas[start],
          state: 0,
          node: newnode
        };
        this.stack = [stackentry];
        this.used_names = {};
        Sk._setupTokenRegexes();
      };
      function findInDfa(a, obj) {
        var i = a.length;
        while (i--) {
          if (a[i][0] === obj[0] && a[i][1] === obj[1]) {
            return true;
          }
        }
        return false;
      }
      Parser.prototype.addcomment = function(value, start, end, line) {
        this.comments[start] = value;
      };
      Parser.prototype.addtoken = function(type, value, context) {
        var errline;
        var itsfirst;
        var itsdfa;
        var state;
        var v;
        var t;
        var newstate;
        var i;
        var a;
        var arcs;
        var first;
        var states;
        var tp;
        var ilabel = this.classify(type, value, context);
        OUTERWHILE: while (true) {
          tp = this.stack[this.stack.length - 1];
          states = tp.dfa[0];
          first = tp.dfa[1];
          arcs = states[tp.state];
          for (a = 0; a < arcs.length; ++a) {
            i = arcs[a][0];
            newstate = arcs[a][1];
            t = this.grammar.labels[i][0];
            v = this.grammar.labels[i][1];
            if (ilabel === i) {
              Sk.asserts.assert(t < 256);
              this.shift(type, value, newstate, context);
              state = newstate;
              while (states[state].length === 1 && states[state][0][0] === 0 && states[state][0][1] === state) {
                this.pop();
                if (this.stack.length === 0) {
                  return true;
                }
                tp = this.stack[this.stack.length - 1];
                state = tp.state;
                states = tp.dfa[0];
                first = tp.dfa[1];
              }
              return false;
            } else if (t >= 256) {
              itsdfa = this.grammar.dfas[t];
              itsfirst = itsdfa[1];
              if (itsfirst.hasOwnProperty(ilabel)) {
                this.push(t, this.grammar.dfas[t], newstate, context);
                continue OUTERWHILE;
              }
            }
          }
          if (findInDfa(arcs, [0, tp.state])) {
            this.pop();
            if (this.stack.length === 0) {
              throw new Sk.builtin.SyntaxError(
                "too much input",
                this.filename,
                ...flatten_context(context)
              );
            }
          } else {
            throw new Sk.builtin.SyntaxError(
              "bad input",
              this.filename,
              ...flatten_context(context)
            );
          }
        }
      };
      function flatten_context(context) {
        return [context[2], context[0][0], context[0][1], context[1][0], context[1][1]];
      }
      Parser.prototype.classify = function(type, value, context) {
        var ilabel;
        if (type === Sk.token.tokens.T_NAME) {
          this.used_names[value] = true;
          ilabel = this.grammar.keywords.hasOwnProperty(value) && this.grammar.keywords[value];
          if (value === "print" && (this.p_flags & Parser.CO_FUTURE_PRINT_FUNCTION || Sk.__future__.print_function === true)) {
            ilabel = false;
          }
          if (ilabel) {
            return ilabel;
          }
        }
        ilabel = this.grammar.tokens.hasOwnProperty(type) && this.grammar.tokens[type];
        if (!ilabel) {
          let descr = "#" + type;
          for (let i in Sk.token.tokens) {
            if (Sk.token.tokens[i] == type) {
              descr = i;
              break;
            }
          }
          throw new Sk.builtin.SyntaxError(
            "bad token " + descr,
            this.filename,
            ...flatten_context(context)
          );
        }
        return ilabel;
      };
      Parser.prototype.shift = function(type, value, newstate, context) {
        var dfa = this.stack[this.stack.length - 1].dfa;
        var state = this.stack[this.stack.length - 1].state;
        var node = this.stack[this.stack.length - 1].node;
        var newnode = {
          type,
          value,
          lineno: context[0][0],
          col_offset: context[0][1],
          end_lineno: context[1][0],
          end_col_offset: context[1][1],
          children: null
        };
        if (newnode) {
          node.children.push(newnode);
        }
        this.stack[this.stack.length - 1] = {
          dfa,
          state: newstate,
          node
        };
      };
      Parser.prototype.push = function(type, newdfa, newstate, context) {
        var dfa = this.stack[this.stack.length - 1].dfa;
        var node = this.stack[this.stack.length - 1].node;
        var newnode = {
          type,
          value: null,
          lineno: context[0][0],
          col_offset: context[0][1],
          end_lineno: context[1][0],
          end_col_offset: context[1][1],
          children: []
        };
        this.stack[this.stack.length - 1] = {
          dfa,
          state: newstate,
          node
        };
        this.stack.push({
          dfa: newdfa,
          state: 0,
          node: newnode
        });
      };
      Parser.prototype.pop = function() {
        var node;
        var pop = this.stack.pop();
        var newnode = pop.node;
        if (newnode) {
          if (this.stack.length !== 0) {
            node = this.stack[this.stack.length - 1].node;
            node.children.push(newnode);
          } else {
            this.rootnode = newnode;
            this.rootnode.used_names = this.used_names;
          }
        }
      };
      function makeParser(filename, style) {
        if (style === void 0) {
          style = "file_input";
        }
        var p = new Parser(filename, Sk.ParseTables);
        if (style === "file_input") {
          p.setup(Sk.ParseTables.sym.file_input);
        } else {
          Sk.asserts.fail("todo;");
        }
        return p;
      }
      Sk.parse = function parse(filename, input) {
        var T_COMMENT = Sk.token.tokens.T_COMMENT;
        var T_NL = Sk.token.tokens.T_NL;
        var T_OP = Sk.token.tokens.T_OP;
        var T_ENDMARKER = Sk.token.tokens.T_ENDMARKER;
        var T_ENCODING = Sk.token.tokens.T_ENCODING;
        var endmarker_seen = false;
        var parser = makeParser(filename);
        var totalLines = 0;
        function readline(input2) {
          let lines = input2.split("\n");
          Sk.parse.linecache[filename] = lines.slice();
          lines = lines.reverse();
          totalLines = lines.length;
          return function() {
            if (lines.length === 0) {
              throw new Sk.builtin.Exception("EOF");
            }
            return lines.pop() + "\n";
          };
        }
        Sk._tokenize(
          readline(input),
          "utf-8",
          function(tokenInfo) {
            var s_lineno = tokenInfo.start[0];
            var s_column = tokenInfo.start[1];
            var type = null;
            var prefix, lineno, column;
            if (tokenInfo.type === T_COMMENT || tokenInfo.type === T_NL || tokenInfo.type === T_ENCODING) {
              prefix += tokenInfo.value;
              lineno = tokenInfo.end[0];
              column = tokenInfo.end[1];
              if (tokenInfo.string[tokenInfo.string.length - 1] === "\n") {
                lineno += 1;
                column = 0;
              }
              if (tokenInfo.type === T_COMMENT) {
                parser.addcomment(
                  tokenInfo.string,
                  tokenInfo.start,
                  tokenInfo.end,
                  tokenInfo.line
                );
              }
            } else {
              if (tokenInfo.type === T_OP) {
                type = Sk.OpMap[tokenInfo.string];
              }
              parser.addtoken(type || tokenInfo.type, tokenInfo.string, [
                tokenInfo.start,
                tokenInfo.end,
                tokenInfo.line
              ]);
              if (tokenInfo.type === T_ENDMARKER) {
                endmarker_seen = true;
              }
            }
          },
          filename
        );
        if (!endmarker_seen) {
          throw new Sk.builtin.SyntaxError(
            "incomplete input",
            this.filename,
            "",
            0,
            0,
            totalLines,
            0
          );
        }
        var result = { cst: parser.rootnode, flags: parser.p_flags, comments: parser.comments };
        return result;
      };
      Sk.parse.linecache = {};
      Sk.parseTreeDump = function parseTreeDump(n, indent) {
        var i;
        var ret;
        indent = indent || "";
        ret = "";
        ret += indent;
        if (n.type >= 256) {
          ret += Sk.ParseTables.number2symbol[n.type] + "\n";
          for (i = 0; i < n.children.length; ++i) {
            ret += Sk.parseTreeDump(n.children[i], indent + "  ");
          }
        } else {
          ret += Sk.token.tok_name[n.type] + ": " + new Sk.builtin.str(n.value)["$r"]().v + "\n";
        }
        return ret;
      };
      Sk.exportSymbol("Sk.Parser", Parser);
      Sk.exportSymbol("Sk.parse", Sk.parse);
      Sk.exportSymbol("Sk.parseTreeDump", Sk.parseTreeDump);
      Sk.exportSymbol("Sk.parse.linecache", Sk.parse.linecache);
    }
  });

  // gen/astnodes.js
  var require_astnodes = __commonJS({
    "gen/astnodes.js"() {
      Sk.astnodes = {};
      Sk.astnodes.Load = function Load() {
      };
      Sk.astnodes.Store = function Store() {
      };
      Sk.astnodes.Del = function Del() {
      };
      Sk.astnodes.AugLoad = function AugLoad() {
      };
      Sk.astnodes.AugStore = function AugStore() {
      };
      Sk.astnodes.Param = function Param() {
      };
      Sk.astnodes.And = function And() {
      };
      Sk.astnodes.Or = function Or() {
      };
      Sk.astnodes.Add = function Add() {
      };
      Sk.astnodes.Sub = function Sub() {
      };
      Sk.astnodes.Mult = function Mult() {
      };
      Sk.astnodes.MatMult = function MatMult() {
      };
      Sk.astnodes.Div = function Div() {
      };
      Sk.astnodes.Mod = function Mod() {
      };
      Sk.astnodes.Pow = function Pow() {
      };
      Sk.astnodes.LShift = function LShift() {
      };
      Sk.astnodes.RShift = function RShift() {
      };
      Sk.astnodes.BitOr = function BitOr() {
      };
      Sk.astnodes.BitXor = function BitXor() {
      };
      Sk.astnodes.BitAnd = function BitAnd() {
      };
      Sk.astnodes.FloorDiv = function FloorDiv() {
      };
      Sk.astnodes.Invert = function Invert() {
      };
      Sk.astnodes.Not = function Not() {
      };
      Sk.astnodes.UAdd = function UAdd() {
      };
      Sk.astnodes.USub = function USub() {
      };
      Sk.astnodes.Eq = function Eq() {
      };
      Sk.astnodes.NotEq = function NotEq() {
      };
      Sk.astnodes.Lt = function Lt2() {
      };
      Sk.astnodes.LtE = function LtE() {
      };
      Sk.astnodes.Gt = function Gt() {
      };
      Sk.astnodes.GtE = function GtE() {
      };
      Sk.astnodes.Is = function Is() {
      };
      Sk.astnodes.IsNot = function IsNot() {
      };
      Sk.astnodes.In = function In() {
      };
      Sk.astnodes.NotIn = function NotIn() {
      };
      Sk.astnodes.Module = function Module(body, docstring) {
        this.body = body;
        this.docstring = docstring;
        return this;
      };
      Sk.astnodes.Interactive = function Interactive(body) {
        this.body = body;
        return this;
      };
      Sk.astnodes.Expression = function Expression(body) {
        this.body = body;
        return this;
      };
      Sk.astnodes.Suite = function Suite(body) {
        this.body = body;
        return this;
      };
      Sk.astnodes.FunctionDef = function FunctionDef(name, args, body, decorator_list, returns, docstring, lineno, col_offset, end_lineno, end_col_offset) {
        Sk.asserts.assert(lineno !== null && lineno !== void 0);
        Sk.asserts.assert(col_offset !== null && col_offset !== void 0);
        Sk.asserts.assert(end_lineno !== null && end_lineno !== void 0);
        Sk.asserts.assert(end_col_offset !== null && end_col_offset !== void 0);
        this.name = name;
        this.args = args;
        this.body = body;
        this.decorator_list = decorator_list;
        this.returns = returns;
        this.docstring = docstring;
        this.lineno = lineno;
        this.col_offset = col_offset;
        this.end_lineno = end_lineno;
        this.end_col_offset = end_col_offset;
        return this;
      };
      Sk.astnodes.AsyncFunctionDef = function AsyncFunctionDef(name, args, body, decorator_list, returns, docstring, lineno, col_offset, end_lineno, end_col_offset) {
        Sk.asserts.assert(lineno !== null && lineno !== void 0);
        Sk.asserts.assert(col_offset !== null && col_offset !== void 0);
        Sk.asserts.assert(end_lineno !== null && end_lineno !== void 0);
        Sk.asserts.assert(end_col_offset !== null && end_col_offset !== void 0);
        this.name = name;
        this.args = args;
        this.body = body;
        this.decorator_list = decorator_list;
        this.returns = returns;
        this.docstring = docstring;
        this.lineno = lineno;
        this.col_offset = col_offset;
        this.end_lineno = end_lineno;
        this.end_col_offset = end_col_offset;
        return this;
      };
      Sk.astnodes.ClassDef = function ClassDef(name, bases, keywords, body, decorator_list, docstring, lineno, col_offset, end_lineno, end_col_offset) {
        Sk.asserts.assert(lineno !== null && lineno !== void 0);
        Sk.asserts.assert(col_offset !== null && col_offset !== void 0);
        Sk.asserts.assert(end_lineno !== null && end_lineno !== void 0);
        Sk.asserts.assert(end_col_offset !== null && end_col_offset !== void 0);
        this.name = name;
        this.bases = bases;
        this.keywords = keywords;
        this.body = body;
        this.decorator_list = decorator_list;
        this.docstring = docstring;
        this.lineno = lineno;
        this.col_offset = col_offset;
        this.end_lineno = end_lineno;
        this.end_col_offset = end_col_offset;
        return this;
      };
      Sk.astnodes.Return = function Return(value, lineno, col_offset, end_lineno, end_col_offset) {
        Sk.asserts.assert(lineno !== null && lineno !== void 0);
        Sk.asserts.assert(col_offset !== null && col_offset !== void 0);
        Sk.asserts.assert(end_lineno !== null && end_lineno !== void 0);
        Sk.asserts.assert(end_col_offset !== null && end_col_offset !== void 0);
        this.value = value;
        this.lineno = lineno;
        this.col_offset = col_offset;
        this.end_lineno = end_lineno;
        this.end_col_offset = end_col_offset;
        return this;
      };
      Sk.astnodes.Delete = function Delete(targets, lineno, col_offset, end_lineno, end_col_offset) {
        Sk.asserts.assert(lineno !== null && lineno !== void 0);
        Sk.asserts.assert(col_offset !== null && col_offset !== void 0);
        Sk.asserts.assert(end_lineno !== null && end_lineno !== void 0);
        Sk.asserts.assert(end_col_offset !== null && end_col_offset !== void 0);
        this.targets = targets;
        this.lineno = lineno;
        this.col_offset = col_offset;
        this.end_lineno = end_lineno;
        this.end_col_offset = end_col_offset;
        return this;
      };
      Sk.astnodes.Assign = function Assign(targets, value, lineno, col_offset, end_lineno, end_col_offset) {
        Sk.asserts.assert(lineno !== null && lineno !== void 0);
        Sk.asserts.assert(col_offset !== null && col_offset !== void 0);
        Sk.asserts.assert(end_lineno !== null && end_lineno !== void 0);
        Sk.asserts.assert(end_col_offset !== null && end_col_offset !== void 0);
        this.targets = targets;
        this.value = value;
        this.lineno = lineno;
        this.col_offset = col_offset;
        this.end_lineno = end_lineno;
        this.end_col_offset = end_col_offset;
        return this;
      };
      Sk.astnodes.AugAssign = function AugAssign(target, op, value, lineno, col_offset, end_lineno, end_col_offset) {
        Sk.asserts.assert(lineno !== null && lineno !== void 0);
        Sk.asserts.assert(col_offset !== null && col_offset !== void 0);
        Sk.asserts.assert(end_lineno !== null && end_lineno !== void 0);
        Sk.asserts.assert(end_col_offset !== null && end_col_offset !== void 0);
        this.target = target;
        this.op = op;
        this.value = value;
        this.lineno = lineno;
        this.col_offset = col_offset;
        this.end_lineno = end_lineno;
        this.end_col_offset = end_col_offset;
        return this;
      };
      Sk.astnodes.AnnAssign = function AnnAssign(target, annotation, value, simple, lineno, col_offset, end_lineno, end_col_offset) {
        Sk.asserts.assert(lineno !== null && lineno !== void 0);
        Sk.asserts.assert(col_offset !== null && col_offset !== void 0);
        Sk.asserts.assert(end_lineno !== null && end_lineno !== void 0);
        Sk.asserts.assert(end_col_offset !== null && end_col_offset !== void 0);
        this.target = target;
        this.annotation = annotation;
        this.value = value;
        this.simple = simple;
        this.lineno = lineno;
        this.col_offset = col_offset;
        this.end_lineno = end_lineno;
        this.end_col_offset = end_col_offset;
        return this;
      };
      Sk.astnodes.For = function For(target, iter, body, orelse, lineno, col_offset, end_lineno, end_col_offset) {
        Sk.asserts.assert(lineno !== null && lineno !== void 0);
        Sk.asserts.assert(col_offset !== null && col_offset !== void 0);
        Sk.asserts.assert(end_lineno !== null && end_lineno !== void 0);
        Sk.asserts.assert(end_col_offset !== null && end_col_offset !== void 0);
        this.target = target;
        this.iter = iter;
        this.body = body;
        this.orelse = orelse;
        this.lineno = lineno;
        this.col_offset = col_offset;
        this.end_lineno = end_lineno;
        this.end_col_offset = end_col_offset;
        return this;
      };
      Sk.astnodes.AsyncFor = function AsyncFor(target, iter, body, orelse, lineno, col_offset, end_lineno, end_col_offset) {
        Sk.asserts.assert(lineno !== null && lineno !== void 0);
        Sk.asserts.assert(col_offset !== null && col_offset !== void 0);
        Sk.asserts.assert(end_lineno !== null && end_lineno !== void 0);
        Sk.asserts.assert(end_col_offset !== null && end_col_offset !== void 0);
        this.target = target;
        this.iter = iter;
        this.body = body;
        this.orelse = orelse;
        this.lineno = lineno;
        this.col_offset = col_offset;
        this.end_lineno = end_lineno;
        this.end_col_offset = end_col_offset;
        return this;
      };
      Sk.astnodes.While = function While(test, body, orelse, lineno, col_offset, end_lineno, end_col_offset) {
        Sk.asserts.assert(lineno !== null && lineno !== void 0);
        Sk.asserts.assert(col_offset !== null && col_offset !== void 0);
        Sk.asserts.assert(end_lineno !== null && end_lineno !== void 0);
        Sk.asserts.assert(end_col_offset !== null && end_col_offset !== void 0);
        this.test = test;
        this.body = body;
        this.orelse = orelse;
        this.lineno = lineno;
        this.col_offset = col_offset;
        this.end_lineno = end_lineno;
        this.end_col_offset = end_col_offset;
        return this;
      };
      Sk.astnodes.If = function If(test, body, orelse, lineno, col_offset, end_lineno, end_col_offset) {
        Sk.asserts.assert(lineno !== null && lineno !== void 0);
        Sk.asserts.assert(col_offset !== null && col_offset !== void 0);
        Sk.asserts.assert(end_lineno !== null && end_lineno !== void 0);
        Sk.asserts.assert(end_col_offset !== null && end_col_offset !== void 0);
        this.test = test;
        this.body = body;
        this.orelse = orelse;
        this.lineno = lineno;
        this.col_offset = col_offset;
        this.end_lineno = end_lineno;
        this.end_col_offset = end_col_offset;
        return this;
      };
      Sk.astnodes.With = function With(items, body, lineno, col_offset, end_lineno, end_col_offset) {
        Sk.asserts.assert(lineno !== null && lineno !== void 0);
        Sk.asserts.assert(col_offset !== null && col_offset !== void 0);
        Sk.asserts.assert(end_lineno !== null && end_lineno !== void 0);
        Sk.asserts.assert(end_col_offset !== null && end_col_offset !== void 0);
        this.items = items;
        this.body = body;
        this.lineno = lineno;
        this.col_offset = col_offset;
        this.end_lineno = end_lineno;
        this.end_col_offset = end_col_offset;
        return this;
      };
      Sk.astnodes.AsyncWith = function AsyncWith(items, body, lineno, col_offset, end_lineno, end_col_offset) {
        Sk.asserts.assert(lineno !== null && lineno !== void 0);
        Sk.asserts.assert(col_offset !== null && col_offset !== void 0);
        Sk.asserts.assert(end_lineno !== null && end_lineno !== void 0);
        Sk.asserts.assert(end_col_offset !== null && end_col_offset !== void 0);
        this.items = items;
        this.body = body;
        this.lineno = lineno;
        this.col_offset = col_offset;
        this.end_lineno = end_lineno;
        this.end_col_offset = end_col_offset;
        return this;
      };
      Sk.astnodes.Raise = function Raise(exc, cause, inst, tback, lineno, col_offset, end_lineno, end_col_offset) {
        Sk.asserts.assert(lineno !== null && lineno !== void 0);
        Sk.asserts.assert(col_offset !== null && col_offset !== void 0);
        Sk.asserts.assert(end_lineno !== null && end_lineno !== void 0);
        Sk.asserts.assert(end_col_offset !== null && end_col_offset !== void 0);
        this.exc = exc;
        this.cause = cause;
        this.inst = inst;
        this.tback = tback;
        this.lineno = lineno;
        this.col_offset = col_offset;
        this.end_lineno = end_lineno;
        this.end_col_offset = end_col_offset;
        return this;
      };
      Sk.astnodes.Try = function Try(body, handlers, orelse, finalbody, lineno, col_offset, end_lineno, end_col_offset) {
        Sk.asserts.assert(lineno !== null && lineno !== void 0);
        Sk.asserts.assert(col_offset !== null && col_offset !== void 0);
        Sk.asserts.assert(end_lineno !== null && end_lineno !== void 0);
        Sk.asserts.assert(end_col_offset !== null && end_col_offset !== void 0);
        this.body = body;
        this.handlers = handlers;
        this.orelse = orelse;
        this.finalbody = finalbody;
        this.lineno = lineno;
        this.col_offset = col_offset;
        this.end_lineno = end_lineno;
        this.end_col_offset = end_col_offset;
        return this;
      };
      Sk.astnodes.Assert = function Assert(test, msg, lineno, col_offset, end_lineno, end_col_offset) {
        Sk.asserts.assert(lineno !== null && lineno !== void 0);
        Sk.asserts.assert(col_offset !== null && col_offset !== void 0);
        Sk.asserts.assert(end_lineno !== null && end_lineno !== void 0);
        Sk.asserts.assert(end_col_offset !== null && end_col_offset !== void 0);
        this.test = test;
        this.msg = msg;
        this.lineno = lineno;
        this.col_offset = col_offset;
        this.end_lineno = end_lineno;
        this.end_col_offset = end_col_offset;
        return this;
      };
      Sk.astnodes.Import = function Import(names, lineno, col_offset, end_lineno, end_col_offset) {
        Sk.asserts.assert(lineno !== null && lineno !== void 0);
        Sk.asserts.assert(col_offset !== null && col_offset !== void 0);
        Sk.asserts.assert(end_lineno !== null && end_lineno !== void 0);
        Sk.asserts.assert(end_col_offset !== null && end_col_offset !== void 0);
        this.names = names;
        this.lineno = lineno;
        this.col_offset = col_offset;
        this.end_lineno = end_lineno;
        this.end_col_offset = end_col_offset;
        return this;
      };
      Sk.astnodes.ImportFrom = function ImportFrom(module2, names, level, lineno, col_offset, end_lineno, end_col_offset) {
        Sk.asserts.assert(lineno !== null && lineno !== void 0);
        Sk.asserts.assert(col_offset !== null && col_offset !== void 0);
        Sk.asserts.assert(end_lineno !== null && end_lineno !== void 0);
        Sk.asserts.assert(end_col_offset !== null && end_col_offset !== void 0);
        this.module = module2;
        this.names = names;
        this.level = level;
        this.lineno = lineno;
        this.col_offset = col_offset;
        this.end_lineno = end_lineno;
        this.end_col_offset = end_col_offset;
        return this;
      };
      Sk.astnodes.Global = function Global(names, lineno, col_offset, end_lineno, end_col_offset) {
        Sk.asserts.assert(lineno !== null && lineno !== void 0);
        Sk.asserts.assert(col_offset !== null && col_offset !== void 0);
        Sk.asserts.assert(end_lineno !== null && end_lineno !== void 0);
        Sk.asserts.assert(end_col_offset !== null && end_col_offset !== void 0);
        this.names = names;
        this.lineno = lineno;
        this.col_offset = col_offset;
        this.end_lineno = end_lineno;
        this.end_col_offset = end_col_offset;
        return this;
      };
      Sk.astnodes.Nonlocal = function Nonlocal(names, lineno, col_offset, end_lineno, end_col_offset) {
        Sk.asserts.assert(lineno !== null && lineno !== void 0);
        Sk.asserts.assert(col_offset !== null && col_offset !== void 0);
        Sk.asserts.assert(end_lineno !== null && end_lineno !== void 0);
        Sk.asserts.assert(end_col_offset !== null && end_col_offset !== void 0);
        this.names = names;
        this.lineno = lineno;
        this.col_offset = col_offset;
        this.end_lineno = end_lineno;
        this.end_col_offset = end_col_offset;
        return this;
      };
      Sk.astnodes.Expr = function Expr(value, lineno, col_offset, end_lineno, end_col_offset) {
        Sk.asserts.assert(lineno !== null && lineno !== void 0);
        Sk.asserts.assert(col_offset !== null && col_offset !== void 0);
        Sk.asserts.assert(end_lineno !== null && end_lineno !== void 0);
        Sk.asserts.assert(end_col_offset !== null && end_col_offset !== void 0);
        this.value = value;
        this.lineno = lineno;
        this.col_offset = col_offset;
        this.end_lineno = end_lineno;
        this.end_col_offset = end_col_offset;
        return this;
      };
      Sk.astnodes.Pass = function Pass(lineno, col_offset, end_lineno, end_col_offset) {
        Sk.asserts.assert(lineno !== null && lineno !== void 0);
        Sk.asserts.assert(col_offset !== null && col_offset !== void 0);
        Sk.asserts.assert(end_lineno !== null && end_lineno !== void 0);
        Sk.asserts.assert(end_col_offset !== null && end_col_offset !== void 0);
        this.lineno = lineno;
        this.col_offset = col_offset;
        this.end_lineno = end_lineno;
        this.end_col_offset = end_col_offset;
        return this;
      };
      Sk.astnodes.Break = function Break(lineno, col_offset, end_lineno, end_col_offset) {
        Sk.asserts.assert(lineno !== null && lineno !== void 0);
        Sk.asserts.assert(col_offset !== null && col_offset !== void 0);
        Sk.asserts.assert(end_lineno !== null && end_lineno !== void 0);
        Sk.asserts.assert(end_col_offset !== null && end_col_offset !== void 0);
        this.lineno = lineno;
        this.col_offset = col_offset;
        this.end_lineno = end_lineno;
        this.end_col_offset = end_col_offset;
        return this;
      };
      Sk.astnodes.Continue = function Continue(lineno, col_offset, end_lineno, end_col_offset) {
        Sk.asserts.assert(lineno !== null && lineno !== void 0);
        Sk.asserts.assert(col_offset !== null && col_offset !== void 0);
        Sk.asserts.assert(end_lineno !== null && end_lineno !== void 0);
        Sk.asserts.assert(end_col_offset !== null && end_col_offset !== void 0);
        this.lineno = lineno;
        this.col_offset = col_offset;
        this.end_lineno = end_lineno;
        this.end_col_offset = end_col_offset;
        return this;
      };
      Sk.astnodes.Print = function Print(dest, values, nl, lineno, col_offset, end_lineno, end_col_offset) {
        Sk.asserts.assert(lineno !== null && lineno !== void 0);
        Sk.asserts.assert(col_offset !== null && col_offset !== void 0);
        Sk.asserts.assert(end_lineno !== null && end_lineno !== void 0);
        Sk.asserts.assert(end_col_offset !== null && end_col_offset !== void 0);
        this.dest = dest;
        this.values = values;
        this.nl = nl;
        this.lineno = lineno;
        this.col_offset = col_offset;
        this.end_lineno = end_lineno;
        this.end_col_offset = end_col_offset;
        return this;
      };
      Sk.astnodes.Debugger = function Debugger(lineno, col_offset, end_lineno, end_col_offset) {
        Sk.asserts.assert(lineno !== null && lineno !== void 0);
        Sk.asserts.assert(col_offset !== null && col_offset !== void 0);
        Sk.asserts.assert(end_lineno !== null && end_lineno !== void 0);
        Sk.asserts.assert(end_col_offset !== null && end_col_offset !== void 0);
        this.lineno = lineno;
        this.col_offset = col_offset;
        this.end_lineno = end_lineno;
        this.end_col_offset = end_col_offset;
        return this;
      };
      Sk.astnodes.BoolOp = function BoolOp(op, values, lineno, col_offset, end_lineno, end_col_offset) {
        Sk.asserts.assert(lineno !== null && lineno !== void 0);
        Sk.asserts.assert(col_offset !== null && col_offset !== void 0);
        Sk.asserts.assert(end_lineno !== null && end_lineno !== void 0);
        Sk.asserts.assert(end_col_offset !== null && end_col_offset !== void 0);
        this.op = op;
        this.values = values;
        this.lineno = lineno;
        this.col_offset = col_offset;
        this.end_lineno = end_lineno;
        this.end_col_offset = end_col_offset;
        return this;
      };
      Sk.astnodes.BinOp = function BinOp(left, op, right, lineno, col_offset, end_lineno, end_col_offset) {
        Sk.asserts.assert(lineno !== null && lineno !== void 0);
        Sk.asserts.assert(col_offset !== null && col_offset !== void 0);
        Sk.asserts.assert(end_lineno !== null && end_lineno !== void 0);
        Sk.asserts.assert(end_col_offset !== null && end_col_offset !== void 0);
        this.left = left;
        this.op = op;
        this.right = right;
        this.lineno = lineno;
        this.col_offset = col_offset;
        this.end_lineno = end_lineno;
        this.end_col_offset = end_col_offset;
        return this;
      };
      Sk.astnodes.UnaryOp = function UnaryOp(op, operand, lineno, col_offset, end_lineno, end_col_offset) {
        Sk.asserts.assert(lineno !== null && lineno !== void 0);
        Sk.asserts.assert(col_offset !== null && col_offset !== void 0);
        Sk.asserts.assert(end_lineno !== null && end_lineno !== void 0);
        Sk.asserts.assert(end_col_offset !== null && end_col_offset !== void 0);
        this.op = op;
        this.operand = operand;
        this.lineno = lineno;
        this.col_offset = col_offset;
        this.end_lineno = end_lineno;
        this.end_col_offset = end_col_offset;
        return this;
      };
      Sk.astnodes.Lambda = function Lambda(args, body, lineno, col_offset, end_lineno, end_col_offset) {
        Sk.asserts.assert(lineno !== null && lineno !== void 0);
        Sk.asserts.assert(col_offset !== null && col_offset !== void 0);
        Sk.asserts.assert(end_lineno !== null && end_lineno !== void 0);
        Sk.asserts.assert(end_col_offset !== null && end_col_offset !== void 0);
        this.args = args;
        this.body = body;
        this.lineno = lineno;
        this.col_offset = col_offset;
        this.end_lineno = end_lineno;
        this.end_col_offset = end_col_offset;
        return this;
      };
      Sk.astnodes.IfExp = function IfExp(test, body, orelse, lineno, col_offset, end_lineno, end_col_offset) {
        Sk.asserts.assert(lineno !== null && lineno !== void 0);
        Sk.asserts.assert(col_offset !== null && col_offset !== void 0);
        Sk.asserts.assert(end_lineno !== null && end_lineno !== void 0);
        Sk.asserts.assert(end_col_offset !== null && end_col_offset !== void 0);
        this.test = test;
        this.body = body;
        this.orelse = orelse;
        this.lineno = lineno;
        this.col_offset = col_offset;
        this.end_lineno = end_lineno;
        this.end_col_offset = end_col_offset;
        return this;
      };
      Sk.astnodes.Dict = function Dict(keys, values, lineno, col_offset, end_lineno, end_col_offset) {
        Sk.asserts.assert(lineno !== null && lineno !== void 0);
        Sk.asserts.assert(col_offset !== null && col_offset !== void 0);
        Sk.asserts.assert(end_lineno !== null && end_lineno !== void 0);
        Sk.asserts.assert(end_col_offset !== null && end_col_offset !== void 0);
        this.keys = keys;
        this.values = values;
        this.lineno = lineno;
        this.col_offset = col_offset;
        this.end_lineno = end_lineno;
        this.end_col_offset = end_col_offset;
        return this;
      };
      Sk.astnodes.Set = function Set2(elts, lineno, col_offset, end_lineno, end_col_offset) {
        Sk.asserts.assert(lineno !== null && lineno !== void 0);
        Sk.asserts.assert(col_offset !== null && col_offset !== void 0);
        Sk.asserts.assert(end_lineno !== null && end_lineno !== void 0);
        Sk.asserts.assert(end_col_offset !== null && end_col_offset !== void 0);
        this.elts = elts;
        this.lineno = lineno;
        this.col_offset = col_offset;
        this.end_lineno = end_lineno;
        this.end_col_offset = end_col_offset;
        return this;
      };
      Sk.astnodes.ListComp = function ListComp(elt, generators, lineno, col_offset, end_lineno, end_col_offset) {
        Sk.asserts.assert(lineno !== null && lineno !== void 0);
        Sk.asserts.assert(col_offset !== null && col_offset !== void 0);
        Sk.asserts.assert(end_lineno !== null && end_lineno !== void 0);
        Sk.asserts.assert(end_col_offset !== null && end_col_offset !== void 0);
        this.elt = elt;
        this.generators = generators;
        this.lineno = lineno;
        this.col_offset = col_offset;
        this.end_lineno = end_lineno;
        this.end_col_offset = end_col_offset;
        return this;
      };
      Sk.astnodes.SetComp = function SetComp(elt, generators, lineno, col_offset, end_lineno, end_col_offset) {
        Sk.asserts.assert(lineno !== null && lineno !== void 0);
        Sk.asserts.assert(col_offset !== null && col_offset !== void 0);
        Sk.asserts.assert(end_lineno !== null && end_lineno !== void 0);
        Sk.asserts.assert(end_col_offset !== null && end_col_offset !== void 0);
        this.elt = elt;
        this.generators = generators;
        this.lineno = lineno;
        this.col_offset = col_offset;
        this.end_lineno = end_lineno;
        this.end_col_offset = end_col_offset;
        return this;
      };
      Sk.astnodes.DictComp = function DictComp(key, value, generators, lineno, col_offset, end_lineno, end_col_offset) {
        Sk.asserts.assert(lineno !== null && lineno !== void 0);
        Sk.asserts.assert(col_offset !== null && col_offset !== void 0);
        Sk.asserts.assert(end_lineno !== null && end_lineno !== void 0);
        Sk.asserts.assert(end_col_offset !== null && end_col_offset !== void 0);
        this.key = key;
        this.value = value;
        this.generators = generators;
        this.lineno = lineno;
        this.col_offset = col_offset;
        this.end_lineno = end_lineno;
        this.end_col_offset = end_col_offset;
        return this;
      };
      Sk.astnodes.GeneratorExp = function GeneratorExp(elt, generators, lineno, col_offset, end_lineno, end_col_offset) {
        Sk.asserts.assert(lineno !== null && lineno !== void 0);
        Sk.asserts.assert(col_offset !== null && col_offset !== void 0);
        Sk.asserts.assert(end_lineno !== null && end_lineno !== void 0);
        Sk.asserts.assert(end_col_offset !== null && end_col_offset !== void 0);
        this.elt = elt;
        this.generators = generators;
        this.lineno = lineno;
        this.col_offset = col_offset;
        this.end_lineno = end_lineno;
        this.end_col_offset = end_col_offset;
        return this;
      };
      Sk.astnodes.Await = function Await(value, lineno, col_offset, end_lineno, end_col_offset) {
        Sk.asserts.assert(lineno !== null && lineno !== void 0);
        Sk.asserts.assert(col_offset !== null && col_offset !== void 0);
        Sk.asserts.assert(end_lineno !== null && end_lineno !== void 0);
        Sk.asserts.assert(end_col_offset !== null && end_col_offset !== void 0);
        this.value = value;
        this.lineno = lineno;
        this.col_offset = col_offset;
        this.end_lineno = end_lineno;
        this.end_col_offset = end_col_offset;
        return this;
      };
      Sk.astnodes.Yield = function Yield(value, lineno, col_offset, end_lineno, end_col_offset) {
        Sk.asserts.assert(lineno !== null && lineno !== void 0);
        Sk.asserts.assert(col_offset !== null && col_offset !== void 0);
        Sk.asserts.assert(end_lineno !== null && end_lineno !== void 0);
        Sk.asserts.assert(end_col_offset !== null && end_col_offset !== void 0);
        this.value = value;
        this.lineno = lineno;
        this.col_offset = col_offset;
        this.end_lineno = end_lineno;
        this.end_col_offset = end_col_offset;
        return this;
      };
      Sk.astnodes.YieldFrom = function YieldFrom(value, lineno, col_offset, end_lineno, end_col_offset) {
        Sk.asserts.assert(lineno !== null && lineno !== void 0);
        Sk.asserts.assert(col_offset !== null && col_offset !== void 0);
        Sk.asserts.assert(end_lineno !== null && end_lineno !== void 0);
        Sk.asserts.assert(end_col_offset !== null && end_col_offset !== void 0);
        this.value = value;
        this.lineno = lineno;
        this.col_offset = col_offset;
        this.end_lineno = end_lineno;
        this.end_col_offset = end_col_offset;
        return this;
      };
      Sk.astnodes.Compare = function Compare(left, ops, comparators, lineno, col_offset, end_lineno, end_col_offset) {
        Sk.asserts.assert(lineno !== null && lineno !== void 0);
        Sk.asserts.assert(col_offset !== null && col_offset !== void 0);
        Sk.asserts.assert(end_lineno !== null && end_lineno !== void 0);
        Sk.asserts.assert(end_col_offset !== null && end_col_offset !== void 0);
        this.left = left;
        this.ops = ops;
        this.comparators = comparators;
        this.lineno = lineno;
        this.col_offset = col_offset;
        this.end_lineno = end_lineno;
        this.end_col_offset = end_col_offset;
        return this;
      };
      Sk.astnodes.Call = function Call(func, args, keywords, lineno, col_offset, end_lineno, end_col_offset) {
        Sk.asserts.assert(lineno !== null && lineno !== void 0);
        Sk.asserts.assert(col_offset !== null && col_offset !== void 0);
        Sk.asserts.assert(end_lineno !== null && end_lineno !== void 0);
        Sk.asserts.assert(end_col_offset !== null && end_col_offset !== void 0);
        this.func = func;
        this.args = args;
        this.keywords = keywords;
        this.lineno = lineno;
        this.col_offset = col_offset;
        this.end_lineno = end_lineno;
        this.end_col_offset = end_col_offset;
        return this;
      };
      Sk.astnodes.Num = function Num(n, lineno, col_offset, end_lineno, end_col_offset) {
        Sk.asserts.assert(lineno !== null && lineno !== void 0);
        Sk.asserts.assert(col_offset !== null && col_offset !== void 0);
        Sk.asserts.assert(end_lineno !== null && end_lineno !== void 0);
        Sk.asserts.assert(end_col_offset !== null && end_col_offset !== void 0);
        this.n = n;
        this.lineno = lineno;
        this.col_offset = col_offset;
        this.end_lineno = end_lineno;
        this.end_col_offset = end_col_offset;
        return this;
      };
      Sk.astnodes.Str = function Str(s, lineno, col_offset, end_lineno, end_col_offset) {
        Sk.asserts.assert(lineno !== null && lineno !== void 0);
        Sk.asserts.assert(col_offset !== null && col_offset !== void 0);
        Sk.asserts.assert(end_lineno !== null && end_lineno !== void 0);
        Sk.asserts.assert(end_col_offset !== null && end_col_offset !== void 0);
        this.s = s;
        this.lineno = lineno;
        this.col_offset = col_offset;
        this.end_lineno = end_lineno;
        this.end_col_offset = end_col_offset;
        return this;
      };
      Sk.astnodes.FormattedValue = function FormattedValue(value, conversion, format_spec, lineno, col_offset, end_lineno, end_col_offset) {
        Sk.asserts.assert(lineno !== null && lineno !== void 0);
        Sk.asserts.assert(col_offset !== null && col_offset !== void 0);
        Sk.asserts.assert(end_lineno !== null && end_lineno !== void 0);
        Sk.asserts.assert(end_col_offset !== null && end_col_offset !== void 0);
        this.value = value;
        this.conversion = conversion;
        this.format_spec = format_spec;
        this.lineno = lineno;
        this.col_offset = col_offset;
        this.end_lineno = end_lineno;
        this.end_col_offset = end_col_offset;
        return this;
      };
      Sk.astnodes.JoinedStr = function JoinedStr(values, lineno, col_offset, end_lineno, end_col_offset) {
        Sk.asserts.assert(lineno !== null && lineno !== void 0);
        Sk.asserts.assert(col_offset !== null && col_offset !== void 0);
        Sk.asserts.assert(end_lineno !== null && end_lineno !== void 0);
        Sk.asserts.assert(end_col_offset !== null && end_col_offset !== void 0);
        this.values = values;
        this.lineno = lineno;
        this.col_offset = col_offset;
        this.end_lineno = end_lineno;
        this.end_col_offset = end_col_offset;
        return this;
      };
      Sk.astnodes.Bytes = function Bytes(s, lineno, col_offset, end_lineno, end_col_offset) {
        Sk.asserts.assert(lineno !== null && lineno !== void 0);
        Sk.asserts.assert(col_offset !== null && col_offset !== void 0);
        Sk.asserts.assert(end_lineno !== null && end_lineno !== void 0);
        Sk.asserts.assert(end_col_offset !== null && end_col_offset !== void 0);
        this.s = s;
        this.lineno = lineno;
        this.col_offset = col_offset;
        this.end_lineno = end_lineno;
        this.end_col_offset = end_col_offset;
        return this;
      };
      Sk.astnodes.NameConstant = function NameConstant(value, lineno, col_offset, end_lineno, end_col_offset) {
        Sk.asserts.assert(lineno !== null && lineno !== void 0);
        Sk.asserts.assert(col_offset !== null && col_offset !== void 0);
        Sk.asserts.assert(end_lineno !== null && end_lineno !== void 0);
        Sk.asserts.assert(end_col_offset !== null && end_col_offset !== void 0);
        this.value = value;
        this.lineno = lineno;
        this.col_offset = col_offset;
        this.end_lineno = end_lineno;
        this.end_col_offset = end_col_offset;
        return this;
      };
      Sk.astnodes.Ellipsis = function Ellipsis(lineno, col_offset, end_lineno, end_col_offset) {
        Sk.asserts.assert(lineno !== null && lineno !== void 0);
        Sk.asserts.assert(col_offset !== null && col_offset !== void 0);
        Sk.asserts.assert(end_lineno !== null && end_lineno !== void 0);
        Sk.asserts.assert(end_col_offset !== null && end_col_offset !== void 0);
        this.lineno = lineno;
        this.col_offset = col_offset;
        this.end_lineno = end_lineno;
        this.end_col_offset = end_col_offset;
        return this;
      };
      Sk.astnodes.Constant = function Constant(value, lineno, col_offset, end_lineno, end_col_offset) {
        Sk.asserts.assert(lineno !== null && lineno !== void 0);
        Sk.asserts.assert(col_offset !== null && col_offset !== void 0);
        Sk.asserts.assert(end_lineno !== null && end_lineno !== void 0);
        Sk.asserts.assert(end_col_offset !== null && end_col_offset !== void 0);
        this.value = value;
        this.lineno = lineno;
        this.col_offset = col_offset;
        this.end_lineno = end_lineno;
        this.end_col_offset = end_col_offset;
        return this;
      };
      Sk.astnodes.Attribute = function Attribute(value, attr, ctx, lineno, col_offset, end_lineno, end_col_offset) {
        Sk.asserts.assert(lineno !== null && lineno !== void 0);
        Sk.asserts.assert(col_offset !== null && col_offset !== void 0);
        Sk.asserts.assert(end_lineno !== null && end_lineno !== void 0);
        Sk.asserts.assert(end_col_offset !== null && end_col_offset !== void 0);
        this.value = value;
        this.attr = attr;
        this.ctx = ctx;
        this.lineno = lineno;
        this.col_offset = col_offset;
        this.end_lineno = end_lineno;
        this.end_col_offset = end_col_offset;
        return this;
      };
      Sk.astnodes.Subscript = function Subscript(value, slice, ctx, lineno, col_offset, end_lineno, end_col_offset) {
        Sk.asserts.assert(lineno !== null && lineno !== void 0);
        Sk.asserts.assert(col_offset !== null && col_offset !== void 0);
        Sk.asserts.assert(end_lineno !== null && end_lineno !== void 0);
        Sk.asserts.assert(end_col_offset !== null && end_col_offset !== void 0);
        this.value = value;
        this.slice = slice;
        this.ctx = ctx;
        this.lineno = lineno;
        this.col_offset = col_offset;
        this.end_lineno = end_lineno;
        this.end_col_offset = end_col_offset;
        return this;
      };
      Sk.astnodes.Starred = function Starred(value, ctx, lineno, col_offset, end_lineno, end_col_offset) {
        Sk.asserts.assert(lineno !== null && lineno !== void 0);
        Sk.asserts.assert(col_offset !== null && col_offset !== void 0);
        Sk.asserts.assert(end_lineno !== null && end_lineno !== void 0);
        Sk.asserts.assert(end_col_offset !== null && end_col_offset !== void 0);
        this.value = value;
        this.ctx = ctx;
        this.lineno = lineno;
        this.col_offset = col_offset;
        this.end_lineno = end_lineno;
        this.end_col_offset = end_col_offset;
        return this;
      };
      Sk.astnodes.Name = function Name2(id, ctx, lineno, col_offset, end_lineno, end_col_offset) {
        Sk.asserts.assert(lineno !== null && lineno !== void 0);
        Sk.asserts.assert(col_offset !== null && col_offset !== void 0);
        Sk.asserts.assert(end_lineno !== null && end_lineno !== void 0);
        Sk.asserts.assert(end_col_offset !== null && end_col_offset !== void 0);
        this.id = id;
        this.ctx = ctx;
        this.lineno = lineno;
        this.col_offset = col_offset;
        this.end_lineno = end_lineno;
        this.end_col_offset = end_col_offset;
        return this;
      };
      Sk.astnodes.List = function List(elts, ctx, lineno, col_offset, end_lineno, end_col_offset) {
        Sk.asserts.assert(lineno !== null && lineno !== void 0);
        Sk.asserts.assert(col_offset !== null && col_offset !== void 0);
        Sk.asserts.assert(end_lineno !== null && end_lineno !== void 0);
        Sk.asserts.assert(end_col_offset !== null && end_col_offset !== void 0);
        this.elts = elts;
        this.ctx = ctx;
        this.lineno = lineno;
        this.col_offset = col_offset;
        this.end_lineno = end_lineno;
        this.end_col_offset = end_col_offset;
        return this;
      };
      Sk.astnodes.Tuple = function Tuple(elts, ctx, lineno, col_offset, end_lineno, end_col_offset) {
        Sk.asserts.assert(lineno !== null && lineno !== void 0);
        Sk.asserts.assert(col_offset !== null && col_offset !== void 0);
        Sk.asserts.assert(end_lineno !== null && end_lineno !== void 0);
        Sk.asserts.assert(end_col_offset !== null && end_col_offset !== void 0);
        this.elts = elts;
        this.ctx = ctx;
        this.lineno = lineno;
        this.col_offset = col_offset;
        this.end_lineno = end_lineno;
        this.end_col_offset = end_col_offset;
        return this;
      };
      Sk.astnodes.Slice = function Slice(lower, upper, step) {
        this.lower = lower;
        this.upper = upper;
        this.step = step;
        return this;
      };
      Sk.astnodes.ExtSlice = function ExtSlice(dims) {
        this.dims = dims;
        return this;
      };
      Sk.astnodes.Index = function Index(value) {
        this.value = value;
        return this;
      };
      Sk.astnodes.comprehension = function comprehension(target, iter, ifs, is_async) {
        this.target = target;
        this.iter = iter;
        this.ifs = ifs;
        this.is_async = is_async;
        return this;
      };
      Sk.astnodes.ExceptHandler = function ExceptHandler(type, name, body, lineno, col_offset, end_lineno, end_col_offset) {
        Sk.asserts.assert(lineno !== null && lineno !== void 0);
        Sk.asserts.assert(col_offset !== null && col_offset !== void 0);
        Sk.asserts.assert(end_lineno !== null && end_lineno !== void 0);
        Sk.asserts.assert(end_col_offset !== null && end_col_offset !== void 0);
        this.type = type;
        this.name = name;
        this.body = body;
        this.lineno = lineno;
        this.col_offset = col_offset;
        this.end_lineno = end_lineno;
        this.end_col_offset = end_col_offset;
        return this;
      };
      Sk.astnodes.arguments_ = function arguments_(args, vararg, kwonlyargs, kw_defaults, kwarg, defaults) {
        this.args = args;
        this.vararg = vararg;
        this.kwonlyargs = kwonlyargs;
        this.kw_defaults = kw_defaults;
        this.kwarg = kwarg;
        this.defaults = defaults;
        return this;
      };
      Sk.astnodes.arg = function arg(arg, annotation) {
        this.arg = arg;
        this.annotation = annotation;
        return this;
      };
      Sk.astnodes.keyword = function keyword(arg, value) {
        this.arg = arg;
        this.value = value;
        return this;
      };
      Sk.astnodes.alias = function alias(name, asname) {
        this.name = name;
        this.asname = asname;
        return this;
      };
      Sk.astnodes.withitem = function withitem(context_expr, optional_vars) {
        this.context_expr = context_expr;
        this.optional_vars = optional_vars;
        return this;
      };
      Sk.astnodes.Module.prototype._astname = "Module";
      Sk.astnodes.Module.prototype._fields = [
        "body",
        function(n) {
          return n.body;
        },
        "docstring",
        function(n) {
          return n.docstring;
        }
      ];
      Sk.astnodes.Interactive.prototype._astname = "Interactive";
      Sk.astnodes.Interactive.prototype._fields = [
        "body",
        function(n) {
          return n.body;
        }
      ];
      Sk.astnodes.Expression.prototype._astname = "Expression";
      Sk.astnodes.Expression.prototype._fields = [
        "body",
        function(n) {
          return n.body;
        }
      ];
      Sk.astnodes.Suite.prototype._astname = "Suite";
      Sk.astnodes.Suite.prototype._fields = [
        "body",
        function(n) {
          return n.body;
        }
      ];
      Sk.astnodes.FunctionDef.prototype._astname = "FunctionDef";
      Sk.astnodes.FunctionDef.prototype._fields = [
        "name",
        function(n) {
          return n.name;
        },
        "args",
        function(n) {
          return n.args;
        },
        "body",
        function(n) {
          return n.body;
        },
        "decorator_list",
        function(n) {
          return n.decorator_list;
        },
        "returns",
        function(n) {
          return n.returns;
        },
        "docstring",
        function(n) {
          return n.docstring;
        }
      ];
      Sk.astnodes.AsyncFunctionDef.prototype._astname = "AsyncFunctionDef";
      Sk.astnodes.AsyncFunctionDef.prototype._fields = [
        "name",
        function(n) {
          return n.name;
        },
        "args",
        function(n) {
          return n.args;
        },
        "body",
        function(n) {
          return n.body;
        },
        "decorator_list",
        function(n) {
          return n.decorator_list;
        },
        "returns",
        function(n) {
          return n.returns;
        },
        "docstring",
        function(n) {
          return n.docstring;
        }
      ];
      Sk.astnodes.ClassDef.prototype._astname = "ClassDef";
      Sk.astnodes.ClassDef.prototype._fields = [
        "name",
        function(n) {
          return n.name;
        },
        "bases",
        function(n) {
          return n.bases;
        },
        "keywords",
        function(n) {
          return n.keywords;
        },
        "body",
        function(n) {
          return n.body;
        },
        "decorator_list",
        function(n) {
          return n.decorator_list;
        },
        "docstring",
        function(n) {
          return n.docstring;
        }
      ];
      Sk.astnodes.Return.prototype._astname = "Return";
      Sk.astnodes.Return.prototype._fields = [
        "value",
        function(n) {
          return n.value;
        }
      ];
      Sk.astnodes.Delete.prototype._astname = "Delete";
      Sk.astnodes.Delete.prototype._fields = [
        "targets",
        function(n) {
          return n.targets;
        }
      ];
      Sk.astnodes.Assign.prototype._astname = "Assign";
      Sk.astnodes.Assign.prototype._fields = [
        "targets",
        function(n) {
          return n.targets;
        },
        "value",
        function(n) {
          return n.value;
        }
      ];
      Sk.astnodes.AugAssign.prototype._astname = "AugAssign";
      Sk.astnodes.AugAssign.prototype._fields = [
        "target",
        function(n) {
          return n.target;
        },
        "op",
        function(n) {
          return n.op;
        },
        "value",
        function(n) {
          return n.value;
        }
      ];
      Sk.astnodes.AnnAssign.prototype._astname = "AnnAssign";
      Sk.astnodes.AnnAssign.prototype._fields = [
        "target",
        function(n) {
          return n.target;
        },
        "annotation",
        function(n) {
          return n.annotation;
        },
        "value",
        function(n) {
          return n.value;
        },
        "simple",
        function(n) {
          return n.simple;
        }
      ];
      Sk.astnodes.For.prototype._astname = "For";
      Sk.astnodes.For.prototype._fields = [
        "target",
        function(n) {
          return n.target;
        },
        "iter",
        function(n) {
          return n.iter;
        },
        "body",
        function(n) {
          return n.body;
        },
        "orelse",
        function(n) {
          return n.orelse;
        }
      ];
      Sk.astnodes.AsyncFor.prototype._astname = "AsyncFor";
      Sk.astnodes.AsyncFor.prototype._fields = [
        "target",
        function(n) {
          return n.target;
        },
        "iter",
        function(n) {
          return n.iter;
        },
        "body",
        function(n) {
          return n.body;
        },
        "orelse",
        function(n) {
          return n.orelse;
        }
      ];
      Sk.astnodes.While.prototype._astname = "While";
      Sk.astnodes.While.prototype._fields = [
        "test",
        function(n) {
          return n.test;
        },
        "body",
        function(n) {
          return n.body;
        },
        "orelse",
        function(n) {
          return n.orelse;
        }
      ];
      Sk.astnodes.If.prototype._astname = "If";
      Sk.astnodes.If.prototype._fields = [
        "test",
        function(n) {
          return n.test;
        },
        "body",
        function(n) {
          return n.body;
        },
        "orelse",
        function(n) {
          return n.orelse;
        }
      ];
      Sk.astnodes.With.prototype._astname = "With";
      Sk.astnodes.With.prototype._fields = [
        "items",
        function(n) {
          return n.items;
        },
        "body",
        function(n) {
          return n.body;
        }
      ];
      Sk.astnodes.AsyncWith.prototype._astname = "AsyncWith";
      Sk.astnodes.AsyncWith.prototype._fields = [
        "items",
        function(n) {
          return n.items;
        },
        "body",
        function(n) {
          return n.body;
        }
      ];
      Sk.astnodes.Raise.prototype._astname = "Raise";
      Sk.astnodes.Raise.prototype._fields = [
        "exc",
        function(n) {
          return n.exc;
        },
        "cause",
        function(n) {
          return n.cause;
        },
        "inst",
        function(n) {
          return n.inst;
        },
        "tback",
        function(n) {
          return n.tback;
        }
      ];
      Sk.astnodes.Try.prototype._astname = "Try";
      Sk.astnodes.Try.prototype._fields = [
        "body",
        function(n) {
          return n.body;
        },
        "handlers",
        function(n) {
          return n.handlers;
        },
        "orelse",
        function(n) {
          return n.orelse;
        },
        "finalbody",
        function(n) {
          return n.finalbody;
        }
      ];
      Sk.astnodes.Assert.prototype._astname = "Assert";
      Sk.astnodes.Assert.prototype._fields = [
        "test",
        function(n) {
          return n.test;
        },
        "msg",
        function(n) {
          return n.msg;
        }
      ];
      Sk.astnodes.Import.prototype._astname = "Import";
      Sk.astnodes.Import.prototype._fields = [
        "names",
        function(n) {
          return n.names;
        }
      ];
      Sk.astnodes.ImportFrom.prototype._astname = "ImportFrom";
      Sk.astnodes.ImportFrom.prototype._fields = [
        "module",
        function(n) {
          return n.module;
        },
        "names",
        function(n) {
          return n.names;
        },
        "level",
        function(n) {
          return n.level;
        }
      ];
      Sk.astnodes.Global.prototype._astname = "Global";
      Sk.astnodes.Global.prototype._fields = [
        "names",
        function(n) {
          return n.names;
        }
      ];
      Sk.astnodes.Nonlocal.prototype._astname = "Nonlocal";
      Sk.astnodes.Nonlocal.prototype._fields = [
        "names",
        function(n) {
          return n.names;
        }
      ];
      Sk.astnodes.Expr.prototype._astname = "Expr";
      Sk.astnodes.Expr.prototype._fields = [
        "value",
        function(n) {
          return n.value;
        }
      ];
      Sk.astnodes.Pass.prototype._astname = "Pass";
      Sk.astnodes.Pass.prototype._fields = [];
      Sk.astnodes.Break.prototype._astname = "Break";
      Sk.astnodes.Break.prototype._fields = [];
      Sk.astnodes.Continue.prototype._astname = "Continue";
      Sk.astnodes.Continue.prototype._fields = [];
      Sk.astnodes.Print.prototype._astname = "Print";
      Sk.astnodes.Print.prototype._fields = [
        "dest",
        function(n) {
          return n.dest;
        },
        "values",
        function(n) {
          return n.values;
        },
        "nl",
        function(n) {
          return n.nl;
        }
      ];
      Sk.astnodes.Debugger.prototype._astname = "Debugger";
      Sk.astnodes.Debugger.prototype._fields = [];
      Sk.astnodes.BoolOp.prototype._astname = "BoolOp";
      Sk.astnodes.BoolOp.prototype._fields = [
        "op",
        function(n) {
          return n.op;
        },
        "values",
        function(n) {
          return n.values;
        }
      ];
      Sk.astnodes.BinOp.prototype._astname = "BinOp";
      Sk.astnodes.BinOp.prototype._fields = [
        "left",
        function(n) {
          return n.left;
        },
        "op",
        function(n) {
          return n.op;
        },
        "right",
        function(n) {
          return n.right;
        }
      ];
      Sk.astnodes.UnaryOp.prototype._astname = "UnaryOp";
      Sk.astnodes.UnaryOp.prototype._fields = [
        "op",
        function(n) {
          return n.op;
        },
        "operand",
        function(n) {
          return n.operand;
        }
      ];
      Sk.astnodes.Lambda.prototype._astname = "Lambda";
      Sk.astnodes.Lambda.prototype._fields = [
        "args",
        function(n) {
          return n.args;
        },
        "body",
        function(n) {
          return n.body;
        }
      ];
      Sk.astnodes.IfExp.prototype._astname = "IfExp";
      Sk.astnodes.IfExp.prototype._fields = [
        "test",
        function(n) {
          return n.test;
        },
        "body",
        function(n) {
          return n.body;
        },
        "orelse",
        function(n) {
          return n.orelse;
        }
      ];
      Sk.astnodes.Dict.prototype._astname = "Dict";
      Sk.astnodes.Dict.prototype._fields = [
        "keys",
        function(n) {
          return n.keys;
        },
        "values",
        function(n) {
          return n.values;
        }
      ];
      Sk.astnodes.Set.prototype._astname = "Set";
      Sk.astnodes.Set.prototype._fields = [
        "elts",
        function(n) {
          return n.elts;
        }
      ];
      Sk.astnodes.ListComp.prototype._astname = "ListComp";
      Sk.astnodes.ListComp.prototype._fields = [
        "elt",
        function(n) {
          return n.elt;
        },
        "generators",
        function(n) {
          return n.generators;
        }
      ];
      Sk.astnodes.SetComp.prototype._astname = "SetComp";
      Sk.astnodes.SetComp.prototype._fields = [
        "elt",
        function(n) {
          return n.elt;
        },
        "generators",
        function(n) {
          return n.generators;
        }
      ];
      Sk.astnodes.DictComp.prototype._astname = "DictComp";
      Sk.astnodes.DictComp.prototype._fields = [
        "key",
        function(n) {
          return n.key;
        },
        "value",
        function(n) {
          return n.value;
        },
        "generators",
        function(n) {
          return n.generators;
        }
      ];
      Sk.astnodes.GeneratorExp.prototype._astname = "GeneratorExp";
      Sk.astnodes.GeneratorExp.prototype._fields = [
        "elt",
        function(n) {
          return n.elt;
        },
        "generators",
        function(n) {
          return n.generators;
        }
      ];
      Sk.astnodes.Await.prototype._astname = "Await";
      Sk.astnodes.Await.prototype._fields = [
        "value",
        function(n) {
          return n.value;
        }
      ];
      Sk.astnodes.Yield.prototype._astname = "Yield";
      Sk.astnodes.Yield.prototype._fields = [
        "value",
        function(n) {
          return n.value;
        }
      ];
      Sk.astnodes.YieldFrom.prototype._astname = "YieldFrom";
      Sk.astnodes.YieldFrom.prototype._fields = [
        "value",
        function(n) {
          return n.value;
        }
      ];
      Sk.astnodes.Compare.prototype._astname = "Compare";
      Sk.astnodes.Compare.prototype._fields = [
        "left",
        function(n) {
          return n.left;
        },
        "ops",
        function(n) {
          return n.ops;
        },
        "comparators",
        function(n) {
          return n.comparators;
        }
      ];
      Sk.astnodes.Call.prototype._astname = "Call";
      Sk.astnodes.Call.prototype._fields = [
        "func",
        function(n) {
          return n.func;
        },
        "args",
        function(n) {
          return n.args;
        },
        "keywords",
        function(n) {
          return n.keywords;
        }
      ];
      Sk.astnodes.Num.prototype._astname = "Num";
      Sk.astnodes.Num.prototype._fields = [
        "n",
        function(n) {
          return n.n;
        }
      ];
      Sk.astnodes.Str.prototype._astname = "Str";
      Sk.astnodes.Str.prototype._fields = [
        "s",
        function(n) {
          return n.s;
        }
      ];
      Sk.astnodes.FormattedValue.prototype._astname = "FormattedValue";
      Sk.astnodes.FormattedValue.prototype._fields = [
        "value",
        function(n) {
          return n.value;
        },
        "conversion",
        function(n) {
          return n.conversion;
        },
        "format_spec",
        function(n) {
          return n.format_spec;
        }
      ];
      Sk.astnodes.JoinedStr.prototype._astname = "JoinedStr";
      Sk.astnodes.JoinedStr.prototype._fields = [
        "values",
        function(n) {
          return n.values;
        }
      ];
      Sk.astnodes.Bytes.prototype._astname = "Bytes";
      Sk.astnodes.Bytes.prototype._fields = [
        "s",
        function(n) {
          return n.s;
        }
      ];
      Sk.astnodes.NameConstant.prototype._astname = "NameConstant";
      Sk.astnodes.NameConstant.prototype._fields = [
        "value",
        function(n) {
          return n.value;
        }
      ];
      Sk.astnodes.Ellipsis.prototype._astname = "Ellipsis";
      Sk.astnodes.Ellipsis.prototype._fields = [];
      Sk.astnodes.Constant.prototype._astname = "Constant";
      Sk.astnodes.Constant.prototype._fields = [
        "value",
        function(n) {
          return n.value;
        }
      ];
      Sk.astnodes.Attribute.prototype._astname = "Attribute";
      Sk.astnodes.Attribute.prototype._fields = [
        "value",
        function(n) {
          return n.value;
        },
        "attr",
        function(n) {
          return n.attr;
        },
        "ctx",
        function(n) {
          return n.ctx;
        }
      ];
      Sk.astnodes.Subscript.prototype._astname = "Subscript";
      Sk.astnodes.Subscript.prototype._fields = [
        "value",
        function(n) {
          return n.value;
        },
        "slice",
        function(n) {
          return n.slice;
        },
        "ctx",
        function(n) {
          return n.ctx;
        }
      ];
      Sk.astnodes.Starred.prototype._astname = "Starred";
      Sk.astnodes.Starred.prototype._fields = [
        "value",
        function(n) {
          return n.value;
        },
        "ctx",
        function(n) {
          return n.ctx;
        }
      ];
      Sk.astnodes.Name.prototype._astname = "Name";
      Sk.astnodes.Name.prototype._fields = [
        "id",
        function(n) {
          return n.id;
        },
        "ctx",
        function(n) {
          return n.ctx;
        }
      ];
      Sk.astnodes.List.prototype._astname = "List";
      Sk.astnodes.List.prototype._fields = [
        "elts",
        function(n) {
          return n.elts;
        },
        "ctx",
        function(n) {
          return n.ctx;
        }
      ];
      Sk.astnodes.Tuple.prototype._astname = "Tuple";
      Sk.astnodes.Tuple.prototype._fields = [
        "elts",
        function(n) {
          return n.elts;
        },
        "ctx",
        function(n) {
          return n.ctx;
        }
      ];
      Sk.astnodes.Load.prototype._astname = "Load";
      Sk.astnodes.Load.prototype._isenum = true;
      Sk.astnodes.Store.prototype._astname = "Store";
      Sk.astnodes.Store.prototype._isenum = true;
      Sk.astnodes.Del.prototype._astname = "Del";
      Sk.astnodes.Del.prototype._isenum = true;
      Sk.astnodes.AugLoad.prototype._astname = "AugLoad";
      Sk.astnodes.AugLoad.prototype._isenum = true;
      Sk.astnodes.AugStore.prototype._astname = "AugStore";
      Sk.astnodes.AugStore.prototype._isenum = true;
      Sk.astnodes.Param.prototype._astname = "Param";
      Sk.astnodes.Param.prototype._isenum = true;
      Sk.astnodes.Slice.prototype._astname = "Slice";
      Sk.astnodes.Slice.prototype._fields = [
        "lower",
        function(n) {
          return n.lower;
        },
        "upper",
        function(n) {
          return n.upper;
        },
        "step",
        function(n) {
          return n.step;
        }
      ];
      Sk.astnodes.ExtSlice.prototype._astname = "ExtSlice";
      Sk.astnodes.ExtSlice.prototype._fields = [
        "dims",
        function(n) {
          return n.dims;
        }
      ];
      Sk.astnodes.Index.prototype._astname = "Index";
      Sk.astnodes.Index.prototype._fields = [
        "value",
        function(n) {
          return n.value;
        }
      ];
      Sk.astnodes.And.prototype._astname = "And";
      Sk.astnodes.And.prototype._isenum = true;
      Sk.astnodes.Or.prototype._astname = "Or";
      Sk.astnodes.Or.prototype._isenum = true;
      Sk.astnodes.Add.prototype._astname = "Add";
      Sk.astnodes.Add.prototype._isenum = true;
      Sk.astnodes.Sub.prototype._astname = "Sub";
      Sk.astnodes.Sub.prototype._isenum = true;
      Sk.astnodes.Mult.prototype._astname = "Mult";
      Sk.astnodes.Mult.prototype._isenum = true;
      Sk.astnodes.MatMult.prototype._astname = "MatMult";
      Sk.astnodes.MatMult.prototype._isenum = true;
      Sk.astnodes.Div.prototype._astname = "Div";
      Sk.astnodes.Div.prototype._isenum = true;
      Sk.astnodes.Mod.prototype._astname = "Mod";
      Sk.astnodes.Mod.prototype._isenum = true;
      Sk.astnodes.Pow.prototype._astname = "Pow";
      Sk.astnodes.Pow.prototype._isenum = true;
      Sk.astnodes.LShift.prototype._astname = "LShift";
      Sk.astnodes.LShift.prototype._isenum = true;
      Sk.astnodes.RShift.prototype._astname = "RShift";
      Sk.astnodes.RShift.prototype._isenum = true;
      Sk.astnodes.BitOr.prototype._astname = "BitOr";
      Sk.astnodes.BitOr.prototype._isenum = true;
      Sk.astnodes.BitXor.prototype._astname = "BitXor";
      Sk.astnodes.BitXor.prototype._isenum = true;
      Sk.astnodes.BitAnd.prototype._astname = "BitAnd";
      Sk.astnodes.BitAnd.prototype._isenum = true;
      Sk.astnodes.FloorDiv.prototype._astname = "FloorDiv";
      Sk.astnodes.FloorDiv.prototype._isenum = true;
      Sk.astnodes.Invert.prototype._astname = "Invert";
      Sk.astnodes.Invert.prototype._isenum = true;
      Sk.astnodes.Not.prototype._astname = "Not";
      Sk.astnodes.Not.prototype._isenum = true;
      Sk.astnodes.UAdd.prototype._astname = "UAdd";
      Sk.astnodes.UAdd.prototype._isenum = true;
      Sk.astnodes.USub.prototype._astname = "USub";
      Sk.astnodes.USub.prototype._isenum = true;
      Sk.astnodes.Eq.prototype._astname = "Eq";
      Sk.astnodes.Eq.prototype._isenum = true;
      Sk.astnodes.NotEq.prototype._astname = "NotEq";
      Sk.astnodes.NotEq.prototype._isenum = true;
      Sk.astnodes.Lt.prototype._astname = "Lt";
      Sk.astnodes.Lt.prototype._isenum = true;
      Sk.astnodes.LtE.prototype._astname = "LtE";
      Sk.astnodes.LtE.prototype._isenum = true;
      Sk.astnodes.Gt.prototype._astname = "Gt";
      Sk.astnodes.Gt.prototype._isenum = true;
      Sk.astnodes.GtE.prototype._astname = "GtE";
      Sk.astnodes.GtE.prototype._isenum = true;
      Sk.astnodes.Is.prototype._astname = "Is";
      Sk.astnodes.Is.prototype._isenum = true;
      Sk.astnodes.IsNot.prototype._astname = "IsNot";
      Sk.astnodes.IsNot.prototype._isenum = true;
      Sk.astnodes.In.prototype._astname = "In";
      Sk.astnodes.In.prototype._isenum = true;
      Sk.astnodes.NotIn.prototype._astname = "NotIn";
      Sk.astnodes.NotIn.prototype._isenum = true;
      Sk.astnodes.comprehension.prototype._astname = "comprehension";
      Sk.astnodes.comprehension.prototype._fields = [
        "target",
        function(n) {
          return n.target;
        },
        "iter",
        function(n) {
          return n.iter;
        },
        "ifs",
        function(n) {
          return n.ifs;
        },
        "is_async",
        function(n) {
          return n.is_async;
        }
      ];
      Sk.astnodes.ExceptHandler.prototype._astname = "ExceptHandler";
      Sk.astnodes.ExceptHandler.prototype._fields = [
        "type",
        function(n) {
          return n.type;
        },
        "name",
        function(n) {
          return n.name;
        },
        "body",
        function(n) {
          return n.body;
        }
      ];
      Sk.astnodes.arguments_.prototype._astname = "arguments";
      Sk.astnodes.arguments_.prototype._fields = [
        "args",
        function(n) {
          return n.args;
        },
        "vararg",
        function(n) {
          return n.vararg;
        },
        "kwonlyargs",
        function(n) {
          return n.kwonlyargs;
        },
        "kw_defaults",
        function(n) {
          return n.kw_defaults;
        },
        "kwarg",
        function(n) {
          return n.kwarg;
        },
        "defaults",
        function(n) {
          return n.defaults;
        }
      ];
      Sk.astnodes.arg.prototype._astname = "arg";
      Sk.astnodes.arg.prototype._fields = [
        "arg",
        function(n) {
          return n.arg;
        },
        "annotation",
        function(n) {
          return n.annotation;
        }
      ];
      Sk.astnodes.keyword.prototype._astname = "keyword";
      Sk.astnodes.keyword.prototype._fields = [
        "arg",
        function(n) {
          return n.arg;
        },
        "value",
        function(n) {
          return n.value;
        }
      ];
      Sk.astnodes.alias.prototype._astname = "alias";
      Sk.astnodes.alias.prototype._fields = [
        "name",
        function(n) {
          return n.name;
        },
        "asname",
        function(n) {
          return n.asname;
        }
      ];
      Sk.astnodes.withitem.prototype._astname = "withitem";
      Sk.astnodes.withitem.prototype._fields = [
        "context_expr",
        function(n) {
          return n.context_expr;
        },
        "optional_vars",
        function(n) {
          return n.optional_vars;
        }
      ];
      Sk.exportSymbol("Sk.astnodes", Sk.astnodes);
    }
  });

  // src/ast.js
  var require_ast = __commonJS({
    "src/ast.js"() {
      var SYM = Sk.ParseTables.sym;
      var TOK = Sk.token.tokens;
      var COMP_GENEXP = 0;
      var COMP_LISTCOMP = 1;
      var COMP_SETCOMP = 2;
      var NULL = null;
      var _slice_kind = {
        Slice_kind: 1,
        ExtSlice_kind: 2,
        Index_kind: 3
      };
      function Compiling(encoding, filename, c_flags) {
        this.c_encoding = encoding;
        this.c_filename = filename;
        this.c_flags = c_flags || 0;
      }
      function NCH(n) {
        Sk.asserts.assert(n !== void 0, "node must be defined");
        if (n.children === null) {
          return 0;
        }
        return n.children.length;
      }
      function CHILD(n, i) {
        Sk.asserts.assert(n !== void 0, "node must be defined");
        Sk.asserts.assert(i !== void 0, "index of child must be specified");
        return n.children[i];
      }
      function REQ(n, type) {
        Sk.asserts.assert(n.type === type, "node wasn't expected type");
      }
      function TYPE(n) {
        return n.type;
      }
      function LINENO(n) {
        return n.lineno;
      }
      function STR(ch) {
        return ch.value;
      }
      function ast_error(c, n, msg) {
        throw new Sk.builtin.SyntaxError(msg, c.c_filename, ...get_context(n));
      }
      function strobj(s) {
        Sk.asserts.assert(typeof s === "string", "expecting string, got " + typeof s);
        return new Sk.builtin.str(s);
      }
      function numStmts(n) {
        var ch;
        var i;
        var cnt;
        switch (n.type) {
          case SYM.single_input:
            if (CHILD(n, 0).type === TOK.T_NEWLINE) {
              return 0;
            } else {
              return numStmts(CHILD(n, 0));
            }
          case SYM.file_input:
            cnt = 0;
            for (i = 0; i < NCH(n); ++i) {
              ch = CHILD(n, i);
              if (ch.type === SYM.stmt) {
                cnt += numStmts(ch);
              }
            }
            return cnt;
          case SYM.stmt:
            return numStmts(CHILD(n, 0));
          case SYM.compound_stmt:
            return 1;
          case SYM.simple_stmt:
            return Math.floor(NCH(n) / 2);
          // div 2 is to remove count of ;s
          case SYM.suite:
            if (NCH(n) === 1) {
              return numStmts(CHILD(n, 0));
            } else {
              cnt = 0;
              for (i = 2; i < NCH(n) - 1; ++i) {
                cnt += numStmts(CHILD(n, i));
              }
              return cnt;
            }
            break;
          default:
            Sk.asserts.fail("Non-statement found");
        }
        return 0;
      }
      function forbiddenCheck(c, n, x, lineno) {
        if (x instanceof Sk.builtin.str) {
          x = x.v;
        }
        if (x === "None") {
          throw new Sk.builtin.SyntaxError("assignment to None", c.c_filename, ...get_context(n));
        }
        if (x === "True" || x === "False") {
          throw new Sk.builtin.SyntaxError(
            "assignment to True or False is forbidden",
            c.c_filename,
            ...get_context(n)
          );
        }
      }
      function get_context(n) {
        return ["", n.lineno, n.col_offset || 0, n.end_lineno || n.lineno, n.end_col_offset || 0];
      }
      function setContext(c, e, ctx, n) {
        var i;
        var exprName;
        var s;
        Sk.asserts.assert(
          ctx !== Sk.astnodes.AugStore && ctx !== Sk.astnodes.AugLoad,
          "context not AugStore or AugLoad"
        );
        s = null;
        exprName = null;
        switch (e.constructor) {
          case Sk.astnodes.Attribute:
          case Sk.astnodes.Name:
            if (ctx === Sk.astnodes.Store) {
              forbiddenCheck(c, n, e.attr, n.lineno);
            }
            e.ctx = ctx;
            break;
          case Sk.astnodes.Starred:
            e.ctx = ctx;
            setContext(c, e.value, ctx, n);
            break;
          case Sk.astnodes.Subscript:
            e.ctx = ctx;
            break;
          case Sk.astnodes.List:
            e.ctx = ctx;
            s = e.elts;
            break;
          case Sk.astnodes.Tuple:
            if (e.elts.length === 0) {
              throw new Sk.builtin.SyntaxError(
                "can't assign to ()",
                c.c_filename,
                ...get_context(n)
              );
            }
            e.ctx = ctx;
            s = e.elts;
            break;
          case Sk.astnodes.Lambda:
            exprName = "lambda";
            break;
          case Sk.astnodes.Call:
            exprName = "function call";
            break;
          case Sk.astnodes.BoolOp:
          case Sk.astnodes.BinOp:
          case Sk.astnodes.UnaryOp:
            exprName = "operator";
            break;
          case Sk.astnodes.GeneratorExp:
            exprName = "generator expression";
            break;
          case Sk.astnodes.Yield:
            exprName = "yield expression";
            break;
          case Sk.astnodes.ListComp:
            exprName = "list comprehension";
            break;
          case Sk.astnodes.SetComp:
            exprName = "set comprehension";
            break;
          case Sk.astnodes.DictComp:
            exprName = "dict comprehension";
            break;
          case Sk.astnodes.Dict:
          case Sk.astnodes.Set:
          case Sk.astnodes.Num:
          case Sk.astnodes.Str:
            exprName = "literal";
            break;
          case Sk.astnodes.NameConstant:
            exprName = "True, False or None";
            break;
          case Sk.astnodes.Compare:
            exprName = "comparison";
            break;
          case Sk.astnodes.Repr:
            exprName = "repr";
            break;
          case Sk.astnodes.IfExp:
            exprName = "conditional expression";
            break;
          default:
            Sk.asserts.fail("unhandled expression in assignment");
        }
        if (exprName) {
          throw new Sk.builtin.SyntaxError(
            "can't " + (ctx === Sk.astnodes.Store ? "assign to" : "delete") + " " + exprName,
            c.c_filename,
            ...get_context(n)
          );
        }
        if (s) {
          for (i = 0; i < s.length; ++i) {
            setContext(c, s[i], ctx, n);
          }
        }
      }
      var operatorMap = {};
      (function() {
        operatorMap[TOK.T_VBAR] = Sk.astnodes.BitOr;
        operatorMap[TOK.T_CIRCUMFLEX] = Sk.astnodes.BitXor;
        operatorMap[TOK.T_AMPER] = Sk.astnodes.BitAnd;
        operatorMap[TOK.T_LEFTSHIFT] = Sk.astnodes.LShift;
        operatorMap[TOK.T_RIGHTSHIFT] = Sk.astnodes.RShift;
        operatorMap[TOK.T_PLUS] = Sk.astnodes.Add;
        operatorMap[TOK.T_MINUS] = Sk.astnodes.Sub;
        operatorMap[TOK.T_STAR] = Sk.astnodes.Mult;
        operatorMap[TOK.T_SLASH] = Sk.astnodes.Div;
        operatorMap[TOK.T_DOUBLESLASH] = Sk.astnodes.FloorDiv;
        operatorMap[TOK.T_PERCENT] = Sk.astnodes.Mod;
      })();
      Sk.setupOperators = function(py3) {
        if (py3) {
          operatorMap[TOK.T_AT] = Sk.astnodes.MatMult;
        } else {
          if (operatorMap[TOK.T_AT]) {
            delete operatorMap[TOK.T_AT];
          }
        }
      };
      Sk.exportSymbol("Sk.setupOperators", Sk.setupOperators);
      function getOperator(n) {
        if (operatorMap[n.type] === void 0) {
          throw new Sk.builtin.SyntaxError("invalid syntax", n.type, ...get_context(n));
        }
        return operatorMap[n.type];
      }
      function new_identifier(n, c) {
        if (n.value) {
          return new Sk.builtin.str(n.value);
        }
        return new Sk.builtin.str(n);
      }
      function astForCompOp(c, n) {
        REQ(n, SYM.comp_op);
        if (NCH(n) === 1) {
          n = CHILD(n, 0);
          switch (n.type) {
            case TOK.T_LESS:
              return Sk.astnodes.Lt;
            case TOK.T_GREATER:
              return Sk.astnodes.Gt;
            case TOK.T_EQEQUAL:
              return Sk.astnodes.Eq;
            case TOK.T_LESSEQUAL:
              return Sk.astnodes.LtE;
            case TOK.T_GREATEREQUAL:
              return Sk.astnodes.GtE;
            case TOK.T_NOTEQUAL:
              return Sk.astnodes.NotEq;
            case TOK.T_NAME:
              if (n.value === "in") {
                return Sk.astnodes.In;
              }
              if (n.value === "is") {
                return Sk.astnodes.Is;
              }
          }
        } else if (NCH(n) === 2) {
          if (CHILD(n, 0).type === TOK.T_NAME) {
            if (CHILD(n, 1).value === "in") {
              return Sk.astnodes.NotIn;
            }
            if (CHILD(n, 0).value === "is") {
              return Sk.astnodes.IsNot;
            }
          }
        }
        Sk.asserts.fail("invalid comp_op");
      }
      function copy_location(e, n) {
        if (e) {
          e.lineno = LINENO(n);
          e.col_offset = n.col_offset;
          e.end_lineno = n.end_lineno;
          e.end_col_offset = n.end_col_offset;
        }
        return e;
      }
      function seq_for_testlist(c, n) {
        var i;
        var seq = [];
        Sk.asserts.assert(
          n.type === SYM.testlist || n.type === SYM.testlist_star_expr || n.type === SYM.listmaker || n.type === SYM.testlist_comp || n.type === SYM.testlist_safe || n.type === SYM.testlist1,
          "node type must be listlike"
        );
        for (i = 0; i < NCH(n); i += 2) {
          Sk.asserts.assert(
            CHILD(n, i).type === SYM.test || CHILD(n, i).type === SYM.old_test || CHILD(n, i).type === SYM.star_expr
          );
          seq[i / 2] = ast_for_expr(c, CHILD(n, i));
        }
        return seq;
      }
      function astForSuite(c, n) {
        var j;
        var num;
        var i;
        var end;
        var ch;
        var pos;
        var seq;
        REQ(n, SYM.suite);
        seq = [];
        pos = 0;
        if (CHILD(n, 0).type === SYM.simple_stmt) {
          n = CHILD(n, 0);
          end = NCH(n) - 1;
          if (CHILD(n, end - 1).type === TOK.T_SEMI) {
            end -= 1;
          }
          for (i = 0; i < end; i += 2) {
            seq[pos++] = astForStmt(c, CHILD(n, i));
          }
        } else {
          for (i = 2; i < NCH(n) - 1; ++i) {
            ch = CHILD(n, i);
            REQ(ch, SYM.stmt);
            num = numStmts(ch);
            if (num === 1) {
              seq[pos++] = astForStmt(c, ch);
            } else {
              ch = CHILD(ch, 0);
              REQ(ch, SYM.simple_stmt);
              for (j = 0; j < NCH(ch); j += 2) {
                if (NCH(CHILD(ch, j)) === 0) {
                  Sk.asserts.assert(j + 1 === NCH(ch));
                  break;
                }
                seq[pos++] = astForStmt(c, CHILD(ch, j));
              }
            }
          }
        }
        Sk.asserts.assert(pos === numStmts(n));
        return seq;
      }
      function astForExceptClause(c, exc, body) {
        var e;
        REQ(exc, SYM.except_clause);
        REQ(body, SYM.suite);
        if (NCH(exc) === 1) {
          return new Sk.astnodes.ExceptHandler(
            null,
            null,
            astForSuite(c, body),
            exc.lineno,
            exc.col_offset,
            exc.end_lineno,
            exc.end_col_offset
          );
        } else if (NCH(exc) === 2) {
          return new Sk.astnodes.ExceptHandler(
            ast_for_expr(c, CHILD(exc, 1)),
            null,
            astForSuite(c, body),
            exc.lineno,
            exc.col_offset,
            exc.end_lineno,
            exc.end_col_offset
          );
        } else if (NCH(exc) === 4) {
          if (Sk.__future__.python3 && CHILD(exc, 2).value == ",") {
            ast_error(c, exc, "Old-style 'except' clauses are not supported in Python 3");
          }
          var expression = ast_for_expr(c, CHILD(exc, 1));
          e = ast_for_expr(c, CHILD(exc, 3));
          setContext(c, e, Sk.astnodes.Store, CHILD(exc, 3));
          return new Sk.astnodes.ExceptHandler(
            ast_for_expr(c, CHILD(exc, 1)),
            e,
            astForSuite(c, body),
            exc.lineno,
            exc.col_offset,
            exc.end_lineno,
            exc.end_col_offset
          );
        }
        Sk.asserts.fail("wrong number of children for except clause");
      }
      function astForTryStmt(c, n) {
        var exceptSt;
        var i;
        var handlers = [];
        var nc = NCH(n);
        var nexcept = (nc - 3) / 3;
        var body, orelse = [], finally_ = null;
        REQ(n, SYM.try_stmt);
        body = astForSuite(c, CHILD(n, 2));
        if (CHILD(n, nc - 3).type === TOK.T_NAME) {
          if (CHILD(n, nc - 3).value === "finally") {
            if (nc >= 9 && CHILD(n, nc - 6).type === TOK.T_NAME) {
              orelse = astForSuite(c, CHILD(n, nc - 4));
              nexcept--;
            }
            finally_ = astForSuite(c, CHILD(n, nc - 1));
            nexcept--;
          } else {
            orelse = astForSuite(c, CHILD(n, nc - 1));
            nexcept--;
          }
        } else if (CHILD(n, nc - 3).type !== SYM.except_clause) {
          throw new Sk.builtin.SyntaxError(
            "malformed 'try' statement",
            c.c_filename,
            ...get_context(n)
          );
        }
        if (nexcept > 0) {
          for (i = 0; i < nexcept; i++) {
            handlers[i] = astForExceptClause(c, CHILD(n, 3 + i * 3), CHILD(n, 5 + i * 3));
          }
        }
        Sk.asserts.assert(!!finally_ || handlers.length != 0);
        return new Sk.astnodes.Try(
          body,
          handlers,
          orelse,
          finally_,
          n.lineno,
          n.col_offset,
          n.end_lineno,
          n.end_col_offset
        );
      }
      function astForDottedName(c, n) {
        var i;
        var e;
        var id;
        var col_offset;
        var lineno;
        REQ(n, SYM.dotted_name);
        lineno = n.lineno;
        col_offset = n.col_offset;
        id = strobj(CHILD(n, 0).value);
        e = new Sk.astnodes.Name(
          id,
          Sk.astnodes.Load,
          lineno,
          col_offset,
          n.end_lineno,
          n.end_col_offset
        );
        for (i = 2; i < NCH(n); i += 2) {
          id = strobj(CHILD(n, i).value);
          e = new Sk.astnodes.Attribute(
            e,
            id,
            Sk.astnodes.Load,
            lineno,
            col_offset,
            n.end_lineno,
            n.end_col_offset
          );
        }
        return e;
      }
      function astForDecorator(c, n) {
        var nameExpr;
        REQ(n, SYM.decorator);
        REQ(CHILD(n, 0), TOK.T_AT);
        REQ(CHILD(n, NCH(n) - 1), TOK.T_NEWLINE);
        nameExpr = astForDottedName(c, CHILD(n, 1));
        if (NCH(n) === 3) {
          return nameExpr;
        } else if (NCH(n) === 5) {
          return new Sk.astnodes.Call(
            nameExpr,
            [],
            [],
            n.lineno,
            n.col_offset,
            n.end_lineno,
            n.end_col_offset
          );
        } else {
          return ast_for_call(c, CHILD(n, 3), nameExpr);
        }
      }
      function astForDecorators(c, n) {
        var i;
        var decoratorSeq;
        REQ(n, SYM.decorators);
        decoratorSeq = [];
        for (i = 0; i < NCH(n); ++i) {
          decoratorSeq[i] = astForDecorator(c, CHILD(n, i));
        }
        return decoratorSeq;
      }
      function ast_for_decorated(c, n) {
        var thing = null;
        var decorator_seq = null;
        REQ(n, SYM.decorated);
        decorator_seq = astForDecorators(c, CHILD(n, 0));
        Sk.asserts.assert(
          TYPE(CHILD(n, 1)) == SYM.funcdef || TYPE(CHILD(n, 1)) == SYM.async_funcdef || TYPE(CHILD(n, 1)) == SYM.classdef
        );
        if (TYPE(CHILD(n, 1)) == SYM.funcdef) {
          thing = ast_for_funcdef(c, CHILD(n, 1), decorator_seq);
        } else if (TYPE(CHILD(n, 1)) == SYM.classdef) {
          thing = astForClassdef(c, CHILD(n, 1), decorator_seq);
        } else if (TYPE(CHILD(n, 1)) == SYM.async_funcdef) {
          thing = ast_for_async_funcdef(c, CHILD(n, 1), decorator_seq);
        }
        if (thing) {
          thing.lineno = LINENO(n);
          thing.col_offset = n.col_offset;
        }
        return thing;
      }
      function ast_for_with_item(c, n) {
        var context_expr, optional_vars;
        REQ(n, SYM.with_item);
        context_expr = ast_for_expr(c, CHILD(n, 0));
        if (NCH(n) == 3) {
          optional_vars = ast_for_expr(c, CHILD(n, 2));
          setContext(c, optional_vars, Sk.astnodes.Store, n);
        }
        return new Sk.astnodes.withitem(context_expr, optional_vars);
      }
      function ast_for_with_stmt(c, n0, is_async) {
        const n = is_async ? CHILD(n0, 1) : n0;
        var i;
        var items = [], body;
        REQ(n, SYM.with_stmt);
        for (i = 1; i < NCH(n) - 2; i += 2) {
          var item = ast_for_with_item(c, CHILD(n, i));
          items[(i - 1) / 2] = item;
        }
        body = astForSuite(c, CHILD(n, NCH(n) - 1));
        if (is_async) {
          return new Sk.astnodes.AsyncWith(
            items,
            body,
            LINENO(n0),
            n0.col_offset,
            n0.end_lineno,
            n0.end_col_offset
          );
        } else {
          return new Sk.astnodes.With(
            items,
            body,
            LINENO(n),
            n.col_offset,
            n.end_lineno,
            n.end_col_offset
          );
        }
      }
      function astForIfStmt(c, n) {
        var off;
        var i;
        var orelse;
        var hasElse;
        var nElif;
        var decider;
        var s;
        REQ(n, SYM.if_stmt);
        if (NCH(n) === 4) {
          return new Sk.astnodes.If(
            ast_for_expr(c, CHILD(n, 1)),
            astForSuite(c, CHILD(n, 3)),
            [],
            n.lineno,
            n.col_offset,
            n.end_lineno,
            n.end_col_offset
          );
        }
        s = CHILD(n, 4).value;
        decider = s.charAt(2);
        if (decider === "s") {
          return new Sk.astnodes.If(
            ast_for_expr(c, CHILD(n, 1)),
            astForSuite(c, CHILD(n, 3)),
            astForSuite(c, CHILD(n, 6)),
            n.lineno,
            n.col_offset,
            n.end_lineno,
            n.end_col_offset
          );
        } else if (decider === "i") {
          nElif = NCH(n) - 4;
          hasElse = false;
          orelse = [];
          if (CHILD(n, nElif + 1).type === TOK.T_NAME && CHILD(n, nElif + 1).value.charAt(2) === "s") {
            hasElse = true;
            nElif -= 3;
          }
          nElif /= 4;
          if (hasElse) {
            orelse = [
              new Sk.astnodes.If(
                ast_for_expr(c, CHILD(n, NCH(n) - 6)),
                astForSuite(c, CHILD(n, NCH(n) - 4)),
                astForSuite(c, CHILD(n, NCH(n) - 1)),
                CHILD(n, NCH(n) - 6).lineno,
                CHILD(n, NCH(n) - 6).col_offset,
                CHILD(n, NCH(n) - 6).end_lineno,
                CHILD(n, NCH(n) - 6).end_col_offset
              )
            ];
            nElif--;
          }
          for (i = 0; i < nElif; ++i) {
            off = 5 + (nElif - i - 1) * 4;
            orelse = [
              new Sk.astnodes.If(
                ast_for_expr(c, CHILD(n, off)),
                astForSuite(c, CHILD(n, off + 2)),
                orelse,
                CHILD(n, off).lineno,
                CHILD(n, off).col_offset,
                CHILD(n, NCH(n) - 6).end_lineno,
                CHILD(n, NCH(n) - 6).end_col_offset
              )
            ];
          }
          return new Sk.astnodes.If(
            ast_for_expr(c, CHILD(n, 1)),
            astForSuite(c, CHILD(n, 3)),
            orelse,
            n.lineno,
            n.col_offset,
            n.end_lineno,
            n.end_col_offset
          );
        }
        Sk.asserts.fail("unexpected token in 'if' statement");
      }
      function ast_for_exprlist(c, n, context) {
        var e;
        var i;
        var seq;
        REQ(n, SYM.exprlist);
        seq = [];
        for (i = 0; i < NCH(n); i += 2) {
          e = ast_for_expr(c, CHILD(n, i));
          seq[i / 2] = e;
          if (context) {
            setContext(c, e, context, CHILD(n, i));
          }
        }
        return seq;
      }
      function astForDelStmt(c, n) {
        REQ(n, SYM.del_stmt);
        return new Sk.astnodes.Delete(
          ast_for_exprlist(c, CHILD(n, 1), Sk.astnodes.Del),
          n.lineno,
          n.col_offset,
          n.end_lineno,
          n.end_col_offset
        );
      }
      function astForGlobalStmt(c, n) {
        var i;
        var s = [];
        REQ(n, SYM.global_stmt);
        for (i = 1; i < NCH(n); i += 2) {
          s[(i - 1) / 2] = strobj(CHILD(n, i).value);
        }
        return new Sk.astnodes.Global(s, n.lineno, n.col_offset, n.end_lineno, n.end_col_offset);
      }
      function astForAssertStmt(c, n) {
        REQ(n, SYM.assert_stmt);
        if (NCH(n) === 2) {
          return new Sk.astnodes.Assert(
            ast_for_expr(c, CHILD(n, 1)),
            null,
            n.lineno,
            n.col_offset,
            n.end_lineno,
            n.end_col_offset
          );
        } else if (NCH(n) === 4) {
          return new Sk.astnodes.Assert(
            ast_for_expr(c, CHILD(n, 1)),
            ast_for_expr(c, CHILD(n, 3)),
            n.lineno,
            n.col_offset,
            n.end_lineno,
            n.end_col_offset
          );
        }
        Sk.asserts.fail("improper number of parts to assert stmt");
      }
      function aliasForImportName(c, n) {
        var i;
        var a;
        var name;
        var str;
        loop: while (true) {
          switch (n.type) {
            case SYM.import_as_name:
              str = null;
              name = strobj(CHILD(n, 0).value);
              if (NCH(n) === 3) {
                str = CHILD(n, 2).value;
              }
              return new Sk.astnodes.alias(name, str == null ? null : strobj(str));
            case SYM.dotted_as_name:
              if (NCH(n) === 1) {
                n = CHILD(n, 0);
                continue loop;
              } else {
                a = aliasForImportName(c, CHILD(n, 0));
                Sk.asserts.assert(!a.asname);
                a.asname = strobj(CHILD(n, 2).value);
                return a;
              }
              break;
            case SYM.dotted_name:
              if (NCH(n) === 1) {
                return new Sk.astnodes.alias(strobj(CHILD(n, 0).value), null);
              } else {
                str = "";
                for (i = 0; i < NCH(n); i += 2) {
                  str += CHILD(n, i).value + ".";
                }
                return new Sk.astnodes.alias(strobj(str.substr(0, str.length - 1)), null);
              }
              break;
            case TOK.T_STAR:
              return new Sk.astnodes.alias(strobj("*"), null);
            default:
              throw new Sk.builtin.SyntaxError(
                "unexpected import name",
                c.c_filename,
                ...get_context(n)
              );
          }
          break;
        }
      }
      function astForImportStmt(c, n) {
        var modname;
        var idx;
        var nchildren;
        var ndots;
        var mod;
        var i;
        var aliases;
        var col_offset;
        var lineno;
        var end_lineno;
        var end_col_offset;
        REQ(n, SYM.import_stmt);
        lineno = n.lineno;
        col_offset = n.col_offset;
        end_lineno = n.end_lineno;
        end_col_offset = n.end_col_offset;
        n = CHILD(n, 0);
        if (n.type === SYM.import_name) {
          n = CHILD(n, 1);
          REQ(n, SYM.dotted_as_names);
          aliases = [];
          for (i = 0; i < NCH(n); i += 2) {
            aliases[i / 2] = aliasForImportName(c, CHILD(n, i));
          }
          return new Sk.astnodes.Import(aliases, lineno, col_offset, end_lineno, end_col_offset);
        } else if (n.type === SYM.import_from) {
          mod = null;
          ndots = 0;
          for (idx = 1; idx < NCH(n); ++idx) {
            if (CHILD(n, idx).type === SYM.dotted_name) {
              mod = aliasForImportName(c, CHILD(n, idx));
              idx++;
              break;
            } else if (CHILD(n, idx).type === TOK.T_DOT) {
              ndots++;
            } else if (CHILD(n, idx).type === TOK.T_ELLIPSIS) {
              ndots += 3;
            } else {
              break;
            }
          }
          ++idx;
          switch (CHILD(n, idx).type) {
            case TOK.T_STAR:
              n = CHILD(n, idx);
              nchildren = 1;
              break;
            case TOK.T_LPAR:
              n = CHILD(n, idx + 1);
              nchildren = NCH(n);
              break;
            case SYM.import_as_names:
              n = CHILD(n, idx);
              nchildren = NCH(n);
              if (nchildren % 2 === 0) {
                throw new Sk.builtin.SyntaxError(
                  "trailing comma not allowed without surrounding parentheses",
                  c.c_filename,
                  ...get_context(n)
                );
              }
              break;
            default:
              throw new Sk.builtin.SyntaxError(
                "Unexpected node-type in from-import",
                c.c_filename,
                ...get_context(n)
              );
          }
          aliases = [];
          if (n.type === TOK.T_STAR) {
            aliases[0] = aliasForImportName(c, n);
          } else {
            for (i = 0; i < NCH(n); i += 2) {
              aliases[i / 2] = aliasForImportName(c, CHILD(n, i));
            }
          }
          modname = mod ? mod.name.v : "";
          return new Sk.astnodes.ImportFrom(
            strobj(modname),
            aliases,
            ndots,
            lineno,
            col_offset,
            end_lineno,
            end_col_offset
          );
        }
        throw new Sk.builtin.SyntaxError("unknown import statement", c.c_filename, ...get_context(n));
      }
      function ast_for_genexp(c, n) {
        Sk.asserts.assert(TYPE(n) == SYM.testlist_comp || TYPE(n) == SYM.argument);
        return ast_for_itercomp(c, n, COMP_GENEXP);
      }
      function ast_for_listcomp(c, n) {
        Sk.asserts.assert(TYPE(n) == SYM.testlist_comp);
        return ast_for_itercomp(c, n, COMP_LISTCOMP);
      }
      function astForFactor(c, n) {
        var expression;
        var pnum;
        var patom;
        var ppower;
        var pfactor;
        if (CHILD(n, 0).type === TOK.T_MINUS && NCH(n) === 2) {
          pfactor = CHILD(n, 1);
          if (pfactor.type === SYM.factor && NCH(pfactor) === 1) {
            ppower = CHILD(pfactor, 0);
            if (ppower.type === SYM.power && NCH(ppower) === 1) {
              patom = CHILD(ppower, 0);
              if (patom.type === SYM.atom) {
                pnum = CHILD(patom, 0);
                if (pnum.type === TOK.T_NUMBER) {
                  pnum.value = "-" + pnum.value;
                  return ast_for_atom(c, patom);
                }
              }
            }
          }
        }
        expression = ast_for_expr(c, CHILD(n, 1));
        switch (CHILD(n, 0).type) {
          case TOK.T_PLUS:
            return new Sk.astnodes.UnaryOp(
              Sk.astnodes.UAdd,
              expression,
              n.lineno,
              n.col_offset,
              n.end_lineno,
              n.end_col_offset
            );
          case TOK.T_MINUS:
            return new Sk.astnodes.UnaryOp(
              Sk.astnodes.USub,
              expression,
              n.lineno,
              n.col_offset,
              n.end_lineno,
              n.end_col_offset
            );
          case TOK.T_TILDE:
            return new Sk.astnodes.UnaryOp(
              Sk.astnodes.Invert,
              expression,
              n.lineno,
              n.col_offset,
              n.end_lineno,
              n.end_col_offset
            );
        }
        Sk.asserts.fail("unhandled factor");
      }
      function astForForStmt(c, n) {
        var target;
        var _target;
        var nodeTarget;
        var seq = [];
        REQ(n, SYM.for_stmt);
        if (NCH(n) === 9) {
          seq = astForSuite(c, CHILD(n, 8));
        }
        nodeTarget = CHILD(n, 1);
        _target = ast_for_exprlist(c, nodeTarget, Sk.astnodes.Store);
        if (NCH(nodeTarget) === 1) {
          target = _target[0];
        } else {
          target = new Sk.astnodes.Tuple(
            _target,
            Sk.astnodes.Store,
            n.lineno,
            n.col_offset,
            n.end_lineno,
            n.end_col_offset
          );
        }
        return new Sk.astnodes.For(
          target,
          ast_for_testlist(c, CHILD(n, 3)),
          astForSuite(c, CHILD(n, 5)),
          seq,
          n.lineno,
          n.col_offset,
          n.end_lineno,
          n.end_col_offset
        );
      }
      function ast_for_call(c, n, func, allowgen) {
        var i, nargs, nkeywords;
        var ndoublestars;
        var args;
        var keywords;
        REQ(n, SYM.arglist);
        nargs = 0;
        nkeywords = 0;
        for (i = 0; i < NCH(n); i++) {
          var ch = CHILD(n, i);
          if (TYPE(ch) == SYM.argument) {
            if (NCH(ch) == 1) {
              nargs++;
            } else if (TYPE(CHILD(ch, 1)) == SYM.comp_for) {
              nargs++;
              if (!allowgen) {
                ast_error(c, ch, "invalid syntax");
              }
              if (NCH(n) > 1) {
                ast_error(c, ch, "Generator expression must be parenthesized");
              }
            } else if (TYPE(CHILD(ch, 0)) == TOK.T_STAR) {
              nargs++;
            } else {
              nkeywords++;
            }
          }
        }
        args = [];
        keywords = [];
        nargs = 0;
        nkeywords = 0;
        ndoublestars = 0;
        for (i = 0; i < NCH(n); i++) {
          ch = CHILD(n, i);
          if (TYPE(ch) == SYM.argument) {
            var e;
            var chch = CHILD(ch, 0);
            if (NCH(ch) == 1) {
              if (nkeywords) {
                if (ndoublestars) {
                  ast_error(
                    c,
                    chch,
                    "positional argument follows keyword argument unpacking"
                  );
                } else {
                  ast_error(c, chch, "positional argument follows keyword argument");
                }
              }
              e = ast_for_expr(c, chch);
              if (!e) {
                return NULL;
              }
              args[nargs++] = e;
            } else if (TYPE(chch) == TOK.T_STAR) {
              var starred;
              if (ndoublestars) {
                ast_error(
                  c,
                  chch,
                  "iterable argument unpacking follows keyword argument unpacking"
                );
                return NULL;
              }
              e = ast_for_expr(c, CHILD(ch, 1));
              if (!e) {
                return NULL;
              }
              starred = new Sk.astnodes.Starred(
                e,
                Sk.astnodes.Load,
                LINENO(chch),
                chch.col_offset,
                chch.end_lineno,
                chch.end_col_offset
              );
              args[nargs++] = starred;
            } else if (TYPE(chch) == TOK.T_DOUBLESTAR) {
              var kw;
              i++;
              e = ast_for_expr(c, CHILD(ch, 1));
              if (!e) {
                return NULL;
              }
              kw = new Sk.astnodes.keyword(NULL, e);
              keywords[nkeywords++] = kw;
              ndoublestars++;
            } else if (TYPE(CHILD(ch, 1)) == SYM.comp_for) {
              e = ast_for_genexp(c, ch);
              if (!e) {
                return NULL;
              }
              args[nargs++] = e;
            } else {
              var kw;
              var key, tmp;
              var k;
              e = ast_for_expr(c, chch);
              if (!e) {
                return NULL;
              }
              if (e.constructor === Sk.astnodes.Lambda) {
                ast_error(c, chch, "lambda cannot contain assignment");
                return NULL;
              } else if (e.constructor !== Sk.astnodes.Name) {
                ast_error(c, chch, "keyword can't be an expression");
                return NULL;
              } else if (forbiddenCheck(c, e.id, ch, 1)) {
                return NULL;
              }
              key = e.id;
              for (k = 0; k < nkeywords; k++) {
                tmp = keywords[k].arg;
                if (tmp && tmp === key) {
                  ast_error(c, chch, "keyword argument repeated");
                  return NULL;
                }
              }
              e = ast_for_expr(c, CHILD(ch, 2));
              if (!e) {
                return NULL;
              }
              kw = new Sk.astnodes.keyword(key, e);
              keywords[nkeywords++] = kw;
            }
          }
        }
        return new Sk.astnodes.Call(
          func,
          args,
          keywords,
          func.lineno,
          func.col_offset,
          func.end_lineno,
          func.end_col_offset
        );
      }
      function ast_for_trailer(c, n, left_expr) {
        REQ(n, SYM.trailer);
        if (TYPE(CHILD(n, 0)) == TOK.T_LPAR) {
          if (NCH(n) == 2) {
            return new Sk.astnodes.Call(
              left_expr,
              NULL,
              NULL,
              LINENO(n),
              n.col_offset,
              n.end_lineno,
              n.end_col_offset
            );
          } else {
            return ast_for_call(c, CHILD(n, 1), left_expr, true);
          }
        } else if (TYPE(CHILD(n, 0)) == TOK.T_DOT) {
          var attr_id = new_identifier(CHILD(n, 1));
          if (!attr_id) {
            return NULL;
          }
          return new Sk.astnodes.Attribute(
            left_expr,
            attr_id,
            Sk.astnodes.Load,
            LINENO(n),
            n.col_offset,
            n.end_lineno,
            n.end_col_offset
          );
        } else {
          REQ(CHILD(n, 0), TOK.T_LSQB);
          REQ(CHILD(n, 2), TOK.T_RSQB);
          n = CHILD(n, 1);
          if (NCH(n) == 1) {
            var slc = astForSlice(c, CHILD(n, 0));
            if (!slc) {
              return NULL;
            }
            return new Sk.astnodes.Subscript(
              left_expr,
              slc,
              Sk.astnodes.Load,
              LINENO(n),
              n.col_offset,
              n.end_lineno,
              n.end_col_offset
            );
          } else {
            var j;
            var slc;
            var e;
            var simple = 1;
            var slices = [], elts;
            for (j = 0; j < NCH(n); j += 2) {
              slc = astForSlice(c, CHILD(n, j));
              if (!slc) {
                return NULL;
              }
              if (slc.kind != _slice_kind.Index_kind) {
                simple = 0;
              }
              slices[j / 2] = slc;
            }
            if (!simple) {
              return new Sk.astnodes.Subscript(
                left_expr,
                new Sk.astnodes.ExtSlice(slices),
                Sk.astnodes.Load,
                LINENO(n),
                n.col_offset,
                n.end_lineno,
                n.end_col_offset
              );
            }
            elts = [];
            for (j = 0; j < slices.length; ++j) {
              slc = slices[j];
              Sk.asserts.assert(slc.kind == _slice_kind.Index_kind && slc.v.Index.value);
              elts[j] = slc.v.Index.value;
            }
            e = new Sk.astnodes.Tuple(
              elts,
              Sk.astnodes.Load,
              LINENO(n),
              n.col_offset,
              n.end_lineno,
              n.end_col_offset
            );
            return new Sk.astnodes.Subscript(
              left_expr,
              new Sk.astnodes.Index(e),
              Sk.astnodes.Load,
              LINENO(n),
              n.col_offset,
              n.end_lineno,
              n.end_col_offset
            );
          }
        }
      }
      function ast_for_flow_stmt(c, n) {
        var ch;
        REQ(n, SYM.flow_stmt);
        ch = CHILD(n, 0);
        switch (TYPE(ch)) {
          case SYM.break_stmt:
            return new Sk.astnodes.Break(LINENO(n), n.col_offset, n.end_lineno, n.end_col_offset);
          case SYM.continue_stmt:
            return new Sk.astnodes.Continue(
              LINENO(n),
              n.col_offset,
              n.end_lineno,
              n.end_col_offset
            );
          case SYM.yield_stmt: {
            var exp = ast_for_expr(c, CHILD(ch, 0));
            if (!exp) {
              return null;
            }
            return new Sk.astnodes.Expr(
              exp,
              LINENO(n),
              n.col_offset,
              n.end_lineno,
              n.end_col_offset
            );
          }
          case SYM.return_stmt:
            if (NCH(ch) == 1) {
              return new Sk.astnodes.Return(
                null,
                LINENO(n),
                n.col_offset,
                n.end_lineno,
                n.end_col_offset
              );
            } else {
              var expression = ast_for_testlist(c, CHILD(ch, 1));
              if (!expression) {
                return null;
              }
              return new Sk.astnodes.Return(
                expression,
                LINENO(n),
                n.col_offset,
                n.end_lineno,
                n.end_col_offset
              );
            }
          case SYM.raise_stmt:
            if (NCH(ch) == 1) {
              return new Sk.astnodes.Raise(
                null,
                null,
                null,
                null,
                LINENO(n),
                n.col_offset,
                n.end_lineno,
                n.end_col_offset
              );
            } else if (NCH(ch) >= 2) {
              var cause = null;
              var expression = ast_for_expr(c, CHILD(ch, 1));
              var inst = null, tback = null;
              if (NCH(ch) == 4 && CHILD(ch, 2).value == "from") {
                if (!Sk.__future__.python3) {
                  ast_error(
                    c,
                    CHILD(ch, 2),
                    "raise ... from ... is not available in Python 2"
                  );
                }
                cause = ast_for_expr(c, CHILD(ch, 3));
              } else if (NCH(ch) >= 4 && CHILD(ch, 2).value == ",") {
                if (Sk.__future__.python3) {
                  ast_error(c, n, "Old raise syntax is not available in Python 3");
                }
                inst = ast_for_expr(c, CHILD(ch, 3));
                if (NCH(ch) == 6) {
                  tback = ast_for_expr(c, CHILD(ch, 5));
                }
              }
              return new Sk.astnodes.Raise(
                expression,
                cause,
                inst,
                tback,
                LINENO(n),
                n.col_offset,
                n.end_lineno,
                n.end_col_offset
              );
            }
          /* fall through */
          default:
            Sk.asserts.fail("unexpected flow_stmt: ", TYPE(ch));
            return null;
        }
      }
      function astForArg(c, n) {
        var name;
        var annotation = null;
        var ch;
        Sk.asserts.assert(n.type === SYM.tfpdef || n.type === SYM.vfpdef);
        ch = CHILD(n, 0);
        forbiddenCheck(c, ch, ch.value, ch.lineno);
        name = strobj(ch.value);
        if (NCH(n) == 3 && CHILD(n, 1).type === TOK.T_COLON) {
          annotation = ast_for_expr(c, CHILD(n, 2));
        }
        return new Sk.astnodes.arg(
          name,
          annotation,
          n.lineno,
          n.col_offset,
          n.end_lineno,
          n.end_col_offset
        );
      }
      function handleKeywordonlyArgs(c, n, start, kwonlyargs, kwdefaults) {
        var argname;
        var ch;
        var expression;
        var annotation;
        var arg;
        var i = start;
        var j = 0;
        if (!kwonlyargs) {
          ast_error(c, CHILD(n, start), "named arguments must follow bare *");
        }
        Sk.asserts.assert(kwdefaults);
        while (i < NCH(n)) {
          ch = CHILD(n, i);
          switch (ch.type) {
            case SYM.vfpdef:
            case SYM.tfpdef:
              if (i + 1 < NCH(n) && CHILD(n, i + 1).type == TOK.T_EQUAL) {
                kwdefaults[j] = ast_for_expr(c, CHILD(n, i + 2));
                i += 2;
              } else {
                kwdefaults[j] = null;
              }
              if (NCH(ch) == 3) {
                annotation = ast_for_expr(c, CHILD(ch, 2));
              } else {
                annotation = null;
              }
              ch = CHILD(ch, 0);
              forbiddenCheck(c, ch, ch.value, ch.lineno);
              argname = strobj(ch.value);
              kwonlyargs[j++] = new Sk.astnodes.arg(
                argname,
                annotation,
                ch.lineno,
                ch.col_offset,
                ch.end_lineno,
                ch.end_col_offset
              );
              i += 2;
              break;
            case TOK.T_DOUBLESTAR:
              return i;
            default:
              ast_error(c, ch, "unexpected node");
          }
        }
        return i;
      }
      function astForArguments(c, n) {
        var k;
        var j;
        var i;
        var foundDefault;
        var posargs = [];
        var posdefaults = [];
        var kwonlyargs = [];
        var kwdefaults = [];
        var vararg = null;
        var kwarg = null;
        var ch = null;
        if (n.type === SYM.parameters) {
          if (NCH(n) === 2) {
            return new Sk.astnodes.arguments_([], null, [], [], null, []);
          }
          n = CHILD(n, 1);
        }
        Sk.asserts.assert(n.type === SYM.varargslist || n.type === SYM.typedargslist);
        i = 0;
        j = 0;
        k = 0;
        while (i < NCH(n)) {
          ch = CHILD(n, i);
          switch (ch.type) {
            case SYM.tfpdef:
            case SYM.vfpdef:
              if (i + 1 < NCH(n) && CHILD(n, i + 1).type == TOK.T_EQUAL) {
                posdefaults[j++] = ast_for_expr(c, CHILD(n, i + 2));
                i += 2;
                foundDefault = 1;
              } else if (foundDefault) {
                throw new Sk.builtin.SyntaxError(
                  "non-default argument follows default argument",
                  c.c_filename,
                  ...get_context(n)
                );
              }
              posargs[k++] = astForArg(c, ch);
              i += 2;
              break;
            case TOK.T_STAR:
              if (i + 1 >= NCH(n) || i + 2 == NCH(n) && CHILD(n, i + 1).type == TOK.T_COMMA) {
                throw new Sk.builtin.SyntaxError(
                  "named arguments must follow bare *",
                  c.c_filename,
                  ...get_context(n)
                );
              }
              ch = CHILD(n, i + 1);
              if (ch.type == TOK.T_COMMA) {
                i += 2;
                i = handleKeywordonlyArgs(c, n, i, kwonlyargs, kwdefaults);
              } else {
                vararg = astForArg(c, ch);
                i += 3;
                if (i < NCH(n) && (CHILD(n, i).type == SYM.tfpdef || CHILD(n, i).type == SYM.vfpdef)) {
                  i = handleKeywordonlyArgs(c, n, i, kwonlyargs, kwdefaults);
                }
              }
              break;
            case TOK.T_DOUBLESTAR:
              ch = CHILD(n, i + 1);
              Sk.asserts.assert(ch.type == SYM.tfpdef || ch.type == SYM.vfpdef);
              kwarg = astForArg(c, ch);
              i += 3;
              break;
            default:
              Sk.asserts.fail("unexpected node in varargslist");
              return;
          }
        }
        return new Sk.astnodes.arguments_(posargs, vararg, kwonlyargs, kwdefaults, kwarg, posdefaults);
      }
      function ast_for_async_funcdef(c, n, decorator_seq) {
        REQ(n, SYM.async_funcdef);
        REQ(CHILD(n, 0), TOK.T_NAME);
        Sk.asserts.assert(STR(CHILD(n, 0) === "async"));
        REQ(CHILD(n, 1), SYM.funcdef);
        return ast_for_funcdef_impl(
          c,
          n,
          decorator_seq,
          true
          /* is_async */
        );
      }
      function ast_for_funcdef(c, n, decorator_seq) {
        return ast_for_funcdef_impl(
          c,
          n,
          decorator_seq,
          false
          /* is_async */
        );
      }
      function ast_for_funcdef_impl(c, n0, decorator_seq, is_async) {
        var n = is_async ? CHILD(n0, 1) : n0;
        var name;
        var args;
        var body;
        var returns = NULL;
        var name_i = 1;
        var end_lineno, end_col_offset;
        var tc;
        var type_comment = NULL;
        if (is_async && c.c_feature_version < 5) {
          ast_error(c, n, "Async functions are only supported in Python 3.5 and greater");
          return NULL;
        }
        REQ(n, SYM.funcdef);
        name = new_identifier(CHILD(n, name_i));
        if (forbiddenCheck(c, name, CHILD(n, name_i), 0)) {
          return NULL;
        }
        args = astForArguments(c, CHILD(n, name_i + 1));
        if (!args) {
          return NULL;
        }
        if (TYPE(CHILD(n, name_i + 2)) == TOK.T_RARROW) {
          returns = ast_for_expr(c, CHILD(n, name_i + 3));
          if (!returns) {
            return NULL;
          }
          name_i += 2;
        }
        if (TYPE(CHILD(n, name_i + 3)) == TOK.T_TYPE_COMMENT) {
          type_comment = TOK.T_NEW_TYPE_COMMENT(CHILD(n, name_i + 3));
          if (!type_comment) {
            return NULL;
          }
          name_i += 1;
        }
        body = astForSuite(c, CHILD(n, name_i + 3));
        if (!body) {
          return NULL;
        }
        if (NCH(CHILD(n, name_i + 3)) > 1) {
          tc = CHILD(CHILD(n, name_i + 3), 1);
          if (TYPE(tc) == TOK.T_TYPE_COMMENT) {
            if (type_comment != NULL) {
              ast_error(c, n, "Cannot have two type comments on def");
              return NULL;
            }
            type_comment = TOK.T_NEW_TYPE_COMMENT(tc);
            if (!type_comment) {
              return NULL;
            }
          }
        }
        if (is_async) {
          return new Sk.astnodes.AsyncFunctionDef(
            name,
            args,
            body,
            decorator_seq,
            returns,
            type_comment,
            LINENO(n0),
            n0.col_offset,
            n0.end_lineno,
            n0.end_col_offset
          );
        } else {
          return new Sk.astnodes.FunctionDef(
            name,
            args,
            body,
            decorator_seq,
            returns,
            type_comment,
            LINENO(n),
            n.col_offset,
            n.end_lineno,
            n.end_col_offset
          );
        }
      }
      function astForClassdef(c, n, decoratorSeq) {
        var classname;
        var call;
        var s;
        REQ(n, SYM.classdef);
        if (NCH(n) == 4) {
          s = astForSuite(c, CHILD(n, 3));
          classname = new_identifier(CHILD(n, 1).value);
          forbiddenCheck(c, CHILD(n, 3), classname, n.lineno);
          return new Sk.astnodes.ClassDef(
            classname,
            [],
            [],
            s,
            decoratorSeq,
            /*TODO docstring*/
            null,
            LINENO(n),
            n.col_offset,
            n.end_lineno,
            n.end_col_offset
          );
        }
        if (TYPE(CHILD(n, 3)) === TOK.T_RPAR) {
          s = astForSuite(c, CHILD(n, 5));
          classname = new_identifier(CHILD(n, 1).value);
          forbiddenCheck(c, CHILD(n, 3), classname, CHILD(n, 3).lineno);
          return new Sk.astnodes.ClassDef(
            classname,
            [],
            [],
            s,
            decoratorSeq,
            /*TODO docstring*/
            null,
            LINENO(n),
            n.col_offset,
            n.end_lineno,
            n.end_col_offset
          );
        }
        {
          var dummy_name;
          var dummy;
          dummy_name = new_identifier(CHILD(n, 1));
          dummy = new Sk.astnodes.Name(
            dummy_name,
            Sk.astnodes.Load,
            LINENO(n),
            n.col_offset,
            n.end_lineno,
            n.end_col_offset
          );
          call = ast_for_call(c, CHILD(n, 3), dummy, false);
        }
        s = astForSuite(c, CHILD(n, 6));
        classname = new_identifier(CHILD(n, 1).value);
        forbiddenCheck(c, CHILD(n, 1), classname, CHILD(n, 1).lineno);
        return new Sk.astnodes.ClassDef(
          classname,
          call.args,
          call.keywords,
          s,
          decoratorSeq,
          /*TODO docstring*/
          null,
          LINENO(n),
          n.col_offset,
          n.end_lineno,
          n.end_col_offset
        );
      }
      function astForLambdef(c, n) {
        var args;
        var expression;
        if (NCH(n) === 3) {
          args = new Sk.astnodes.arguments_([], null, null, []);
          expression = ast_for_expr(c, CHILD(n, 2));
        } else {
          args = astForArguments(c, CHILD(n, 1));
          expression = ast_for_expr(c, CHILD(n, 3));
        }
        return new Sk.astnodes.Lambda(
          args,
          expression,
          n.lineno,
          n.col_offset,
          n.end_lineno,
          n.end_col_offset
        );
      }
      function astForComprehension(c, n) {
        var j;
        var ifs;
        var nifs;
        var ge;
        var expression;
        var t;
        var forch;
        var i;
        var ch;
        var genexps;
        var nfors;
        var elt;
        var comps;
        var comp;
        function countCompFors(c2, n2) {
          var nfors2 = 0;
          count_comp_for: while (true) {
            nfors2++;
            REQ(n2, SYM.comp_for);
            if (NCH(n2) === 5) {
              n2 = CHILD(n2, 4);
            } else {
              return nfors2;
            }
            count_comp_iter: while (true) {
              REQ(n2, SYM.comp_iter);
              n2 = CHILD(n2, 0);
              if (n2.type === SYM.comp_for) {
                continue count_comp_for;
              } else if (n2.type === SYM.comp_if) {
                if (NCH(n2) === 3) {
                  n2 = CHILD(n2, 2);
                  continue count_comp_iter;
                } else {
                  return nfors2;
                }
              }
              break;
            }
            break;
          }
          Sk.asserts.fail("logic error in countCompFors");
        }
        function countCompIfs(c2, n2) {
          var nifs2 = 0;
          while (true) {
            REQ(n2, SYM.comp_iter);
            if (CHILD(n2, 0).type === SYM.comp_for) {
              return nifs2;
            }
            n2 = CHILD(n2, 0);
            REQ(n2, SYM.comp_if);
            nifs2++;
            if (NCH(n2) === 2) {
              return nifs2;
            }
            n2 = CHILD(n2, 2);
          }
        }
        nfors = countCompFors(c, n);
        comps = [];
        for (i = 0; i < nfors; ++i) {
          REQ(n, SYM.comp_for);
          forch = CHILD(n, 1);
          t = ast_for_exprlist(c, forch, Sk.astnodes.Store);
          expression = ast_for_expr(c, CHILD(n, 3));
          if (NCH(forch) === 1) {
            comp = new Sk.astnodes.comprehension(t[0], expression, []);
          } else {
            comp = new Sk.astnodes.comprehension(
              new Sk.astnodes.Tuple(
                t,
                Sk.astnodes.Store,
                n.lineno,
                n.col_offset,
                n.end_lineno,
                n.end_col_offset
              ),
              expression,
              []
            );
          }
          if (NCH(n) === 5) {
            n = CHILD(n, 4);
            nifs = countCompIfs(c, n);
            ifs = [];
            for (j = 0; j < nifs; ++j) {
              REQ(n, SYM.comp_iter);
              n = CHILD(n, 0);
              REQ(n, SYM.comp_if);
              expression = ast_for_expr(c, CHILD(n, 1));
              ifs[j] = expression;
              if (NCH(n) === 3) {
                n = CHILD(n, 2);
              }
            }
            if (n.type === SYM.comp_iter) {
              n = CHILD(n, 0);
            }
            comp.ifs = ifs;
          }
          comps[i] = comp;
        }
        return comps;
      }
      function astForIterComp(c, n, type) {
        var elt, comps;
        Sk.asserts.assert(NCH(n) > 1);
        elt = ast_for_expr(c, CHILD(n, 0));
        comps = astForComprehension(c, CHILD(n, 1));
        if (type === COMP_GENEXP) {
          return new Sk.astnodes.GeneratorExp(
            elt,
            comps,
            n.lineno,
            n.col_offset,
            n.end_lineno,
            n.end_col_offset
          );
        } else if (type === COMP_SETCOMP) {
          return new Sk.astnodes.SetComp(
            elt,
            comps,
            n.lineno,
            n.col_offset,
            n.end_lineno,
            n.end_col_offset
          );
        }
      }
      function count_comp_fors(c, n) {
        var n_fors = 0;
        var is_async;
        count_comp_for: while (true) {
          is_async = 0;
          n_fors++;
          REQ(n, SYM.comp_for);
          if (TYPE(CHILD(n, 0)) == TOK.T_ASYNC) {
            is_async = 1;
          }
          if (NCH(n) == 5 + is_async) {
            n = CHILD(n, 4 + is_async);
          } else {
            return n_fors;
          }
          count_comp_iter: while (true) {
            REQ(n, SYM.comp_iter);
            n = CHILD(n, 0);
            if (TYPE(n) === SYM.comp_for) {
              continue count_comp_for;
            } else if (TYPE(n) === SYM.comp_if) {
              if (NCH(n) === 3) {
                n = CHILD(n, 2);
                continue count_comp_iter;
              } else {
                return n_fors;
              }
            }
            break;
          }
          break;
        }
      }
      function count_comp_ifs(c, n) {
        var n_ifs = 0;
        while (true) {
          REQ(n, SYM.comp_iter);
          if (TYPE(CHILD(n, 0)) == SYM.comp_for) {
            return n_ifs;
          }
          n = CHILD(n, 0);
          REQ(n, SYM.comp_if);
          n_ifs++;
          if (NCH(n) == 2) {
            return n_ifs;
          }
          n = CHILD(n, 2);
        }
      }
      function ast_for_comprehension(c, n) {
        var i, n_fors;
        var comps = [];
        n_fors = count_comp_fors(c, n);
        for (i = 0; i < n_fors; i++) {
          var comp;
          var t;
          var expression, first;
          var for_ch;
          var is_async = 0;
          if (TYPE(CHILD(n, 0)) == TOK.T_ASYNC) {
            is_async = 1;
          }
          for_ch = CHILD(n, 1 + is_async);
          t = ast_for_exprlist(c, for_ch, Sk.astnodes.Store);
          if (!t) {
            return null;
          }
          expression = ast_for_expr(c, CHILD(n, 3 + is_async));
          if (!expression) {
            return null;
          }
          first = t[0];
          if (NCH(for_ch) == 1) {
            comp = new Sk.astnodes.comprehension(first, expression, null, is_async);
          } else {
            comp = new Sk.astnodes.comprehension(
              new Sk.astnodes.Tuple(
                t,
                Sk.astnodes.Store,
                first.lineno,
                first.col_offset,
                for_ch.end_lineno,
                for_ch.end_col_offset
              ),
              expression,
              null,
              is_async
            );
          }
          if (NCH(n) == 5 + is_async) {
            var j, n_ifs;
            var ifs = [];
            n = CHILD(n, 4 + is_async);
            n_ifs = count_comp_ifs(c, n);
            if (n_ifs == -1) {
              return null;
            }
            for (j = 0; j < n_ifs; j++) {
              REQ(n, SYM.comp_iter);
              n = CHILD(n, 0);
              REQ(n, SYM.comp_if);
              expression = ast_for_expr(c, CHILD(n, 1));
              if (!expression) {
                return null;
              }
              ifs[j] = expression;
              if (NCH(n) == 3) {
                n = CHILD(n, 2);
              }
            }
            if (TYPE(n) == SYM.comp_iter) {
              n = CHILD(n, 0);
            }
            comp.ifs = ifs;
          }
          comps[i] = comp;
        }
        return comps;
      }
      function ast_for_itercomp(c, n, type) {
        var elt;
        var comps;
        var ch;
        Sk.asserts.assert(NCH(n) > 1);
        ch = CHILD(n, 0);
        elt = ast_for_expr(c, ch);
        if (elt.constructor === Sk.astnodes.Starred) {
          ast_error(c, ch, "iterable unpacking cannot be used in comprehension");
          return NULL;
        }
        comps = ast_for_comprehension(c, CHILD(n, 1));
        if (type == COMP_GENEXP) {
          return new Sk.astnodes.GeneratorExp(
            elt,
            comps,
            LINENO(n),
            n.col_offset,
            n.end_lineno,
            n.end_col_offset
          );
        } else if (type == COMP_LISTCOMP) {
          return new Sk.astnodes.ListComp(
            elt,
            comps,
            LINENO(n),
            n.col_offset,
            n.end_lineno,
            n.end_col_offset
          );
        } else if (type == COMP_SETCOMP) {
          return new Sk.astnodes.SetComp(
            elt,
            comps,
            LINENO(n),
            n.col_offset,
            n.end_lineno,
            n.end_col_offset
          );
        } else {
          return null;
        }
      }
      function ast_for_dictelement(c, n, i) {
        var expression;
        if (TYPE(CHILD(n, i)) == TOK.T_DOUBLESTAR) {
          Sk.asserts.assert(NCH(n) - i >= 2);
          expression = ast_for_expr(c, CHILD(n, i + 1));
          return { key: null, value: expression, i: i + 2 };
        } else {
          Sk.asserts.assert(NCH(n) - i >= 3);
          expression = ast_for_expr(c, CHILD(n, i));
          if (!expression) {
            return 0;
          }
          var key = expression;
          REQ(CHILD(n, i + 1), TOK.T_COLON);
          expression = ast_for_expr(c, CHILD(n, i + 2));
          if (!expression) {
            return false;
          }
          var value = expression;
          return { key, value, i: i + 3 };
        }
      }
      function ast_for_dictcomp(c, n) {
        var key, value;
        var comps = [];
        Sk.asserts.assert(NCH(n) > 3);
        REQ(CHILD(n, 1), TOK.T_COLON);
        key = ast_for_expr(c, CHILD(n, 0));
        value = ast_for_expr(c, CHILD(n, 2));
        comps = astForComprehension(c, CHILD(n, 3));
        return new Sk.astnodes.DictComp(
          key,
          value,
          comps,
          n.lineno,
          n.col_offset,
          n.end_lineno,
          n.end_col_offset
        );
      }
      function ast_for_dictdisplay(c, n) {
        var i;
        var j;
        var keys = [], values = [];
        j = 0;
        for (i = 0; i < NCH(n); i++) {
          var res = ast_for_dictelement(c, n, i);
          i = res.i;
          keys[j] = res.key;
          values[j] = res.value;
          j++;
        }
        return new Sk.astnodes.Dict(
          keys,
          values,
          LINENO(n),
          n.col_offset,
          n.end_lineno,
          n.end_col_offset
        );
      }
      function ast_for_setcomp(c, n) {
        Sk.asserts.assert(n.type === SYM.dictorsetmaker);
        return astForIterComp(c, n, COMP_SETCOMP);
      }
      function astForWhileStmt(c, n) {
        REQ(n, SYM.while_stmt);
        if (NCH(n) === 4) {
          return new Sk.astnodes.While(
            ast_for_expr(c, CHILD(n, 1)),
            astForSuite(c, CHILD(n, 3)),
            [],
            n.lineno,
            n.col_offset,
            n.end_lineno,
            n.end_col_offset
          );
        } else if (NCH(n) === 7) {
          return new Sk.astnodes.While(
            ast_for_expr(c, CHILD(n, 1)),
            astForSuite(c, CHILD(n, 3)),
            astForSuite(c, CHILD(n, 6)),
            n.lineno,
            n.col_offset,
            n.end_lineno,
            n.end_col_offset
          );
        }
        Sk.asserts.fail("wrong number of tokens for 'while' stmt");
      }
      function astForAugassign(c, n) {
        REQ(n, SYM.augassign);
        n = CHILD(n, 0);
        switch (n.value.charAt(0)) {
          case "+":
            return Sk.astnodes.Add;
          case "-":
            return Sk.astnodes.Sub;
          case "/":
            if (n.value.charAt(1) === "/") {
              return Sk.astnodes.FloorDiv;
            }
            return Sk.astnodes.Div;
          case "%":
            return Sk.astnodes.Mod;
          case "<":
            return Sk.astnodes.LShift;
          case ">":
            return Sk.astnodes.RShift;
          case "&":
            return Sk.astnodes.BitAnd;
          case "^":
            return Sk.astnodes.BitXor;
          case "|":
            return Sk.astnodes.BitOr;
          case "*":
            if (n.value.charAt(1) === "*") {
              return Sk.astnodes.Pow;
            }
            return Sk.astnodes.Mult;
          case "@":
            if (Sk.__future__.python3) {
              return Sk.astnodes.MatMult;
            }
          default:
            Sk.asserts.fail("invalid augassign");
        }
      }
      function astForBinop(c, n) {
        var tmp;
        var newoperator;
        var nextOper;
        var i;
        var result = new Sk.astnodes.BinOp(
          ast_for_expr(c, CHILD(n, 0)),
          getOperator(CHILD(n, 1)),
          ast_for_expr(c, CHILD(n, 2)),
          n.lineno,
          n.col_offset,
          n.end_lineno,
          n.end_col_offset
        );
        var nops = (NCH(n) - 1) / 2;
        for (i = 1; i < nops; ++i) {
          nextOper = CHILD(n, i * 2 + 1);
          newoperator = getOperator(nextOper);
          tmp = ast_for_expr(c, CHILD(n, i * 2 + 2));
          result = new Sk.astnodes.BinOp(
            result,
            newoperator,
            tmp,
            nextOper.lineno,
            nextOper.col_offset,
            nextOper.end_lineno,
            nextOper.end_col_offset
          );
        }
        return result;
      }
      function ast_for_testlist(c, n) {
        Sk.asserts.assert(NCH(n) > 0);
        if (n.type === SYM.testlist_comp) {
          if (NCH(n) > 1) {
            Sk.asserts.assert(CHILD(n, 1).type !== SYM.comp_for);
          }
        } else {
          Sk.asserts.assert(n.type === SYM.testlist || n.type === SYM.testlist_star_expr);
        }
        if (NCH(n) === 1) {
          return ast_for_expr(c, CHILD(n, 0));
        } else {
          return new Sk.astnodes.Tuple(
            seq_for_testlist(c, n),
            Sk.astnodes.Load,
            n.lineno,
            n.col_offset,
            n.end_lineno,
            n.end_col_offset
            /*, c.c_arena */
          );
        }
      }
      function ast_for_exprStmt(c, n) {
        var expression;
        var value;
        var e;
        var i;
        var targets;
        var expr2;
        var varName;
        var expr1;
        var ch;
        var ann;
        var simple;
        var deep;
        var expr3;
        REQ(n, SYM.expr_stmt);
        if (NCH(n) === 1) {
          return new Sk.astnodes.Expr(
            ast_for_testlist(c, CHILD(n, 0)),
            n.lineno,
            n.col_offset,
            n.end_lineno,
            n.end_col_offset
          );
        } else if (CHILD(n, 1).type === SYM.augassign) {
          ch = CHILD(n, 0);
          expr1 = ast_for_testlist(c, ch);
          setContext(c, expr1, Sk.astnodes.Store, ch);
          switch (expr1.constructor) {
            case Sk.astnodes.Name:
              varName = expr1.id;
              forbiddenCheck(c, ch, varName, n.lineno);
              break;
            case Sk.astnodes.Attribute:
            case Sk.astnodes.Subscript:
              break;
            case Sk.astnodes.GeneratorExp:
              throw new Sk.builtin.SyntaxError(
                "augmented assignment to generator expression not possible",
                c.c_filename,
                ...get_context(n)
              );
            case Sk.astnodes.Yield:
              throw new Sk.builtin.SyntaxError(
                "augmented assignment to yield expression not possible",
                c.c_filename,
                ...get_context(n)
              );
            default:
              throw new Sk.builtin.SyntaxError(
                "illegal expression for augmented assignment",
                c.c_filename,
                ...get_context(n)
              );
          }
          ch = CHILD(n, 2);
          if (ch.type === SYM.testlist) {
            expr2 = ast_for_testlist(c, ch);
          } else {
            expr2 = ast_for_expr(c, ch);
          }
          return new Sk.astnodes.AugAssign(
            expr1,
            astForAugassign(c, CHILD(n, 1)),
            expr2,
            n.lineno,
            n.col_offset,
            n.end_lineno,
            n.end_col_offset
          );
        } else if (CHILD(n, 1).type === SYM.annassign) {
          if (!Sk.__future__.python3) {
            throw new Sk.builtin.SyntaxError(
              "Annotated assignment is not supported in Python 2",
              ...get_context(n)
            );
          }
          ch = CHILD(n, 0);
          ann = CHILD(n, 1);
          simple = 1;
          deep = ch;
          while (NCH(deep) == 1) {
            deep = CHILD(deep, 0);
          }
          if (NCH(deep) > 0 && TYPE(CHILD(deep, 0)) == TOK.T_LPAR) {
            simple = 0;
          }
          expr1 = ast_for_testlist(c, ch);
          switch (expr1.constructor) {
            case Sk.astnodes.Name:
              varName = expr1.id;
              forbiddenCheck(c, ch, varName, n.lineno);
              setContext(c, expr1, Sk.astnodes.Store, ch);
              break;
            case Sk.astnodes.Attribute:
              varName = expr1.attr;
              forbiddenCheck(c, ch, varName, n.lineno);
              setContext(c, expr1, Sk.astnodes.Store, ch);
              break;
            case Sk.astnodes.Subscript:
              setContext(c, expr1, Sk.astnodes.Store, ch);
              break;
            case Sk.astnodes.List:
              throw new Sk.builtin.SyntaxError(
                "only single target (not list) can be annotated",
                c.c_filename,
                ...get_context(n)
              );
            case Sk.astnodes.Tuple:
              throw new Sk.builtin.SyntaxError(
                "only single target (not tuple) can be annotated",
                c.c_filename,
                ...get_context(n)
              );
            default:
              throw new Sk.builtin.SyntaxError(
                "illegal target for annotation",
                c.c_filename,
                ...get_context(n)
              );
          }
          if (expr1.constructor != Sk.astnodes.Name) {
            simple = 0;
          }
          ch = CHILD(ann, 1);
          expr2 = ast_for_expr(c, ch);
          if (NCH(ann) == 2) {
            return new Sk.astnodes.AnnAssign(
              expr1,
              expr2,
              null,
              simple,
              n.lineno,
              n.col_offset,
              n.end_lineno,
              n.end_col_offset
            );
          } else {
            ch = CHILD(ann, 3);
            expr3 = ast_for_expr(c, ch);
            return new Sk.astnodes.AnnAssign(
              expr1,
              expr2,
              expr3,
              simple,
              n.lineno,
              n.col_offset,
              n.end_lineno,
              n.end_col_offset
            );
          }
        } else {
          REQ(CHILD(n, 1), TOK.T_EQUAL);
          targets = [];
          for (i = 0; i < NCH(n) - 2; i += 2) {
            ch = CHILD(n, i);
            if (ch.type === SYM.yield_expr) {
              throw new Sk.builtin.SyntaxError(
                "assignment to yield expression not possible",
                c.c_filename,
                ...get_context(n)
              );
            }
            e = ast_for_testlist(c, ch);
            setContext(c, e, Sk.astnodes.Store, CHILD(n, i));
            targets[i / 2] = e;
          }
          value = CHILD(n, NCH(n) - 1);
          if (value.type === SYM.testlist_star_expr) {
            expression = ast_for_testlist(c, value);
          } else {
            expression = ast_for_expr(c, value);
          }
          return new Sk.astnodes.Assign(
            targets,
            expression,
            n.lineno,
            n.col_offset,
            n.end_lineno,
            n.end_col_offset
          );
        }
      }
      function astForIfexpr(c, n) {
        Sk.asserts.assert(NCH(n) === 5);
        return new Sk.astnodes.IfExp(
          ast_for_expr(c, CHILD(n, 2)),
          ast_for_expr(c, CHILD(n, 0)),
          ast_for_expr(c, CHILD(n, 4)),
          n.lineno,
          n.col_offset,
          n.end_lineno,
          n.end_col_offset
        );
      }
      function parsestr(c, n, s) {
        var quote = s.charAt(0);
        var rawmode = false;
        var unicode = false;
        var fmode = false;
        var bytesmode = false;
        var decodeEscape = function(s2, quote2) {
          var d3;
          var d2;
          var d1;
          var d0;
          var ch;
          var i;
          var len = s2.length;
          var ret = "";
          for (i = 0; i < len; ++i) {
            ch = s2.charAt(i);
            if (ch === "\\") {
              ++i;
              ch = s2.charAt(i);
              if (ch === "n") {
                ret += "\n";
              } else if (ch === "\\") {
                ret += "\\";
              } else if (ch === "t") {
                ret += "	";
              } else if (ch === "r") {
                ret += "\r";
              } else if (ch === "b") {
                ret += "\b";
              } else if (ch === "f") {
                ret += "\f";
              } else if (ch === "v") {
                ret += "\v";
              } else if (ch === "0") {
                ret += "\0";
              } else if (ch === '"') {
                ret += '"';
              } else if (ch === "'") {
                ret += "'";
              } else if (ch === "\n") {
              } else if (ch === "x") {
                if (i + 2 >= len) {
                  ast_error(c, n, "Truncated \\xNN escape");
                }
                ret += String.fromCharCode(parseInt(s2.substr(i + 1, 2), 16));
                i += 2;
              } else if (!bytesmode && ch === "u") {
                if (i + 4 >= len) {
                  ast_error(c, n, "Truncated \\uXXXX escape");
                }
                ret += String.fromCharCode(parseInt(s2.substr(i + 1, 4), 16));
                i += 4;
              } else if (!bytesmode && ch === "U") {
                if (i + 8 >= len) {
                  ast_error(c, n, "Truncated \\UXXXXXXXX escape");
                }
                ret += String.fromCodePoint(parseInt(s2.substr(i + 1, 8), 16));
                i += 8;
              } else {
                ret += "\\" + ch;
              }
            } else if (bytesmode && ch.charCodeAt(0) > 127) {
              ast_error(c, n, "bytes can only contain ASCII literal characters");
            } else {
              ret += ch;
            }
          }
          return ret;
        };
        if (c.c_flags & Sk.Parser.CO_FUTURE_UNICODE_LITERALS || Sk.__future__.unicode_literals === true) {
          unicode = true;
        }
        let seenflags = {};
        while (true) {
          if (quote === "u" || quote === "U") {
            unicode = true;
          } else if (quote === "r" || quote === "R") {
            rawmode = true;
          } else if (quote === "b" || quote === "B") {
            bytesmode = true;
          } else if (quote === "f" || quote === "F") {
            fmode = true;
          } else {
            break;
          }
          s = s.substr(1);
          quote = s.charAt(0);
        }
        Sk.asserts.assert(quote === "'" || quote === '"' && s.charAt(s.length - 1) === quote);
        s = s.substr(1, s.length - 2);
        if (s.length >= 4 && s.charAt(0) === quote && s.charAt(1) === quote) {
          Sk.asserts.assert(s.charAt(s.length - 1) === quote && s.charAt(s.length - 2) === quote);
          s = s.substr(2, s.length - 4);
        }
        if (rawmode || s.indexOf("\\") === -1) {
          if (bytesmode) {
            for (let i = 0; i < s.length; i++) {
              if (s.charCodeAt(i) > 127) {
                ast_error(c, n, "bytes can only contain ASCII literal characters");
              }
            }
          }
          return [strobj(s), fmode, bytesmode];
        }
        return [strobj(decodeEscape(s, quote)), fmode, bytesmode];
      }
      function fstring_compile_expr(str, expr_start, expr_end, c, n) {
        Sk.asserts.assert(expr_end >= expr_start);
        Sk.asserts.assert(str.charAt(expr_start - 1) == "{");
        Sk.asserts.assert(
          str.charAt(expr_end) == "}" || str.charAt(expr_end) == "!" || str.charAt(expr_end) == ":"
        );
        let s = str.substring(expr_start, expr_end);
        if (/^\s*$/.test(s)) {
          ast_error(c, n, "f-string: empty expression not allowed");
        }
        s = "(" + s + ")";
        let ast;
        try {
          let parsed = Sk.parse("<fstring>", s);
          ast = Sk.astFromParse(parsed.cst, "<fstring>", parsed.flags);
        } catch (e) {
          if (e.traceback && e.traceback[0]) {
            let tb = e.traceback[0];
            tb.lineno = (tb.lineno || 1) - 1 + LINENO(n);
            tb.filename = c.c_filename;
          }
          throw e;
        }
        Sk.asserts.assert(ast.body.length == 1 && ast.body[0].constructor === Sk.astnodes.Expr);
        return ast.body[0].value;
      }
      function fstring_find_expr(str, start, end, raw, recurse_lvl, c, n) {
        let i = start;
        Sk.asserts.assert(str.charAt(i) == "{");
        i++;
        let expr_start = i;
        let quote_char = null;
        let string_type = 0;
        let nested_depth = 0;
        let format_spec, conversion;
        let unexpected_end_of_string = () => ast_error(c, n, "f-string: expecting '}'");
        Sk.asserts.assert(i <= end);
        for (; i < end; i++) {
          let ch = str.charAt(i);
          if (ch == "\\") {
            ast_error(c, n, "f-string expression part cannot include a backslash");
          }
          if (quote_char) {
            if (ch == quote_char) {
              if (string_type == 3) {
                if (i + 2 < end && str.charAt(i + 1) == ch && str.charAt(i + 2) == ch) {
                  i += 2;
                  string_type = 0;
                  quote_char = 0;
                  continue;
                }
              } else {
                quote_char = 0;
                string_type = 0;
                continue;
              }
            }
          } else if (ch == "'" || ch == '"') {
            if (i + 2 < end && str.charAt(i + 1) == ch && str.charAt(i + 2) == ch) {
              string_type = 3;
              i += 2;
            } else {
              string_type = 1;
            }
            quote_char = ch;
          } else if (ch == "[" || ch == "{" || ch == "(") {
            nested_depth++;
          } else if (nested_depth != 0 && (ch == "]" || ch == "}" || ch == ")")) {
            nested_depth--;
          } else if (ch == "#") {
            ast_error(c, n, "f-string expression part cannot include '#'");
          } else if (nested_depth == 0 && (ch == "!" || ch == ":" || ch == "}")) {
            if (ch == "!" && i + 1 < end && str.charAt(i + 1) == "=") {
              continue;
            }
            break;
          } else {
          }
        }
        if (quote_char) {
          ast_error(c, n, "f-string: unterminated string");
        }
        if (nested_depth) {
          ast_error(c, n, "f-string: mismatched '(', '{', or '['");
        }
        let expr_end = i;
        let simple_expression = fstring_compile_expr(str, expr_start, expr_end, c, n);
        if (str.charAt(i) == "!") {
          i++;
          if (i >= end) {
            unexpected_end_of_string();
          }
          conversion = str.charAt(i);
          i++;
          if (!(conversion == "s" || conversion == "r" || conversion == "a")) {
            ast_error(c, n, "f-string: invalid conversion character: expected 's', 'r', or 'a'");
          }
        }
        if (i >= end) {
          unexpected_end_of_string();
        }
        if (str.charAt(i) == ":") {
          i++;
          if (i >= end) {
            unexpected_end_of_string();
          }
          [format_spec, i] = fstring_parse(str, i, end, raw, recurse_lvl + 1, c, n);
        }
        if (i >= end || str.charAt(i) != "}") {
          unexpected_end_of_string();
        }
        i++;
        let expr = new Sk.astnodes.FormattedValue(
          simple_expression,
          conversion,
          format_spec,
          LINENO(n),
          n.col_offset,
          n.end_lineno,
          n.end_col_offset
        );
        return [expr, i];
      }
      function fstring_parse(str, start, end, raw, recurse_lvl, c, n) {
        let values = [];
        let idx = start;
        let addLiteral = (literal) => {
          if (literal.indexOf("}") !== -1) {
            if (/(^|[^}])}(}})*($|[^}])/.test(literal)) {
              throw new Sk.builtin.SyntaxError(
                "f-string: single '}' is not allowed",
                c.c_filename,
                ...get_context(n)
              );
            }
            literal = literal.replace(/}}/g, "}");
          }
          values.push(
            new Sk.astnodes.Str(
              new Sk.builtin.str(literal),
              LINENO(n),
              n.col_offset,
              n.end_lineno,
              n.end_col_offset
            )
          );
        };
        while (idx < end) {
          let bidx = str.indexOf("{", idx);
          if (recurse_lvl !== 0) {
            let cbidx = str.indexOf("}", idx);
            if (cbidx !== -1) {
              if (bidx === -1) {
                end = cbidx;
              } else if (bidx > cbidx) {
                bidx = -1;
                end = cbidx;
              }
            }
          }
          if (bidx === -1) {
            addLiteral(str.substring(idx, end));
            idx = end;
            break;
          } else if (bidx + 1 < end && str.charAt(bidx + 1) === "{") {
            addLiteral(str.substring(idx, bidx + 1));
            idx = bidx + 2;
            continue;
          } else {
            addLiteral(str.substring(idx, bidx));
            idx = bidx;
            let [expr, endIdx] = fstring_find_expr(str, bidx, end, raw, recurse_lvl, c, n);
            values.push(expr);
            idx = endIdx;
          }
        }
        return [
          new Sk.astnodes.JoinedStr(values, LINENO(n), n.col_offset, n.end_lineno, n.end_col_offset),
          idx
        ];
      }
      function parsestrplus(c, n) {
        let strs = [];
        let lastStrNode;
        let bytesmode;
        for (let i = 0; i < NCH(n); ++i) {
          let chstr = CHILD(n, i).value;
          let r = parsestr(c, CHILD(n, i), chstr);
          let str = r[0];
          let fmode = r[1];
          let this_bytesmode = r[2];
          if (i != 0 && bytesmode !== this_bytesmode) {
            ast_error(c, n, "cannot mix bytes and nonbytes literals");
          }
          bytesmode = this_bytesmode;
          if (fmode) {
            if (!Sk.__future__.python3) {
              throw new Sk.builtin.SyntaxError(
                "invalid string (f-strings are not supported in Python 2)",
                c.c_filename,
                ...get_context(CHILD(n, i))
              );
            }
            let jss = str.$jsstr();
            let [astnode, _] = fstring_parse(jss, 0, jss.length, false, 0, c, CHILD(n, i));
            strs.push.apply(strs, astnode.values);
            lastStrNode = null;
          } else {
            if (lastStrNode) {
              lastStrNode.s = lastStrNode.s.sq$concat(str);
            } else {
              let type = bytesmode ? Sk.astnodes.Bytes : Sk.astnodes.Str;
              lastStrNode = new type(
                str,
                LINENO(n),
                n.col_offset,
                n.end_lineno,
                n.end_col_offset
              );
              strs.push(lastStrNode);
            }
          }
        }
        if (strs.length === 1 && strs[0].constructor === Sk.astnodes.Str) {
          return strs[0];
        } else {
          return new Sk.astnodes.JoinedStr(
            strs,
            LINENO(n),
            n.col_offset,
            n.end_lineno,
            n.end_col_offset
          );
        }
      }
      var FLOAT_RE = new RegExp(Sk._tokenize.Floatnumber);
      var underscore = /_/g;
      function parsenumber(c, s, lineno) {
        s = s.replace(underscore, "");
        const end = s[s.length - 1];
        if (end === "j" || end === "J") {
          return new Sk.builtin.complex(0, parseFloat(s.slice(0, -1)));
        }
        if (FLOAT_RE.test(s)) {
          return new Sk.builtin.float_(parseFloat(s));
        }
        const start = s[0];
        if (start === "0" && s !== "0" && s.charCodeAt(1) < 65) {
          s = "0o" + s.substring(1);
        }
        let isInt = true;
        if (end === "l" || end === "L") {
          s = s.slice(0, -1);
          isInt = false;
        }
        const val = Number(s);
        if (val > Number.MAX_SAFE_INTEGER) {
          return isInt ? new Sk.builtin.int_(JSBI.BigInt(s)) : new Sk.builtin.lng(JSBI.BigInt(s));
        }
        return isInt ? new Sk.builtin.int_(val) : new Sk.builtin.lng(val);
      }
      function astForSlice(c, n) {
        var n2;
        var step;
        var upper;
        var lower;
        var ch;
        REQ(n, SYM.subscript);
        ch = CHILD(n, 0);
        lower = null;
        upper = null;
        step = null;
        if (ch.type === TOK.T_DOT) {
          return new Sk.astnodes.Ellipsis();
        }
        if (NCH(n) === 1 && ch.type === SYM.test) {
          return new Sk.astnodes.Index(ast_for_expr(c, ch));
        }
        if (ch.type === SYM.test) {
          lower = ast_for_expr(c, ch);
        }
        if (ch.type === TOK.T_COLON) {
          if (NCH(n) > 1) {
            n2 = CHILD(n, 1);
            if (n2.type === SYM.test) {
              upper = ast_for_expr(c, n2);
            }
          }
        } else if (NCH(n) > 2) {
          n2 = CHILD(n, 2);
          if (n2.type === SYM.test) {
            upper = ast_for_expr(c, n2);
          }
        }
        ch = CHILD(n, NCH(n) - 1);
        if (ch.type === SYM.sliceop) {
          if (NCH(ch) === 1) {
            ch = CHILD(ch, 0);
            step = new Sk.astnodes.NameConstant(
              Sk.builtin.none.none$,
              Sk.astnodes.Load,
              ch.lineno,
              ch.col_offset,
              ch.end_lineno,
              ch.end_col_offset
            );
          } else {
            ch = CHILD(ch, 1);
            if (ch.type === SYM.test) {
              step = ast_for_expr(c, ch);
            }
          }
        }
        return new Sk.astnodes.Slice(lower, upper, step);
      }
      function ast_for_atom(c, n) {
        var ch = CHILD(n, 0);
        switch (TYPE(ch)) {
          case TOK.T_NAME: {
            var name;
            var s = STR(ch);
            if (s.length >= 4 && s.length <= 5) {
              if (s === "None") {
                return new Sk.astnodes.NameConstant(
                  Sk.builtin.none.none$,
                  n.lineno,
                  n.col_offset,
                  n.end_lineno,
                  n.end_col_offset
                );
              }
              if (s === "True") {
                return new Sk.astnodes.NameConstant(
                  Sk.builtin.bool.true$,
                  n.lineno,
                  n.col_offset,
                  n.end_lineno,
                  n.end_col_offset
                );
              }
              if (s === "False") {
                return new Sk.astnodes.NameConstant(
                  Sk.builtin.bool.false$,
                  n.lineno,
                  n.col_offset,
                  n.end_lineno,
                  n.end_col_offset
                );
              }
            }
            name = new_identifier(s, c);
            return new Sk.astnodes.Name(
              name,
              Sk.astnodes.Load,
              LINENO(n),
              n.col_offset,
              n.end_lineno,
              n.end_col_offset
            );
          }
          case TOK.T_STRING:
            return parsestrplus(c, n);
          case TOK.T_NUMBER:
            return new Sk.astnodes.Num(
              parsenumber(c, ch.value, n.lineno),
              n.lineno,
              n.col_offset,
              n.end_lineno,
              n.end_col_offset
            );
          case TOK.T_ELLIPSIS:
            return new Sk.astnodes.Ellipsis(
              LINENO(n),
              n.col_offset,
              n.end_lineno,
              n.end_col_offset
            );
          case TOK.T_LPAR:
            ch = CHILD(n, 1);
            if (TYPE(ch) == TOK.T_RPAR) {
              return new Sk.astnodes.Tuple(
                [],
                Sk.astnodes.Load,
                LINENO(n),
                n.col_offset,
                n.end_lineno,
                n.end_col_offset
              );
            }
            if (TYPE(ch) == SYM.yield_expr) {
              return ast_for_expr(c, ch);
            }
            if (NCH(ch) == 1) {
              return ast_for_testlist(c, ch);
            }
            if (TYPE(CHILD(ch, 1)) == SYM.comp_for) {
              return copy_location(ast_for_genexp(c, ch), n);
            } else {
              return copy_location(ast_for_testlist(c, ch), n);
            }
          case TOK.T_LSQB:
            ch = CHILD(n, 1);
            if (TYPE(ch) == TOK.T_RSQB) {
              return new Sk.astnodes.List(
                [],
                Sk.astnodes.Load,
                LINENO(n),
                n.col_offset,
                n.end_lineno,
                n.end_col_offset
              );
            }
            REQ(ch, SYM.testlist_comp);
            if (NCH(ch) == 1 || TYPE(CHILD(ch, 1)) == TOK.T_COMMA) {
              var elts = seq_for_testlist(c, ch);
              if (!elts) {
                return null;
              }
              return new Sk.astnodes.List(
                elts,
                Sk.astnodes.Load,
                LINENO(n),
                n.col_offset,
                n.end_lineno,
                n.end_col_offset
              );
            } else {
              return copy_location(ast_for_listcomp(c, ch), n);
            }
          case TOK.T_LBRACE: {
            var res;
            ch = CHILD(n, 1);
            if (TYPE(ch) == TOK.T_RBRACE) {
              return new Sk.astnodes.Dict(
                null,
                null,
                LINENO(n),
                n.col_offset,
                n.end_lineno,
                n.end_col_offset
              );
            } else {
              var is_dict = TYPE(CHILD(ch, 0)) == TOK.T_DOUBLESTAR;
              if (NCH(ch) == 1 || NCH(ch) > 1 && TYPE(CHILD(ch, 1)) == TOK.T_COMMA) {
                res = ast_for_setdisplay(c, ch);
              } else if (NCH(ch) > 1 && TYPE(CHILD(ch, 1)) == SYM.comp_for) {
                res = ast_for_setcomp(c, ch);
              } else if (NCH(ch) > 3 - is_dict && TYPE(CHILD(ch, 3 - is_dict)) == SYM.comp_for) {
                if (is_dict) {
                  ast_error(c, n, "dict unpacking cannot be used in dict comprehension");
                  return null;
                }
                res = ast_for_dictcomp(c, ch);
              } else {
                res = ast_for_dictdisplay(c, ch);
              }
              return copy_location(res, n);
            }
          }
          default:
            Sk.asserts.fail("unhandled atom " + TYPE(ch));
            return null;
        }
      }
      function ast_for_setdisplay(c, n) {
        var i;
        var elts = [];
        Sk.asserts.assert(TYPE(n) === SYM.dictorsetmaker);
        for (i = 0; i < NCH(n); i += 2) {
          var expression;
          expression = ast_for_expr(c, CHILD(n, i));
          elts[i / 2] = expression;
        }
        return new Sk.astnodes.Set(elts, LINENO(n), n.col_offset, n.end_lineno, n.end_col_offset);
      }
      function astForAtomExpr(c, n) {
        var i, nch, start = 0;
        var e, tmp;
        REQ(n, SYM.atom_expr);
        nch = NCH(n);
        if (CHILD(n, 0).type === TOK.T_AWAIT) {
          start = 1;
          Sk.asserts.assert(nch > 1);
        }
        e = ast_for_atom(c, CHILD(n, start));
        if (!e) {
          return null;
        }
        if (nch === 1) {
          return e;
        }
        if (start && nch === 2) {
          return new Sk.astnodes.Await(
            e,
            n.lineno,
            n.col_offset,
            n.end_lineno,
            n.end_col_offset
            /*, c->c_arena*/
          );
        }
        for (i = start + 1; i < nch; i++) {
          var ch = CHILD(n, i);
          if (ch.type !== SYM.trailer) {
            break;
          }
          tmp = ast_for_trailer(c, ch, e);
          if (!tmp) {
            return null;
          }
          tmp.lineno = e.lineno;
          tmp.col_offset = e.col_offset;
          e = tmp;
        }
        if (start) {
          return new Sk.astnodes.Await(
            e,
            n.line,
            n.col_offset,
            n.end_lineno,
            n.end_col_offset
            /*, c->c_arena*/
          );
        } else {
          return e;
        }
      }
      function astForPower(c, n) {
        var f;
        var tmp;
        var ch;
        var i;
        var e;
        REQ(n, SYM.power);
        e = astForAtomExpr(c, CHILD(n, 0));
        if (NCH(n) === 1) {
          return e;
        }
        if (CHILD(n, NCH(n) - 1).type === SYM.factor) {
          f = ast_for_expr(c, CHILD(n, NCH(n) - 1));
          e = new Sk.astnodes.BinOp(
            e,
            Sk.astnodes.Pow,
            f,
            n.lineno,
            n.col_offset,
            n.end_lineno,
            n.end_col_offset
          );
        }
        return e;
      }
      function astForStarred(c, n) {
        REQ(n, SYM.star_expr);
        return new Sk.astnodes.Starred(
          ast_for_expr(c, CHILD(n, 1)),
          Sk.astnodes.Load,
          n.lineno,
          n.col_offset,
          n.end_lineno,
          n.end_col_offset
          /*, c.c_arena */
        );
      }
      function ast_for_expr(c, n) {
        var exp;
        var cmps;
        var ops;
        var i;
        var seq;
        LOOP: while (true) {
          switch (n.type) {
            case SYM.test:
            case SYM.test_nocond:
              if (CHILD(n, 0).type === SYM.lambdef || CHILD(n, 0).type === SYM.lambdef_nocond) {
                return astForLambdef(c, CHILD(n, 0));
              } else if (NCH(n) > 1) {
                return astForIfexpr(c, n);
              }
            // fallthrough
            case SYM.or_test:
            case SYM.and_test:
              if (NCH(n) === 1) {
                n = CHILD(n, 0);
                continue LOOP;
              }
              seq = [];
              for (i = 0; i < NCH(n); i += 2) {
                seq[i / 2] = ast_for_expr(c, CHILD(n, i));
              }
              if (CHILD(n, 1).value === "and") {
                return new Sk.astnodes.BoolOp(
                  Sk.astnodes.And,
                  seq,
                  n.lineno,
                  n.col_offset,
                  n.end_lineno,
                  n.end_col_offset
                  /*, c.c_arena*/
                );
              }
              Sk.asserts.assert(CHILD(n, 1).value === "or");
              return new Sk.astnodes.BoolOp(
                Sk.astnodes.Or,
                seq,
                n.lineno,
                n.col_offset,
                n.end_lineno,
                n.end_col_offset
              );
            case SYM.not_test:
              if (NCH(n) === 1) {
                n = CHILD(n, 0);
                continue LOOP;
              } else {
                return new Sk.astnodes.UnaryOp(
                  Sk.astnodes.Not,
                  ast_for_expr(c, CHILD(n, 1)),
                  n.lineno,
                  n.col_offset,
                  n.end_lineno,
                  n.end_col_offset
                );
              }
              break;
            case SYM.comparison:
              if (NCH(n) === 1) {
                n = CHILD(n, 0);
                continue LOOP;
              } else {
                ops = [];
                cmps = [];
                for (i = 1; i < NCH(n); i += 2) {
                  ops[(i - 1) / 2] = astForCompOp(c, CHILD(n, i));
                  cmps[(i - 1) / 2] = ast_for_expr(c, CHILD(n, i + 1));
                }
                return new Sk.astnodes.Compare(
                  ast_for_expr(c, CHILD(n, 0)),
                  ops,
                  cmps,
                  n.lineno,
                  n.col_offset,
                  n.end_lineno,
                  n.end_col_offset
                );
              }
              break;
            case SYM.star_expr:
              return astForStarred(c, n);
            /* The next fize cases all handle BinOps  The main body of code
               is the same in each case, but the switch turned inside out to
               reuse the code for each type of operator
             */
            case SYM.expr:
            case SYM.xor_expr:
            case SYM.and_expr:
            case SYM.shift_expr:
            case SYM.arith_expr:
            case SYM.term:
              if (NCH(n) === 1) {
                n = CHILD(n, 0);
                continue LOOP;
              }
              return astForBinop(c, n);
            case SYM.yield_expr:
              var an;
              var en;
              var is_from = false;
              exp = null;
              if (NCH(n) > 1) {
                an = CHILD(n, 1);
              }
              if (an) {
                en = CHILD(an, NCH(an) - 1);
                if (NCH(an) == 2) {
                  is_from = true;
                  exp = ast_for_expr(c, en);
                } else {
                  exp = ast_for_testlist(c, en);
                }
              }
              if (is_from) {
                return new Sk.astnodes.YieldFrom(
                  exp,
                  n.lineno,
                  n.col_offset,
                  n.end_lineno,
                  n.end_col_offset
                );
              }
              return new Sk.astnodes.Yield(
                exp,
                n.lineno,
                n.col_offset,
                n.end_lineno,
                n.end_col_offset
              );
            case SYM.factor:
              if (NCH(n) === 1) {
                n = CHILD(n, 0);
                continue LOOP;
              }
              return astForFactor(c, n);
            case SYM.power:
              return astForPower(c, n);
            default:
              Sk.asserts.fail("unhandled expr", "n.type: %d", n.type);
          }
          break;
        }
      }
      function astForNonLocalStmt(c, n) {
        ast_error(c, n, "Not implemented: nonlocal");
      }
      function astForAsyncStmt(c, n) {
        ast_error(c, n, "Not implemented: async");
      }
      function astForPrintStmt(c, n) {
        if (Sk.__future__.print_function) {
          ast_error(c, n, "Missing parentheses in call to 'print'");
        }
        var nl;
        var i, j;
        var seq;
        var start = 1;
        var dest = null;
        REQ(n, SYM.print_stmt);
        if (NCH(n) >= 2 && CHILD(n, 1).type === TOK.T_RIGHTSHIFT) {
          dest = ast_for_expr(c, CHILD(n, 2));
          start = 4;
        }
        seq = [];
        for (i = start, j = 0; i < NCH(n); i += 2, ++j) {
          seq[j] = ast_for_expr(c, CHILD(n, i));
        }
        nl = CHILD(n, NCH(n) - 1).type === TOK.T_COMMA ? false : true;
        return new Sk.astnodes.Print(
          dest,
          seq,
          nl,
          n.lineno,
          n.col_offset,
          n.end_lineno,
          n.end_col_offset
        );
      }
      function astForStmt(c, n) {
        var ch;
        if (n.type === SYM.stmt) {
          Sk.asserts.assert(NCH(n) === 1);
          n = CHILD(n, 0);
        }
        if (n.type === SYM.simple_stmt) {
          Sk.asserts.assert(numStmts(n) === 1);
          n = CHILD(n, 0);
        }
        if (n.type === SYM.small_stmt) {
          n = CHILD(n, 0);
          switch (n.type) {
            case SYM.expr_stmt:
              return ast_for_exprStmt(c, n);
            case SYM.del_stmt:
              return astForDelStmt(c, n);
            case SYM.pass_stmt:
              return new Sk.astnodes.Pass(n.lineno, n.col_offset, n.end_lineno, n.end_col_offset);
            case SYM.flow_stmt:
              return ast_for_flow_stmt(c, n);
            case SYM.import_stmt:
              return astForImportStmt(c, n);
            case SYM.global_stmt:
              return astForGlobalStmt(c, n);
            case SYM.nonlocal_stmt:
              return astForNonLocalStmt(c, n);
            case SYM.assert_stmt:
              return astForAssertStmt(c, n);
            case SYM.print_stmt:
              return astForPrintStmt(c, n);
            case SYM.debugger_stmt:
              return new Sk.astnodes.Debugger(
                n.lineno,
                n.col_offset,
                n.end_lineno,
                n.end_col_offset
              );
            default:
              Sk.asserts.fail("unhandled small_stmt");
          }
        } else {
          ch = CHILD(n, 0);
          REQ(n, SYM.compound_stmt);
          switch (ch.type) {
            case SYM.if_stmt:
              return astForIfStmt(c, ch);
            case SYM.while_stmt:
              return astForWhileStmt(c, ch);
            case SYM.for_stmt:
              return astForForStmt(c, ch);
            case SYM.try_stmt:
              return astForTryStmt(c, ch);
            case SYM.with_stmt:
              return ast_for_with_stmt(c, ch);
            case SYM.funcdef:
              return ast_for_funcdef(c, ch, []);
            case SYM.classdef:
              return astForClassdef(c, ch, []);
            case SYM.decorated:
              return ast_for_decorated(c, ch);
            case SYM.async_stmt:
              return astForAsyncStmt(c, ch);
            default:
              Sk.asserts.assert("unhandled compound_stmt");
          }
        }
      }
      Sk.astFromParse = function(n, filename, c_flags) {
        var j;
        var num;
        var ch;
        var i;
        var c = new Compiling("utf-8", filename, c_flags);
        var stmts = [];
        var k = 0;
        switch (n.type) {
          case SYM.file_input:
            for (i = 0; i < NCH(n) - 1; ++i) {
              ch = CHILD(n, i);
              if (ch.type === TOK.T_NEWLINE) {
                continue;
              }
              REQ(ch, SYM.stmt);
              num = numStmts(ch);
              if (num === 1) {
                stmts[k++] = astForStmt(c, ch);
              } else {
                ch = CHILD(ch, 0);
                REQ(ch, SYM.simple_stmt);
                for (j = 0; j < num; ++j) {
                  stmts[k++] = astForStmt(c, CHILD(ch, j * 2));
                }
              }
            }
            return new Sk.astnodes.Module(stmts);
          case SYM.eval_input:
            Sk.asserts.fail("todo;");
          case SYM.single_input:
            Sk.asserts.fail("todo;");
          default:
            Sk.asserts.fail("todo;");
        }
      };
      Sk.astDump = function(node) {
        var spaces = function(n) {
          var i;
          var ret = "";
          for (i = 0; i < n; ++i) {
            ret += " ";
          }
          return ret;
        };
        var _format = function(node2, indent) {
          var ret;
          var elemsstr;
          var x;
          var elems;
          var fieldstr;
          var field;
          var attrs;
          var fieldlen;
          var b;
          var a;
          var i;
          var fields;
          var namelen;
          if (node2 === null) {
            return indent + "None";
          } else if (node2.prototype && node2.prototype._astname !== void 0 && node2.prototype._isenum) {
            return indent + node2.prototype._astname + "()";
          } else if (node2._astname !== void 0) {
            namelen = spaces(node2._astname.length + 1);
            fields = [];
            for (i = 0; i < node2._fields.length; i += 2) {
              a = node2._fields[i];
              b = node2._fields[i + 1](node2);
              fieldlen = spaces(a.length + 1);
              fields.push([a, _format(b, indent + namelen + fieldlen)]);
            }
            attrs = [];
            for (i = 0; i < fields.length; ++i) {
              field = fields[i];
              attrs.push(field[0] + "=" + field[1].replace(/^\s+/, ""));
            }
            fieldstr = attrs.join(",\n" + indent + namelen);
            return indent + node2._astname + "(" + fieldstr + ")";
          } else if (Sk.isArrayLike(node2)) {
            elems = [];
            for (i = 0; i < node2.length; ++i) {
              x = node2[i];
              elems.push(_format(x, indent + " "));
            }
            elemsstr = elems.join(",\n");
            return indent + "[" + elemsstr.replace(/^\s+/, "") + "]";
          } else {
            if (node2 === true) {
              ret = "True";
            } else if (node2 === false) {
              ret = "False";
            } else if (node2 instanceof Sk.builtin.lng) {
              ret = node2.tp$str().v;
            } else if (node2 instanceof Sk.builtin.str) {
              ret = node2["$r"]().v;
            } else {
              ret = "" + node2;
            }
            return indent + ret;
          }
        };
        return _format(node, "");
      };
      Sk.INHERITANCE_MAP = {
        mod: [Sk.astnodes.Module, Sk.astnodes.Interactive, Sk.astnodes.Expression, Sk.astnodes.Suite],
        stmt: [
          Sk.astnodes.FunctionDef,
          Sk.astnodes.AsyncFunctionDef,
          Sk.astnodes.ClassDef,
          Sk.astnodes.Return,
          Sk.astnodes.Delete,
          Sk.astnodes.Assign,
          Sk.astnodes.AugAssign,
          Sk.astnodes.AnnAssign,
          Sk.astnodes.For,
          Sk.astnodes.AsyncFor,
          Sk.astnodes.While,
          Sk.astnodes.If,
          Sk.astnodes.With,
          Sk.astnodes.AsyncWith,
          Sk.astnodes.Raise,
          Sk.astnodes.Try,
          Sk.astnodes.Assert,
          Sk.astnodes.Import,
          Sk.astnodes.ImportFrom,
          Sk.astnodes.Global,
          Sk.astnodes.Nonlocal,
          Sk.astnodes.Expr,
          Sk.astnodes.Pass,
          Sk.astnodes.Break,
          Sk.astnodes.Continue,
          Sk.astnodes.Print,
          Sk.astnodes.Debugger
        ],
        expr: [
          Sk.astnodes.BoolOp,
          Sk.astnodes.BinOp,
          Sk.astnodes.UnaryOp,
          Sk.astnodes.Lambda,
          Sk.astnodes.IfExp,
          Sk.astnodes.Dict,
          Sk.astnodes.Set,
          Sk.astnodes.ListComp,
          Sk.astnodes.SetComp,
          Sk.astnodes.DictComp,
          Sk.astnodes.GeneratorExp,
          Sk.astnodes.Await,
          Sk.astnodes.Yield,
          Sk.astnodes.YieldFrom,
          Sk.astnodes.Compare,
          Sk.astnodes.Call,
          Sk.astnodes.Num,
          Sk.astnodes.Str,
          Sk.astnodes.FormattedValue,
          Sk.astnodes.JoinedStr,
          Sk.astnodes.Bytes,
          Sk.astnodes.Ellipsis,
          Sk.astnodes.NameConstant,
          Sk.astnodes.Constant,
          Sk.astnodes.Attribute,
          Sk.astnodes.Subscript,
          Sk.astnodes.Starred,
          Sk.astnodes.Name,
          Sk.astnodes.List,
          Sk.astnodes.Tuple
        ],
        expr_context: [
          Sk.astnodes.Load,
          Sk.astnodes.Store,
          Sk.astnodes.Del,
          Sk.astnodes.AugLoad,
          Sk.astnodes.AugStore,
          Sk.astnodes.Param
        ],
        slice: [Sk.astnodes.Slice, Sk.astnodes.ExtSlice, Sk.astnodes.Index],
        boolop: [Sk.astnodes.And, Sk.astnodes.Or],
        operator: [
          Sk.astnodes.Add,
          Sk.astnodes.Sub,
          Sk.astnodes.Mult,
          Sk.astnodes.MatMult,
          Sk.astnodes.Div,
          Sk.astnodes.Mod,
          Sk.astnodes.Pow,
          Sk.astnodes.LShift,
          Sk.astnodes.RShift,
          Sk.astnodes.BitOr,
          Sk.astnodes.BitXor,
          Sk.astnodes.BitAnd,
          Sk.astnodes.FloorDiv
        ],
        unaryop: [Sk.astnodes.Invert, Sk.astnodes.Not, Sk.astnodes.UAdd, Sk.astnodes.USub],
        cmpop: [
          Sk.astnodes.Eq,
          Sk.astnodes.NotEq,
          Sk.astnodes.Lt,
          Sk.astnodes.LtE,
          Sk.astnodes.Gt,
          Sk.astnodes.GtE,
          Sk.astnodes.Is,
          Sk.astnodes.IsNot,
          Sk.astnodes.In,
          Sk.astnodes.NotIn
        ],
        comprehension: [],
        excepthandler: [Sk.astnodes.ExceptHandler],
        arguments_: [],
        arg: [],
        keyword: [],
        alias: [],
        withitem: []
      };
      Sk.exportSymbol("Sk.astFromParse", Sk.astFromParse);
      Sk.exportSymbol("Sk.astDump", Sk.astDump);
      Sk.exportSymbol("Sk.INHERITANCE_MAP", Sk.INHERITANCE_MAP);
    }
  });

  // src/symtable.js
  var require_symtable = __commonJS({
    "src/symtable.js"() {
      var DEF_GLOBAL = 1;
      var DEF_LOCAL = 2;
      var DEF_PARAM = 2 << 1;
      var USE = 2 << 2;
      var DEF_STAR = 2 << 3;
      var DEF_DOUBLESTAR = 2 << 4;
      var DEF_INTUPLE = 2 << 5;
      var DEF_FREE = 2 << 6;
      var DEF_FREE_GLOBAL = 2 << 7;
      var DEF_FREE_CLASS = 2 << 8;
      var DEF_IMPORT = 2 << 9;
      var DEF_NONLOCAL = 2 << 10;
      var DEF_ANNOT = 2 << 11;
      var DEF_BOUND = DEF_LOCAL | DEF_PARAM | DEF_IMPORT;
      var SCOPE_OFF = 11;
      var SCOPE_MASK = 7;
      var LOCAL = 1;
      var GLOBAL_EXPLICIT = 2;
      var GLOBAL_IMPLICIT = 3;
      var FREE = 4;
      var CELL = 5;
      var OPT_IMPORT_STAR = 1;
      var OPT_EXEC = 2;
      var OPT_BARE_EXEC = 4;
      var OPT_TOPLEVEL = 8;
      var GENERATOR = 2;
      var GENERATOR_EXPRESSION = 2;
      var ModuleBlock = "module";
      var FunctionBlock = "function";
      var ClassBlock = "class";
      var SYMTAB_CONSTS = {
        DEF_GLOBAL,
        DEF_LOCAL,
        DEF_PARAM,
        USE,
        DEF_STAR,
        DEF_DOUBLESTAR,
        DEF_INTUPLE,
        DEF_FREE,
        DEF_FREE_GLOBAL,
        DEF_FREE_CLASS,
        DEF_IMPORT,
        DEF_BOUND,
        SCOPE_OFF,
        SCOPE_MASK,
        LOCAL,
        GLOBAL_EXPLICIT,
        GLOBAL_IMPLICIT,
        FREE,
        CELL,
        OPT_IMPORT_STAR,
        OPT_EXEC,
        OPT_BARE_EXEC,
        OPT_TOPLEVEL,
        GENERATOR,
        GENERATOR_EXPRESSION,
        ModuleBlock,
        FunctionBlock,
        ClassBlock
      };
      Sk.exportSymbol("Sk.SYMTAB_CONSTS", SYMTAB_CONSTS);
      function Symbol_(name, flags, namespaces) {
        this.__name = name;
        this.__flags = flags;
        this.__scope = flags >> SCOPE_OFF & SCOPE_MASK;
        this.__namespaces = namespaces || [];
      }
      Symbol_.prototype.get_name = function() {
        return this.__name;
      };
      Symbol_.prototype.is_referenced = function() {
        return !!(this.__flags & USE);
      };
      Symbol_.prototype.is_parameter = function() {
        return !!(this.__flags & DEF_PARAM);
      };
      Symbol_.prototype.is_global = function() {
        return this.__scope === GLOBAL_IMPLICIT || this.__scope == GLOBAL_EXPLICIT;
      };
      Symbol_.prototype.is_declared_global = function() {
        return this.__scope == GLOBAL_EXPLICIT;
      };
      Symbol_.prototype.is_local = function() {
        return !!(this.__flags & DEF_BOUND);
      };
      Symbol_.prototype.is_free = function() {
        return this.__scope == FREE;
      };
      Symbol_.prototype.is_imported = function() {
        return !!(this.__flags & DEF_IMPORT);
      };
      Symbol_.prototype.is_assigned = function() {
        return !!(this.__flags & DEF_LOCAL);
      };
      Symbol_.prototype.is_namespace = function() {
        return this.__namespaces && this.__namespaces.length > 0;
      };
      Symbol_.prototype.get_namespaces = function() {
        return this.__namespaces;
      };
      var astScopeCounter = 0;
      function SymbolTableScope(table, name, type, ast, lineno) {
        this.symFlags = {};
        this.name = name;
        this.varnames = [];
        this.children = [];
        this.blockType = type;
        this.isNested = false;
        this.hasFree = false;
        this.childHasFree = false;
        this.generator = false;
        this.varargs = false;
        this.varkeywords = false;
        this.returnsValue = false;
        this.lineno = lineno;
        this.table = table;
        if (table.cur && (table.cur.nested || table.cur.blockType === FunctionBlock)) {
          this.isNested = true;
        }
        ast.scopeId = astScopeCounter++;
        table.stss[ast.scopeId] = this;
        this.symbols = {};
      }
      SymbolTableScope.prototype.get_type = function() {
        return this.blockType;
      };
      SymbolTableScope.prototype.get_name = function() {
        return this.name;
      };
      SymbolTableScope.prototype.get_lineno = function() {
        return this.lineno;
      };
      SymbolTableScope.prototype.is_nested = function() {
        return this.isNested;
      };
      SymbolTableScope.prototype.has_children = function() {
        return this.children.length > 0;
      };
      SymbolTableScope.prototype.get_identifiers = function() {
        return this._identsMatching(function() {
          return true;
        });
      };
      SymbolTableScope.prototype.lookup = function(name) {
        var namespaces;
        var flags;
        var sym;
        if (!this.symbols.hasOwnProperty(name)) {
          flags = this.symFlags[name];
          namespaces = this.__check_children(name);
          sym = this.symbols[name] = new Symbol_(name, flags, namespaces);
        } else {
          sym = this.symbols[name];
        }
        return sym;
      };
      SymbolTableScope.prototype.__check_children = function(name) {
        var child;
        var i;
        var ret = [];
        for (i = 0; i < this.children.length; ++i) {
          child = this.children[i];
          if (child.name === name) {
            ret.push(child);
          }
        }
        return ret;
      };
      SymbolTableScope.prototype._identsMatching = function(f) {
        var k;
        var ret = [];
        for (k in this.symFlags) {
          if (this.symFlags.hasOwnProperty(k)) {
            if (f(this.symFlags[k])) {
              ret.push(k);
            }
          }
        }
        ret.sort();
        return ret;
      };
      SymbolTableScope.prototype.get_parameters = function() {
        Sk.asserts.assert(
          this.get_type() == "function",
          "get_parameters only valid for function scopes"
        );
        if (!this._funcParams) {
          this._funcParams = this._identsMatching(function(x) {
            return x & DEF_PARAM;
          });
        }
        return this._funcParams;
      };
      SymbolTableScope.prototype.get_locals = function() {
        Sk.asserts.assert(this.get_type() == "function", "get_locals only valid for function scopes");
        if (!this._funcLocals) {
          this._funcLocals = this._identsMatching(function(x) {
            return x & DEF_BOUND;
          });
        }
        return this._funcLocals;
      };
      SymbolTableScope.prototype.get_globals = function() {
        Sk.asserts.assert(this.get_type() == "function", "get_globals only valid for function scopes");
        if (!this._funcGlobals) {
          this._funcGlobals = this._identsMatching(function(x) {
            var masked = x >> SCOPE_OFF & SCOPE_MASK;
            return masked == GLOBAL_IMPLICIT || masked == GLOBAL_EXPLICIT;
          });
        }
        return this._funcGlobals;
      };
      SymbolTableScope.prototype.get_frees = function() {
        Sk.asserts.assert(this.get_type() == "function", "get_frees only valid for function scopes");
        if (!this._funcFrees) {
          this._funcFrees = this._identsMatching(function(x) {
            var masked = x >> SCOPE_OFF & SCOPE_MASK;
            return masked == FREE;
          });
        }
        return this._funcFrees;
      };
      SymbolTableScope.prototype.get_methods = function() {
        var i;
        var all;
        Sk.asserts.assert(this.get_type() == "class", "get_methods only valid for class scopes");
        if (!this._classMethods) {
          all = [];
          for (i = 0; i < this.children.length; ++i) {
            all.push(this.children[i].name);
          }
          all.sort();
          this._classMethods = all;
        }
        return this._classMethods;
      };
      SymbolTableScope.prototype.getScope = function(name) {
        var v = this.symFlags[name];
        if (v === void 0) {
          return 0;
        }
        return v >> SCOPE_OFF & SCOPE_MASK;
      };
      function SymbolTable(filename) {
        this.filename = filename;
        this.cur = null;
        this.top = null;
        this.stack = [];
        this.global = null;
        this.curClass = null;
        this.tmpname = 0;
        this.stss = {};
      }
      SymbolTable.prototype.getStsForAst = function(ast) {
        var v;
        Sk.asserts.assert(ast.scopeId !== void 0, "ast wasn't added to st?");
        v = this.stss[ast.scopeId];
        Sk.asserts.assert(v !== void 0, "unknown sym tab entry");
        return v;
      };
      SymbolTable.prototype.SEQStmt = function(nodes) {
        var val;
        var i;
        var len;
        if (nodes !== null) {
          Sk.asserts.assert(Sk.isArrayLike(nodes), "SEQ: nodes isn't array? got " + nodes.toString());
          len = nodes.length;
          for (i = 0; i < len; ++i) {
            val = nodes[i];
            if (val) {
              this.visitStmt(val);
            }
          }
        }
      };
      SymbolTable.prototype.SEQExpr = function(nodes) {
        var val;
        var i;
        var len;
        if (nodes !== null) {
          Sk.asserts.assert(Sk.isArrayLike(nodes), "SEQ: nodes isn't array? got " + nodes.toString());
          len = nodes.length;
          for (i = 0; i < len; ++i) {
            val = nodes[i];
            if (val) {
              this.visitExpr(val);
            }
          }
        }
      };
      SymbolTable.prototype.enterBlock = function(name, blockType, ast, lineno) {
        var prev;
        name = Sk.fixReserved(name);
        prev = null;
        if (this.cur) {
          prev = this.cur;
          this.stack.push(this.cur);
        }
        this.cur = new SymbolTableScope(this, name, blockType, ast, lineno);
        if (name === "top") {
          this.global = this.cur.symFlags;
        }
        if (prev) {
          prev.children.push(this.cur);
        }
      };
      SymbolTable.prototype.exitBlock = function() {
        this.cur = null;
        if (this.stack.length > 0) {
          this.cur = this.stack.pop();
        }
      };
      SymbolTable.prototype.visitParams = function(args, toplevel, lineno) {
        var arg;
        var i;
        for (i = 0; i < args.length; ++i) {
          arg = args[i];
          if (arg.constructor === Sk.astnodes.arg) {
            this.addDef(arg.arg, DEF_PARAM, lineno);
          } else {
            throw new Sk.builtin.SyntaxError(
              "invalid expression in parameter list",
              this.filename,
              lineno
            );
          }
        }
      };
      SymbolTable.prototype.visitAnnotations = function(a, returns) {
        if (a.posonlyargs) {
          this.visitArgAnnotations(a.posonlyargs);
        }
        if (a.args) {
          this.visitArgAnnotations(a.args);
        }
        if (a.vararg && a.vararg.annotation) {
          this.visitExpr(a.vararg.annotation);
        }
        if (a.kwarg && a.kwarg.annotation) {
          this.visitExpr(a.kwarg.annotation);
        }
        if (a.kwonlyargs) {
          this.visitArgAnnotations(a.kwonlyargs);
        }
        if (returns) {
          this.visitExpr(returns);
        }
      };
      SymbolTable.prototype.visitArgAnnotations = function(args) {
        for (let i = 0; i < args.length; i++) {
          const arg = args[i];
          if (arg.annotation) {
            this.visitExpr(arg.annotation);
          }
        }
      };
      SymbolTable.prototype.visitArguments = function(a, lineno) {
        if (a.args) {
          this.visitParams(a.args, true, lineno);
        }
        if (a.kwonlyargs) {
          this.visitParams(a.kwonlyargs, true, lineno);
        }
        if (a.vararg) {
          this.addDef(a.vararg.arg, DEF_PARAM, lineno);
          this.cur.varargs = true;
        }
        if (a.kwarg) {
          this.addDef(a.kwarg.arg, DEF_PARAM, lineno);
          this.cur.varkeywords = true;
        }
      };
      SymbolTable.prototype.newTmpname = function(lineno) {
        this.addDef(new Sk.builtin.str("_[" + ++this.tmpname + "]"), DEF_LOCAL, lineno);
      };
      SymbolTable.prototype.addDef = function(name, flag, lineno) {
        var fromGlobal;
        var val;
        var mangled = Sk.mangleName(this.curClass, name).v;
        mangled = Sk.fixReserved(mangled);
        val = this.cur.symFlags[mangled];
        if (val !== void 0) {
          if (flag & DEF_PARAM && val & DEF_PARAM) {
            throw new Sk.builtin.SyntaxError(
              "duplicate argument '" + name.v + "' in function definition",
              this.filename,
              lineno
            );
          }
          val |= flag;
        } else {
          val = flag;
        }
        this.cur.symFlags[mangled] = val;
        if (flag & DEF_PARAM) {
          this.cur.varnames.push(mangled);
        } else if (flag & DEF_GLOBAL) {
          val = flag;
          fromGlobal = this.global[mangled];
          if (fromGlobal !== void 0) {
            val |= fromGlobal;
          }
          this.global[mangled] = val;
        }
      };
      SymbolTable.prototype.visitSlice = function(s) {
        var i;
        switch (s.constructor) {
          case Sk.astnodes.Slice:
            if (s.lower) {
              this.visitExpr(s.lower);
            }
            if (s.upper) {
              this.visitExpr(s.upper);
            }
            if (s.step) {
              this.visitExpr(s.step);
            }
            break;
          case Sk.astnodes.ExtSlice:
            for (i = 0; i < s.dims.length; ++i) {
              this.visitSlice(s.dims[i]);
            }
            break;
          case Sk.astnodes.Index:
            this.visitExpr(s.value);
            break;
          case Sk.astnodes.Ellipsis:
            break;
        }
      };
      SymbolTable.prototype.visitStmt = function(s) {
        var cur;
        var name;
        var i;
        var nameslen;
        var tmp;
        var e_name;
        Sk.asserts.assert(s !== void 0, "visitStmt called with undefined");
        switch (s.constructor) {
          case Sk.astnodes.FunctionDef:
            this.addDef(s.name, DEF_LOCAL, s.lineno);
            if (s.args.defaults) {
              this.SEQExpr(s.args.defaults);
            }
            if (s.decorator_list) {
              this.SEQExpr(s.decorator_list);
            }
            if (s.args.kw_defaults) {
              this.SEQExpr(s.args.kw_defaults);
            }
            this.visitAnnotations(s.args, s.returns);
            this.enterBlock(s.name.v, FunctionBlock, s, s.lineno);
            this.visitArguments(s.args, s.lineno);
            this.SEQStmt(s.body);
            this.exitBlock();
            break;
          case Sk.astnodes.ClassDef:
            this.addDef(s.name, DEF_LOCAL, s.lineno);
            this.SEQExpr(s.bases);
            if (s.decorator_list) {
              this.SEQExpr(s.decorator_list);
            }
            this.enterBlock(s.name.v, ClassBlock, s, s.lineno);
            tmp = this.curClass;
            this.curClass = s.name;
            this.SEQStmt(s.body);
            this.exitBlock();
            break;
          case Sk.astnodes.Return:
            if (s.value) {
              this.visitExpr(s.value);
              this.cur.returnsValue = true;
              if (this.cur.generator) {
                throw new Sk.builtin.SyntaxError(
                  "'return' with argument inside generator",
                  this.filename,
                  s.lineno
                );
              }
            }
            break;
          case Sk.astnodes.Delete:
            this.SEQExpr(s.targets);
            break;
          case Sk.astnodes.Assign:
            this.SEQExpr(s.targets);
            this.visitExpr(s.value);
            break;
          case Sk.astnodes.AnnAssign:
            if (s.target.constructor == Sk.astnodes.Name) {
              e_name = s.target;
              name = Sk.mangleName(this.curClass, e_name.id).v;
              name = Sk.fixReserved(name);
              cur = this.cur.symFlags[name];
              if (cur & (DEF_GLOBAL | DEF_NONLOCAL) && this.global != this.cur.symFlags && // TODO
              s.simple) {
                throw new Sk.builtin.SyntaxError(
                  "annotated name '" + name + "' can't be global",
                  this.filename,
                  s.lineno
                );
              }
              if (s.simple) {
                this.addDef(new Sk.builtin.str(name), DEF_ANNOT | DEF_LOCAL, s.lineno);
              } else if (s.value) {
                this.addDef(new Sk.builtin.str(name), DEF_LOCAL, s.lineno);
              }
            } else {
              this.visitExpr(s.target);
            }
            this.visitExpr(s.annotation);
            if (s.value) {
              this.visitExpr(s.value);
            }
            break;
          case Sk.astnodes.AugAssign:
            this.visitExpr(s.target);
            this.visitExpr(s.value);
            break;
          case Sk.astnodes.Print:
            if (s.dest) {
              this.visitExpr(s.dest);
            }
            this.SEQExpr(s.values);
            break;
          case Sk.astnodes.For:
            this.visitExpr(s.target);
            this.visitExpr(s.iter);
            this.SEQStmt(s.body);
            if (s.orelse) {
              this.SEQStmt(s.orelse);
            }
            break;
          case Sk.astnodes.While:
            this.visitExpr(s.test);
            this.SEQStmt(s.body);
            if (s.orelse) {
              this.SEQStmt(s.orelse);
            }
            break;
          case Sk.astnodes.If:
            this.visitExpr(s.test);
            this.SEQStmt(s.body);
            if (s.orelse) {
              this.SEQStmt(s.orelse);
            }
            break;
          case Sk.astnodes.Raise:
            if (s.exc) {
              this.visitExpr(s.exc);
              if (s.inst) {
                this.visitExpr(s.inst);
                if (s.tback) {
                  this.visitExpr(s.tback);
                }
              }
              if (s.cause) {
                this.visitExpr(s.cause);
              }
            }
            break;
          case Sk.astnodes.Assert:
            this.visitExpr(s.test);
            if (s.msg) {
              this.visitExpr(s.msg);
            }
            break;
          case Sk.astnodes.Import:
          case Sk.astnodes.ImportFrom:
            this.visitAlias(s.names, s.lineno);
            break;
          case Sk.astnodes.Global:
            nameslen = s.names.length;
            for (i = 0; i < nameslen; ++i) {
              name = Sk.mangleName(this.curClass, s.names[i]).v;
              name = Sk.fixReserved(name);
              cur = this.cur.symFlags[name];
              if (cur & (DEF_LOCAL | USE)) {
                if (cur & DEF_LOCAL) {
                  throw new Sk.builtin.SyntaxError(
                    "name '" + name + "' is assigned to before global declaration",
                    this.filename,
                    s.lineno
                  );
                } else {
                  throw new Sk.builtin.SyntaxError(
                    "name '" + name + "' is used prior to global declaration",
                    this.filename,
                    s.lineno
                  );
                }
              }
              this.addDef(new Sk.builtin.str(name), DEF_GLOBAL, s.lineno);
            }
            break;
          case Sk.astnodes.Expr:
            this.visitExpr(s.value);
            break;
          case Sk.astnodes.Pass:
          case Sk.astnodes.Break:
          case Sk.astnodes.Continue:
          case Sk.astnodes.Debugger:
            break;
          case Sk.astnodes.With:
            VISIT_SEQ(this.visit_withitem.bind(this), s.items);
            VISIT_SEQ(this.visitStmt.bind(this), s.body);
            break;
          case Sk.astnodes.Try:
            this.SEQStmt(s.body);
            this.visitExcepthandlers(s.handlers);
            this.SEQStmt(s.orelse);
            this.SEQStmt(s.finalbody);
            break;
          default:
            Sk.asserts.fail("Unhandled type " + s.constructor.name + " in visitStmt");
        }
      };
      SymbolTable.prototype.visit_withitem = function(item) {
        this.visitExpr(item.context_expr);
        if (item.optional_vars) {
          this.visitExpr(item.optional_vars);
        }
      };
      function VISIT_SEQ(visitFunc, seq) {
        var i;
        for (i = 0; i < seq.length; i++) {
          var elt = seq[i];
          visitFunc(elt);
        }
      }
      SymbolTable.prototype.visitExpr = function(e) {
        var i;
        Sk.asserts.assert(e !== void 0, "visitExpr called with undefined");
        switch (e.constructor) {
          case Sk.astnodes.BoolOp:
            this.SEQExpr(e.values);
            break;
          case Sk.astnodes.BinOp:
            this.visitExpr(e.left);
            this.visitExpr(e.right);
            break;
          case Sk.astnodes.UnaryOp:
            this.visitExpr(e.operand);
            break;
          case Sk.astnodes.Lambda:
            this.addDef(new Sk.builtin.str("lambda"), DEF_LOCAL, e.lineno);
            if (e.args.defaults) {
              this.SEQExpr(e.args.defaults);
            }
            this.enterBlock("lambda", FunctionBlock, e, e.lineno);
            this.visitArguments(e.args, e.lineno);
            this.visitExpr(e.body);
            this.exitBlock();
            break;
          case Sk.astnodes.IfExp:
            this.visitExpr(e.test);
            this.visitExpr(e.body);
            this.visitExpr(e.orelse);
            break;
          case Sk.astnodes.Dict:
            this.SEQExpr(e.keys);
            this.SEQExpr(e.values);
            break;
          case Sk.astnodes.DictComp:
            this.newTmpname(e.lineno);
            this.visitExpr(e.key);
            this.visitExpr(e.value);
            this.visitComprehension(e.generators, 0);
            break;
          case Sk.astnodes.SetComp:
            this.newTmpname(e.lineno);
            this.visitExpr(e.elt);
            this.visitComprehension(e.generators, 0);
            break;
          case Sk.astnodes.ListComp:
            this.newTmpname(e.lineno);
            this.visitExpr(e.elt);
            this.visitComprehension(e.generators, 0);
            break;
          case Sk.astnodes.GeneratorExp:
            this.visitGenexp(e);
            break;
          case Sk.astnodes.YieldFrom:
          case Sk.astnodes.Yield:
            if (e.value) {
              this.visitExpr(e.value);
            }
            this.cur.generator = true;
            if (this.cur.returnsValue) {
              throw new Sk.builtin.SyntaxError(
                "'return' with argument inside generator",
                this.filename,
                e.lineno
              );
            }
            break;
          case Sk.astnodes.Compare:
            this.visitExpr(e.left);
            this.SEQExpr(e.comparators);
            break;
          case Sk.astnodes.Call:
            this.visitExpr(e.func);
            if (e.args) {
              for (let a of e.args) {
                if (a.constructor === Sk.astnodes.Starred) {
                  this.visitExpr(a.value);
                } else {
                  this.visitExpr(a);
                }
              }
            }
            if (e.keywords) {
              for (let k of e.keywords) {
                this.visitExpr(k.value);
              }
            }
            break;
          case Sk.astnodes.Num:
          case Sk.astnodes.Str:
          case Sk.astnodes.Bytes:
            break;
          case Sk.astnodes.JoinedStr:
            for (let s of e.values) {
              this.visitExpr(s);
            }
            break;
          case Sk.astnodes.FormattedValue:
            this.visitExpr(e.value);
            if (e.format_spec) {
              this.visitExpr(e.format_spec);
            }
            break;
          case Sk.astnodes.Attribute:
            this.visitExpr(e.value);
            break;
          case Sk.astnodes.Subscript:
            this.visitExpr(e.value);
            this.visitSlice(e.slice);
            break;
          case Sk.astnodes.Name:
            this.addDef(e.id, e.ctx === Sk.astnodes.Load ? USE : DEF_LOCAL, e.lineno);
            break;
          case Sk.astnodes.NameConstant:
            break;
          case Sk.astnodes.List:
          case Sk.astnodes.Tuple:
          case Sk.astnodes.Set:
            this.SEQExpr(e.elts);
            break;
          case Sk.astnodes.Starred:
            this.visitExpr(e.value);
            break;
          case Sk.astnodes.Ellipsis:
            break;
          default:
            Sk.asserts.fail("Unhandled type " + e.constructor.name + " in visitExpr");
        }
      };
      SymbolTable.prototype.visitComprehension = function(lcs, startAt) {
        var lc;
        var i;
        var len = lcs.length;
        for (i = startAt; i < len; ++i) {
          lc = lcs[i];
          this.visitExpr(lc.target);
          this.visitExpr(lc.iter);
          this.SEQExpr(lc.ifs);
        }
      };
      SymbolTable.prototype.visitAlias = function(names, lineno) {
        var dot;
        var storename;
        var name;
        var a;
        var i;
        for (i = 0; i < names.length; ++i) {
          a = names[i];
          name = a.asname === null ? a.name.v : a.asname.v;
          storename = name;
          dot = name.indexOf(".");
          if (dot !== -1) {
            storename = name.substr(0, dot);
          }
          if (name !== "*") {
            this.addDef(new Sk.builtin.str(storename), DEF_IMPORT, lineno);
          } else {
            if (this.cur.blockType !== ModuleBlock) {
              throw new Sk.builtin.SyntaxError(
                "import * only allowed at module level",
                this.filename,
                lineno
              );
            }
          }
        }
      };
      SymbolTable.prototype.visitGenexp = function(e) {
        var outermost = e.generators[0];
        this.visitExpr(outermost.iter);
        this.enterBlock("genexpr", FunctionBlock, e, e.lineno);
        this.cur.generator = true;
        this.addDef(new Sk.builtin.str(".0"), DEF_PARAM, e.lineno);
        this.visitExpr(outermost.target);
        this.SEQExpr(outermost.ifs);
        this.visitComprehension(e.generators, 1);
        this.visitExpr(e.elt);
        this.exitBlock();
      };
      SymbolTable.prototype.visitExcepthandlers = function(handlers) {
        var i, eh;
        for (i = 0; eh = handlers[i]; ++i) {
          if (eh.type) {
            this.visitExpr(eh.type);
          }
          if (eh.name) {
            this.visitExpr(eh.name);
          }
          this.SEQStmt(eh.body);
        }
      };
      function _dictUpdate(a, b) {
        var kb;
        for (kb in b) {
          a[kb] = b[kb];
        }
      }
      SymbolTable.prototype.analyzeBlock = function(ste, bound, free, global2) {
        var c;
        var i;
        var childlen;
        var allfree;
        var flags;
        var name;
        var local = {};
        var scope = {};
        var newglobal = {};
        var newbound = {};
        var newfree = {};
        if (ste.blockType == ClassBlock) {
          _dictUpdate(newglobal, global2);
          if (bound) {
            _dictUpdate(newbound, bound);
          }
        }
        for (name in ste.symFlags) {
          flags = ste.symFlags[name];
          this.analyzeName(ste, scope, name, flags, bound, local, free, global2);
        }
        if (ste.blockType !== ClassBlock) {
          if (ste.blockType === FunctionBlock) {
            _dictUpdate(newbound, local);
          }
          if (bound) {
            _dictUpdate(newbound, bound);
          }
          _dictUpdate(newglobal, global2);
        }
        allfree = {};
        childlen = ste.children.length;
        for (i = 0; i < childlen; ++i) {
          c = ste.children[i];
          this.analyzeChildBlock(c, newbound, newfree, newglobal, allfree);
          if (c.hasFree || c.childHasFree) {
            ste.childHasFree = true;
          }
        }
        _dictUpdate(newfree, allfree);
        if (ste.blockType === FunctionBlock) {
          this.analyzeCells(scope, newfree);
        }
        let discoveredFree = this.updateSymbols(
          ste.symFlags,
          scope,
          bound,
          newfree,
          ste.blockType === ClassBlock
        );
        ste.hasFree = ste.hasFree || discoveredFree;
        _dictUpdate(free, newfree);
      };
      SymbolTable.prototype.analyzeChildBlock = function(entry, bound, free, global2, childFree) {
        var tempGlobal;
        var tempFree;
        var tempBound = {};
        _dictUpdate(tempBound, bound);
        tempFree = {};
        _dictUpdate(tempFree, free);
        tempGlobal = {};
        _dictUpdate(tempGlobal, global2);
        this.analyzeBlock(entry, tempBound, tempFree, tempGlobal);
        _dictUpdate(childFree, tempFree);
      };
      SymbolTable.prototype.analyzeCells = function(scope, free) {
        var flags;
        var name;
        for (name in scope) {
          flags = scope[name];
          if (flags !== LOCAL) {
            continue;
          }
          if (free[name] === void 0) {
            continue;
          }
          scope[name] = CELL;
          delete free[name];
        }
      };
      SymbolTable.prototype.updateSymbols = function(symbols, scope, bound, free, classflag) {
        var i;
        var o;
        var pos;
        var freeValue;
        var w;
        var flags;
        var name;
        var discoveredFree = false;
        for (name in symbols) {
          flags = symbols[name];
          w = scope[name];
          flags |= w << SCOPE_OFF;
          symbols[name] = flags;
        }
        freeValue = FREE << SCOPE_OFF;
        pos = 0;
        for (name in free) {
          o = symbols[name];
          if (o !== void 0) {
            if (classflag && o & (DEF_BOUND | DEF_GLOBAL)) {
              i = o | DEF_FREE_CLASS;
              symbols[name] = i;
            }
            continue;
          }
          if (bound[name] === void 0) {
            continue;
          }
          symbols[name] = freeValue;
          discoveredFree = true;
        }
        return discoveredFree;
      };
      SymbolTable.prototype.analyzeName = function(ste, dict, name, flags, bound, local, free, global2) {
        if (flags & DEF_GLOBAL) {
          if (flags & DEF_PARAM) {
            throw new Sk.builtin.SyntaxError(
              "name '" + name + "' is local and global",
              this.filename,
              ste.lineno
            );
          }
          dict[name] = GLOBAL_EXPLICIT;
          global2[name] = null;
          if (bound && bound[name] !== void 0) {
            delete bound[name];
          }
          return;
        }
        if (flags & DEF_BOUND) {
          dict[name] = LOCAL;
          local[name] = null;
          delete global2[name];
          return;
        }
        if (bound && bound[name] !== void 0) {
          dict[name] = FREE;
          ste.hasFree = true;
          free[name] = null;
        } else if (global2 && global2[name] !== void 0) {
          dict[name] = GLOBAL_IMPLICIT;
        } else {
          if (ste.isNested) {
            ste.hasFree = true;
          }
          dict[name] = GLOBAL_IMPLICIT;
        }
      };
      SymbolTable.prototype.analyze = function() {
        var free = {};
        var global2 = {};
        this.analyzeBlock(this.top, null, free, global2);
      };
      Sk.symboltable = function(ast, filename) {
        var i;
        var ret = new SymbolTable(filename);
        ret.enterBlock("top", ModuleBlock, ast, 0);
        ret.top = ret.cur;
        for (i = 0; i < ast.body.length; ++i) {
          ret.visitStmt(ast.body[i]);
        }
        ret.exitBlock();
        ret.analyze();
        return ret;
      };
      Sk.dumpSymtab = function(st) {
        var pyBoolStr = function(b) {
          return b ? "True" : "False";
        };
        var pyList = function(l) {
          var i;
          var ret = [];
          for (i = 0; i < l.length; ++i) {
            ret.push(new Sk.builtin.str(l[i])["$r"]().v);
          }
          return "[" + ret.join(", ") + "]";
        };
        var getIdents = function(obj, indent) {
          var ns;
          var j;
          var sub;
          var nsslen;
          var nss;
          var info;
          var i;
          var objidentslen;
          var objidents;
          var ret;
          if (indent === void 0) {
            indent = "";
          }
          ret = "";
          ret += indent + "Sym_type: " + obj.get_type() + "\n";
          ret += indent + "Sym_name: " + obj.get_name() + "\n";
          ret += indent + "Sym_lineno: " + obj.get_lineno() + "\n";
          ret += indent + "Sym_nested: " + pyBoolStr(obj.is_nested()) + "\n";
          ret += indent + "Sym_haschildren: " + pyBoolStr(obj.has_children()) + "\n";
          if (obj.get_type() === "class") {
            ret += indent + "Class_methods: " + pyList(obj.get_methods()) + "\n";
          } else if (obj.get_type() === "function") {
            ret += indent + "Func_params: " + pyList(obj.get_parameters()) + "\n";
            ret += indent + "Func_locals: " + pyList(obj.get_locals()) + "\n";
            ret += indent + "Func_globals: " + pyList(obj.get_globals()) + "\n";
            ret += indent + "Func_frees: " + pyList(obj.get_frees()) + "\n";
          }
          ret += indent + "-- Identifiers --\n";
          objidents = obj.get_identifiers();
          objidentslen = objidents.length;
          for (i = 0; i < objidentslen; ++i) {
            info = obj.lookup(objidents[i]);
            ret += indent + "name: " + info.get_name() + "\n";
            ret += indent + "  is_referenced: " + pyBoolStr(info.is_referenced()) + "\n";
            ret += indent + "  is_imported: " + pyBoolStr(info.is_imported()) + "\n";
            ret += indent + "  is_parameter: " + pyBoolStr(info.is_parameter()) + "\n";
            ret += indent + "  is_global: " + pyBoolStr(info.is_global()) + "\n";
            ret += indent + "  is_declared_global: " + pyBoolStr(info.is_declared_global()) + "\n";
            ret += indent + "  is_local: " + pyBoolStr(info.is_local()) + "\n";
            ret += indent + "  is_free: " + pyBoolStr(info.is_free()) + "\n";
            ret += indent + "  is_assigned: " + pyBoolStr(info.is_assigned()) + "\n";
            ret += indent + "  is_namespace: " + pyBoolStr(info.is_namespace()) + "\n";
            nss = info.get_namespaces();
            nsslen = nss.length;
            ret += indent + "  namespaces: [\n";
            sub = [];
            for (j = 0; j < nsslen; ++j) {
              ns = nss[j];
              sub.push(getIdents(ns, indent + "    "));
            }
            ret += sub.join("\n");
            ret += indent + "  ]\n";
          }
          return ret;
        };
        return getIdents(st.top, "");
      };
      Sk.exportSymbol("Sk.symboltable", Sk.symboltable);
      Sk.exportSymbol("Sk.dumpSymtab", Sk.dumpSymtab);
    }
  });

  // src/compile.js
  var require_compile = __commonJS({
    "src/compile.js"() {
      var out;
      Sk.gensymcount = 0;
      function Compiler(filename, st, flags, canSuspend, sourceCodeForAnnotation) {
        this.filename = filename;
        this.st = st;
        this.flags = flags;
        this.canSuspend = canSuspend;
        this.interactive = false;
        this.nestlevel = 0;
        this.u = null;
        this.consts = {};
        this.stack = [];
        this.result = [];
        this.allUnits = [];
        this.source = sourceCodeForAnnotation ? sourceCodeForAnnotation.split("\n") : false;
        this.retainComments = false;
      }
      function CompilerUnit() {
        this.ste = null;
        this.name = null;
        this.canSuspend = false;
        this.doesSuspend = false;
        this.private_ = null;
        this.firstlineno = 0;
        this.lineno = 0;
        this.linenoSet = false;
        this.localnames = [];
        this.localtemps = [];
        this.tempsToSave = [];
        this.blocknum = 0;
        this.blocks = [];
        this.curblock = 0;
        this.scopename = null;
        this.prefixCode = "";
        this.varDeclsCode = "";
        this.switchCode = "";
        this.suffixCode = "";
        this.breakBlocks = [];
        this.continueBlocks = [];
        this.exceptBlocks = [];
        this.finallyBlocks = [];
      }
      function get_context(ctx) {
        return [ctx.lineno, ctx.col_offset, ctx.end_lineno, ctx.end_col_offset];
      }
      CompilerUnit.prototype.activateScope = function() {
        var self2 = this;
        out = function() {
          var i;
          var b = self2.blocks[self2.curblock];
          if (b._next === null) {
            for (i = 0; i < arguments.length; ++i) {
              b.push(arguments[i]);
            }
          }
        };
      };
      Compiler.prototype.getSourceLine = function(lineno) {
        Sk.asserts.assert(this.source);
        return this.source[lineno - 1];
      };
      Compiler.prototype.annotateSource = function(ast, shouldStep) {
        var i;
        var col_offset;
        var lineno;
        var sourceLine;
        if (this.source) {
          const astName = ast._astname;
          lineno = ast.lineno;
          col_offset = ast.col_offset;
          sourceLine = this.getSourceLine(lineno);
          Sk.asserts.assert(ast.lineno !== void 0 && ast.col_offset !== void 0);
          let isDocstring = !!(ast.constructor === Sk.astnodes.Expr && ast.value.constructor === Sk.astnodes.Str);
          if (shouldStep && (!this.filename || !this.filename.startsWith("src/lib/"))) {
            out("\n$currLineNo=", lineno, ";$currColNo=", col_offset, ";");
            let chompedLine = sourceLine;
            if (chompedLine.length > 24) {
              chompedLine = chompedLine.substr(0, 24) + "...";
            }
            out("Sk.currFilename=$fname;$currSource=", JSON.stringify(chompedLine), ";");
            out(
              `Sk.afterSingleExecution && Sk.afterSingleExecution($gbl,$getLocals(),${lineno}, ${col_offset}, $fname, ${isDocstring}, '${astName}');
`
            );
          }
        }
      };
      Compiler.prototype.gensym = function(hint) {
        hint = hint || "";
        hint = "$" + hint;
        hint += Sk.gensymcount++;
        return hint;
      };
      Compiler.prototype.niceName = function(roughName) {
        return this.gensym(roughName.replace("<", "").replace(">", "").replace(" ", "_"));
      };
      var reservedWords_ = Sk.builtin.str.reservedWords_;
      function fixReserved(name) {
        if (reservedWords_[name] === void 0) {
          return name;
        }
        return name + "_$rw$";
      }
      function unfixReserved(name) {
        return name.replace(/_\$rw\$$/, "");
      }
      function mangleName(priv, ident) {
        var name = ident.v;
        var strpriv = null;
        if (priv === null || name === null || name.charAt(0) !== "_" || name.charAt(1) !== "_") {
          return ident;
        }
        if (name.charAt(name.length - 1) === "_" && name.charAt(name.length - 2) === "_") {
          return ident;
        }
        strpriv = priv.v;
        strpriv.replace(/_/g, "");
        if (strpriv === "") {
          return ident;
        }
        strpriv = priv.v;
        strpriv.replace(/^_*/, "");
        strpriv = new Sk.builtin.str("_" + strpriv + name);
        return strpriv;
      }
      Compiler.prototype.makeConstant = function(rest) {
        var i;
        var v;
        var val = "";
        var cval;
        for (i = 0; i < arguments.length; ++i) {
          val += arguments[i];
        }
        for (var constant in this.consts) {
          if (this.consts.hasOwnProperty(constant)) {
            cval = this.consts[constant];
            if (cval == val) {
              return constant;
            }
          }
        }
        v = "$moduleConstants." + this.gensym("_");
        this.consts[v] = val;
        return v;
      };
      Compiler.prototype._gr = function(hint, rest) {
        var i;
        var v = this.gensym(hint);
        this.u.localtemps.push(v);
        out("var ", v, "=");
        for (i = 1; i < arguments.length; ++i) {
          out(arguments[i]);
        }
        out(";");
        return v;
      };
      Compiler.prototype.outputInterruptTest = function() {
        var output = "";
        if (Sk.execLimit !== null || Sk.yieldLimit !== null && this.u.canSuspend) {
          output += "var $dateNow = Date.now();";
          if (Sk.execLimit !== null) {
            output += "Sk.misceval.timeoutCheck($dateNow);";
          }
          if (Sk.yieldLimit !== null && this.u.canSuspend) {
            output += "if ($dateNow - Sk.lastYield > Sk.yieldLimit) {";
            output += "var $susp = $saveSuspension($mys(), $fname,$currLineNo,$currColNo, $currSource);";
            output += "$susp.$blk = $blk;";
            output += "$susp.optional = true;";
            output += "return $susp;";
            output += "}";
            this.u.doesSuspend = true;
          }
        }
        return output;
      };
      Compiler.prototype._jumpfalse = function(test, block) {
        var cond = this._gr("jfalse", "(", test, "===false||!Sk.misceval.isTrue(", test, "))");
        out("if(", cond, "){/*test failed */$blk=", block, ";continue;}");
      };
      Compiler.prototype._jumpundef = function(test, block) {
        out("if(", test, "===undefined){$blk=", block, ";continue;}");
      };
      Compiler.prototype._jumpnotundef = function(test, block) {
        out("if(", test, "!==undefined){$blk=", block, ";continue;}");
      };
      Compiler.prototype._jumptrue = function(test, block) {
        var cond = this._gr("jtrue", "(", test, "===true||Sk.misceval.isTrue(", test, "))");
        out("if(", cond, "){/*test passed */$blk=", block, ";continue;}");
      };
      Compiler.prototype._jump = function(block) {
        if (this.u.blocks[this.u.curblock]._next === null) {
          out("$blk=", block, ";");
          this.u.blocks[this.u.curblock]._next = block;
        }
      };
      Compiler.prototype._checkSuspension = function(e) {
        var retblk;
        if (this.u.canSuspend) {
          retblk = this.newBlock("function return or resume suspension");
          this._jump(retblk);
          this.setBlock(retblk);
          e = e || { lineno: "$currLineNo", col_offset: "$currColNo", source: "$currSource" };
          out(
            "if ($ret && $ret.$isSuspension) { return $saveSuspension($ret,$fname," + e.lineno + "," + e.col_offset + "," + e.source + "); }"
          );
          this.u.doesSuspend = true;
          this.u.tempsToSave = this.u.tempsToSave.concat(this.u.localtemps);
        } else {
          out(
            "if ($ret && $ret.$isSuspension) { $ret = Sk.misceval.retryOptionalSuspensionOrThrow($ret); }"
          );
        }
      };
      Compiler.prototype.cunpackstarstoarray = function(elts, permitEndOnly) {
        if (!elts || elts.length == 0) {
          return "[]";
        }
        let hasStars = false;
        for (let elt of elts) {
          if (permitEndOnly && hasStars) {
            throw new Sk.builtin.SyntaxError(
              "Extended argument unpacking is not permitted in Python 2"
            );
          }
          if (elt.constructor === Sk.astnodes.Starred) {
            hasStars = true;
          }
        }
        if (hasStars) {
          let arr = this._gr("unpack", "[]");
          for (let elt of elts) {
            if (elt.constructor !== Sk.astnodes.Starred) {
              out(arr, ".push(", this.vexpr(elt), ");");
            } else {
              out(
                "$ret = Sk.misceval.iterFor(Sk.abstr.iter(",
                this.vexpr(elt.value),
                "), function(e) { ",
                arr,
                ".push(e); });"
              );
              this._checkSuspension();
            }
          }
          return arr;
        } else {
          return "[" + elts.map((expr) => this.vexpr(expr)).join(",") + "]";
        }
      };
      Compiler.prototype.ctuplelistorset = function(e, data, tuporlist) {
        var i;
        var items;
        var item;
        var allconsts;
        Sk.asserts.assert(tuporlist === "tuple" || tuporlist === "list" || tuporlist === "set");
        let hasStars = false;
        let starIdx;
        for (i = 0; i < e.elts.length; i++) {
          if (e.elts[i].constructor === Sk.astnodes.Starred) {
            hasStars = true;
            starIdx = i;
            break;
          }
        }
        if (e.ctx === Sk.astnodes.Store) {
          if (hasStars) {
            if (!Sk.__future__.python3) {
              throw new Sk.builtin.SyntaxError(
                "assignment unpacking with stars is not supported in Python 2",
                this.filename,
                e.lineno
              );
            }
            for (i = starIdx + 1; i < e.elts.length; i++) {
              if (e.elts[i].constructor === Sk.astnodes.Starred) {
                throw new Sk.builtin.SyntaxError(
                  "multiple starred expressions in assignment",
                  this.filename,
                  e.lineno,
                  ...get_context(e)
                );
              }
            }
          }
          const breakIdx = hasStars ? starIdx : e.elts.length;
          const numvals = hasStars ? e.elts.length - 1 : breakIdx;
          out(
            "$ret = Sk.abstr.sequenceUnpack(" + data + "," + breakIdx + "," + numvals + ", " + hasStars + ");"
          );
          this._checkSuspension();
          items = this._gr("items", "$ret");
          for (i = 0; i < e.elts.length; ++i) {
            if (i === starIdx) {
              this.vexpr(e.elts[i].value, items + "[" + i + "]");
            } else {
              this.vexpr(e.elts[i], items + "[" + i + "]");
            }
          }
        } else if (e.ctx === Sk.astnodes.Load || tuporlist === "set") {
          if (hasStars) {
            if (!Sk.__future__.python3) {
              throw new Sk.builtin.SyntaxError(
                "List packing with stars is not supported in Python 2"
              );
            }
            return this._gr(
              "load" + tuporlist,
              "new Sk.builtins['",
              tuporlist,
              "'](",
              this.cunpackstarstoarray(e.elts),
              ")"
            );
          } else if (tuporlist === "tuple") {
            allconsts = true;
            items = [];
            for (i = 0; i < e.elts.length; ++i) {
              item = this.vexpr(e.elts[i]);
              if (allconsts && item.indexOf("$const") == -1) {
                allconsts = false;
              }
              items.push(item);
            }
            if (allconsts) {
              return this.makeConstant("new Sk.builtin.tuple([" + items + "])");
            } else {
              for (i = 0; i < items.length; ++i) {
                items[i] = this._gr("elem", items[i]);
              }
              return this._gr(
                "load" + tuporlist,
                "new Sk.builtins['",
                tuporlist,
                "']([",
                items,
                "])"
              );
            }
          } else {
            items = [];
            for (i = 0; i < e.elts.length; ++i) {
              items.push(this._gr("elem", this.vexpr(e.elts[i])));
            }
            return this._gr(
              "load" + tuporlist,
              "new Sk.builtins['",
              tuporlist,
              "']([",
              items,
              "])"
            );
          }
        }
      };
      Compiler.prototype.csubdict = function(e, begin, end) {
        const items = [];
        for (let i = begin; i < end; i++) {
          items.push(this.vexpr(e.keys[i]));
          items.push(this.vexpr(e.values[i]));
        }
        return this._gr("loaddict", "new Sk.builtins['dict']([", items, "])");
      };
      Compiler.prototype.cdict = function(e) {
        let have_dict = 0;
        let is_unpacking = false;
        const n = e.values ? e.values.length : 0;
        let elements = 0;
        let main_dict;
        let sub_dict;
        for (let i = 0; i < n; i++) {
          is_unpacking = e.keys[i] === null;
          if (is_unpacking) {
            if (elements) {
              sub_dict = this.csubdict(e, i - elements, i);
              if (have_dict) {
                out(main_dict, ".dict$merge(", sub_dict, ");");
              } else {
                main_dict = sub_dict;
                have_dict = 1;
              }
              elements = 0;
            }
            if (have_dict === 0) {
              main_dict = this._gr("loaddict", "new Sk.builtins.dict([])");
              have_dict = 1;
            }
            sub_dict = this.vexpr(e.values[i]);
            out("$ret = ", main_dict, ".dict$merge(", sub_dict, ");");
            this._checkSuspension(e);
          } else {
            elements++;
          }
        }
        if (elements) {
          sub_dict = this.csubdict(e, n - elements, n);
          if (have_dict) {
            out(main_dict, ".dict$merge(", sub_dict, ");");
          } else {
            main_dict = sub_dict;
            have_dict = 1;
          }
        }
        if (have_dict === 0) {
          main_dict = this._gr("loaddict", "new Sk.builtins.dict([])");
        }
        return main_dict;
      };
      Compiler.prototype.clistcomp = function(e) {
        Sk.asserts.assert(e instanceof Sk.astnodes.ListComp);
        var tmp = this._gr("_compr", "new Sk.builtins['list']([])");
        return this.ccompgen("list", tmp, e.generators, 0, e.elt, null, e);
      };
      Compiler.prototype.cdictcomp = function(e) {
        Sk.asserts.assert(e instanceof Sk.astnodes.DictComp);
        var tmp = this._gr("_dcompr", "new Sk.builtins.dict([])");
        return this.ccompgen("dict", tmp, e.generators, 0, e.value, e.key, e);
      };
      Compiler.prototype.csetcomp = function(e) {
        Sk.asserts.assert(e instanceof Sk.astnodes.SetComp);
        var tmp = this._gr("_setcompr", "new Sk.builtins.set([])");
        return this.ccompgen("set", tmp, e.generators, 0, e.elt, null, e);
      };
      Compiler.prototype.ccompgen = function(type, tmpname, generators, genIndex, value, key, e) {
        var start = this.newBlock(type + " comp start");
        var skip = this.newBlock(type + " comp skip");
        var anchor = this.newBlock(type + " comp anchor");
        var l = generators[genIndex];
        var toiter = this.vexpr(l.iter);
        var iter = this._gr("iter", "Sk.abstr.iter(", toiter, ")");
        var lvalue;
        var lkey;
        var ifres;
        var i;
        var target;
        var nexti;
        var n;
        this._jump(start);
        this.setBlock(start);
        out("$ret = Sk.abstr.iternext(", iter, ", true);");
        this._checkSuspension(e);
        nexti = this._gr("next", "$ret");
        this._jumpundef(nexti, anchor);
        target = this.vexpr(l.target, nexti);
        n = l.ifs ? l.ifs.length : 0;
        for (i = 0; i < n; ++i) {
          ifres = this.vexpr(l.ifs[i]);
          this._jumpfalse(ifres, start);
        }
        if (++genIndex < generators.length) {
          this.ccompgen(type, tmpname, generators, genIndex, value, key, e);
        }
        if (genIndex >= generators.length) {
          lvalue = this.vexpr(value);
          if (type === "dict") {
            lkey = this.vexpr(key);
            out(tmpname, ".mp$ass_subscript(", lkey, ",", lvalue, ");");
          } else if (type === "list") {
            out(tmpname, ".v.push(", lvalue, ");");
          } else if (type === "set") {
            out(tmpname, ".v.mp$ass_subscript(", lvalue, ", true);");
          }
          this._jump(skip);
          this.setBlock(skip);
        }
        this._jump(start);
        this.setBlock(anchor);
        return tmpname;
      };
      Compiler.prototype.cyield = function(e) {
        if (this.u.ste.blockType !== Sk.SYMTAB_CONSTS.FunctionBlock) {
          throw new Sk.builtin.SyntaxError(
            "'yield' outside function",
            this.filename,
            e.lineno,
            ...get_context(e)
          );
        }
        var val = "Sk.builtin.none.none$", nextBlock;
        if (e.value) {
          val = this.vexpr(e.value);
        }
        nextBlock = this.newBlock("after yield");
        out("return [/*resume*/", nextBlock, ",/*ret*/", val, "];");
        this.setBlock(nextBlock);
        return "$gen.gi$sentvalue";
      };
      Compiler.prototype.cyieldfrom = function(e) {
        if (this.u.ste.blockType !== Sk.SYMTAB_CONSTS.FunctionBlock) {
          throw new Sk.builtin.SyntaxError(
            "'yield' outside function",
            this.filename,
            e.lineno,
            ...get_context(e)
          );
        }
        let iterable = this.vexpr(e.value);
        iterable = this._gr("iter", "Sk.abstr.iter(", iterable, ")");
        out("$gen." + iterable + "=", iterable, ";");
        var afterIter = this.newBlock("after iter");
        var afterBlock = this.newBlock("after yield from");
        this._jump(afterIter);
        this.setBlock(afterIter);
        var retval = this.gensym("retval");
        out(iterable, "=$gen.", iterable, ";");
        out("var ", retval, ";");
        out(
          "if ($gen.gi$sentvalue === Sk.builtin.none.none$ || " + iterable + ".constructor === Sk.builtin.generator) {"
        );
        out("$ret=", iterable, ".tp$iternext(true, $gen.gi$sentvalue);");
        out("} else {");
        var send = this.makeConstant("new Sk.builtin.str('send');");
        out("$ret=Sk.misceval.tryCatch(");
        out("function(){");
        out(
          "return Sk.misceval.callsimOrSuspendArray(Sk.abstr.gattr(",
          iterable,
          ",",
          send,
          "), [$gen.gi$sentvalue]);},"
        );
        out("function (e) { ");
        out("if (e instanceof Sk.builtin.StopIteration) { ");
        out(iterable, ".gi$ret = e.$value;");
        out("return undefined;");
        out("} else { throw e; }");
        out("}");
        out(");");
        out("}");
        this._checkSuspension(e);
        out(retval, "=$ret;");
        out("if(", retval, "===undefined) {");
        out("$gen.gi$sentvalue=$gen." + iterable + ".gi$ret;");
        out("$blk=", afterBlock, ";continue;");
        out("}");
        out("return [/*resume*/", afterIter, ",/*ret*/", retval, "];");
        this.setBlock(afterBlock);
        return "$gen.gi$sentvalue";
      };
      Compiler.prototype.ccompare = function(e) {
        var res;
        var rhs;
        var i;
        var fres;
        var done;
        var n;
        var cur;
        Sk.asserts.assert(e.ops.length === e.comparators.length);
        cur = this.vexpr(e.left);
        n = e.ops.length;
        done = this.newBlock("done");
        fres = this._gr("compareres", "null");
        for (i = 0; i < n; ++i) {
          rhs = this.vexpr(e.comparators[i]);
          out(
            "$ret = Sk.misceval.richCompareBool(",
            cur,
            ",",
            rhs,
            ",'",
            e.ops[i].prototype._astname,
            "', true);"
          );
          this._checkSuspension(e);
          out(fres, "=Sk.builtin.bool($ret);");
          this._jumpfalse("$ret", done);
          cur = rhs;
        }
        this._jump(done);
        this.setBlock(done);
        return fres;
      };
      Compiler.prototype.ccall = function(e) {
        var func = this.vexpr(e.func);
        var kwarray = null;
        let positionalArgs = this.cunpackstarstoarray(e.args, !Sk.__future__.python3);
        let keywordArgs = "undefined";
        if (e.keywords && e.keywords.length > 0) {
          let hasStars = false;
          kwarray = [];
          for (let kw of e.keywords) {
            if (hasStars && !Sk.__future__.python3) {
              throw new Sk.builtin.SyntaxError(
                "Advanced unpacking of function arguments is not supported in Python 2"
              );
            }
            if (kw.arg) {
              kwarray.push("'" + kw.arg.v + "'");
              kwarray.push(this.vexpr(kw.value));
            } else {
              hasStars = true;
            }
          }
          keywordArgs = "[" + kwarray.join(",") + "]";
          if (hasStars) {
            keywordArgs = this._gr("keywordArgs", keywordArgs);
            for (let kw of e.keywords) {
              if (!kw.arg) {
                out(
                  "$ret = Sk.abstr.mappingUnpackIntoKeywordArray(",
                  keywordArgs,
                  ",",
                  this.vexpr(kw.value),
                  ",",
                  func,
                  ");"
                );
                this._checkSuspension();
              }
            }
          }
        }
        if (Sk.__future__.super_args && e.func.id && e.func.id.v === "super" && positionalArgs === "[]") {
          out(
            'if (typeof self === "undefined" || self===window) { throw new Sk.builtin.RuntimeError("super(): no arguments") };'
          );
          positionalArgs = "[__class__,self]";
        }
        out(
          "$ret = (",
          func,
          ".tp$call)?",
          func,
          ".tp$call(",
          positionalArgs,
          ",",
          keywordArgs,
          ") : Sk.misceval.applyOrSuspend(",
          func,
          ",undefined,undefined,",
          keywordArgs,
          ",",
          positionalArgs,
          ");"
        );
        this._checkSuspension(e);
        return this._gr("call", "$ret");
      };
      Compiler.prototype.cslice = function(s) {
        var step;
        var high;
        var low;
        Sk.asserts.assert(s instanceof Sk.astnodes.Slice);
        if (Sk.__future__.python3) {
          low = s.lower ? this.vexpr(s.lower) : "Sk.builtin.none.none$";
          high = s.upper ? this.vexpr(s.upper) : "Sk.builtin.none.none$";
          step = s.step ? this.vexpr(s.step) : "Sk.builtin.none.none$";
        } else {
          low = s.lower ? this.vexpr(s.lower) : s.step ? "Sk.builtin.none.none$" : "new Sk.builtin.int_(0)";
          high = s.upper ? this.vexpr(s.upper) : s.step ? "Sk.builtin.none.none$" : "new Sk.builtin.int_(2147483647)";
          step = s.step ? this.vexpr(s.step) : "Sk.builtin.none.none$";
        }
        return this._gr("slice", "new Sk.builtins['slice'](", low, ",", high, ",", step, ")");
      };
      Compiler.prototype.eslice = function(dims) {
        var i;
        var dimSubs, subs;
        Sk.asserts.assert(dims instanceof Array);
        dimSubs = [];
        for (i = 0; i < dims.length; i++) {
          dimSubs.push(this.vslicesub(dims[i]));
        }
        return this._gr("extslice", "new Sk.builtins['tuple']([", dimSubs, "])");
      };
      Compiler.prototype.vslicesub = function(s) {
        var subs;
        switch (s.constructor) {
          case Sk.astnodes.Index:
            subs = this.vexpr(s.value);
            break;
          case Sk.astnodes.Slice:
            subs = this.cslice(s);
            break;
          case Sk.astnodes.Ellipsis:
            Sk.asserts.fail("todo compile.js Ellipsis;");
            break;
          case Sk.astnodes.ExtSlice:
            subs = this.eslice(s.dims);
            break;
          default:
            Sk.asserts.fail("invalid subscript kind");
        }
        return subs;
      };
      Compiler.prototype.vslice = function(s, ctx, obj, dataToStore) {
        var subs = this.vslicesub(s);
        return this.chandlesubscr(ctx, obj, subs, dataToStore);
      };
      Compiler.prototype.chandlesubscr = function(ctx, obj, subs, data) {
        if (ctx === Sk.astnodes.Load || ctx === Sk.astnodes.AugLoad) {
          out("$ret = Sk.abstr.objectGetItem(", obj, ",", subs, ", true);");
          this._checkSuspension();
          return this._gr("lsubscr", "$ret");
        } else if (ctx === Sk.astnodes.Store || ctx === Sk.astnodes.AugStore) {
          out("$ret = Sk.abstr.objectSetItem(", obj, ",", subs, ",", data, ", true);");
          this._checkSuspension();
        } else if (ctx === Sk.astnodes.Del) {
          out("Sk.abstr.objectDelItem(", obj, ",", subs, ");");
        } else {
          Sk.asserts.fail("handlesubscr fail");
        }
      };
      Compiler.prototype.cboolop = function(e) {
        var expres;
        var i;
        var retval;
        var n;
        var s;
        var end;
        var ifFailed;
        var jtype;
        Sk.asserts.assert(e instanceof Sk.astnodes.BoolOp);
        if (e.op === Sk.astnodes.And) {
          jtype = this._jumpfalse;
        } else {
          jtype = this._jumptrue;
        }
        end = this.newBlock("end of boolop");
        s = e.values;
        n = s.length;
        for (i = 0; i < n; ++i) {
          expres = this.vexpr(s[i]);
          if (i === 0) {
            retval = this._gr("boolopsucc", expres);
          }
          out(retval, "=", expres, ";");
          jtype.call(this, expres, end);
        }
        this._jump(end);
        this.setBlock(end);
        return retval;
      };
      Compiler.prototype.cjoinedstr = function(e) {
        let ret;
        Sk.asserts.assert(e instanceof Sk.astnodes.JoinedStr);
        for (let s of e.values) {
          let v = this.vexpr(s);
          if (!ret) {
            ret = this._gr("joinedstr", v);
          } else {
            out(ret, "=", ret, ".sq$concat(", v, ");");
          }
        }
        if (!ret) {
          ret = "Sk.builtin.str.$emptystr";
        }
        return ret;
      };
      Compiler.prototype.cformattedvalue = function(e) {
        let value = this.vexpr(e.value);
        switch (e.conversion) {
          case "s":
            value = this._gr("value", "new Sk.builtin.str(", value, ")");
            break;
          case "a":
            value = this._gr("value", "Sk.builtin.ascii(", value, ")");
            break;
          case "r":
            value = this._gr("value", "Sk.builtin.repr(", value, ")");
            break;
        }
        let formatSpec = e.format_spec ? this.vexpr(e.format_spec) : "Sk.builtin.str.$emptystr";
        return this._gr("formatted", "Sk.abstr.objectFormat(" + value + "," + formatSpec + ")");
      };
      function getJsLiteralForString(s) {
        let r = '"';
        for (let i = 0; i < s.length; i++) {
          let c = s.charCodeAt(i);
          if (c == 10) {
            r += "\\n";
          } else if (c == 92) {
            r += "\\\\";
          } else if (c == 34 || c < 32 || c >= 127 && c < 256) {
            r += "\\x" + ("0" + c.toString(16)).substr(-2);
          } else if (c >= 256) {
            r += "\\u" + ("000" + c.toString(16)).substr(-4);
          } else {
            r += s.charAt(i);
          }
        }
        r += '"';
        return r;
      }
      Compiler.prototype.vexpr = function(e, data, augvar, augsubs) {
        var mangled, mname;
        var val;
        var result;
        var nStr;
        if (e.lineno > this.u.lineno) {
          this.u.lineno = e.lineno;
          this.u.linenoSet = false;
        }
        switch (e.constructor) {
          case Sk.astnodes.BoolOp:
            return this.cboolop(e);
          case Sk.astnodes.BinOp:
            return this._gr(
              "binop",
              "Sk.abstr.numberBinOp(",
              this.vexpr(e.left),
              ",",
              this.vexpr(e.right),
              ",'",
              e.op.prototype._astname,
              "')"
            );
          case Sk.astnodes.UnaryOp:
            return this._gr(
              "unaryop",
              "Sk.abstr.numberUnaryOp(",
              this.vexpr(e.operand),
              ",'",
              e.op.prototype._astname,
              "')"
            );
          case Sk.astnodes.Lambda:
            return this.clambda(e);
          case Sk.astnodes.IfExp:
            return this.cifexp(e);
          case Sk.astnodes.Dict:
            return this.cdict(e);
          case Sk.astnodes.ListComp:
            return this.clistcomp(e);
          case Sk.astnodes.DictComp:
            return this.cdictcomp(e);
          case Sk.astnodes.SetComp:
            return this.csetcomp(e);
          case Sk.astnodes.GeneratorExp:
            return this.cgenexp(e);
          case Sk.astnodes.Yield:
            return this.cyield(e);
          case Sk.astnodes.YieldFrom:
            return this.cyieldfrom(e);
          case Sk.astnodes.Compare:
            return this.ccompare(e);
          case Sk.astnodes.Call:
            result = this.ccall(e);
            this.annotateSource(e, true);
            return result;
          case Sk.astnodes.Num:
            if (typeof e.n === "number") {
              return e.n;
            } else if (e.n instanceof Sk.builtin.lng) {
              return this.makeConstant("new Sk.builtin.lng('" + e.n.v.toString() + "')");
            } else if (e.n instanceof Sk.builtin.int_) {
              if (typeof e.n.v === "number") {
                return this.makeConstant("new Sk.builtin.int_(" + e.n.v + ")");
              }
              return this.makeConstant("new Sk.builtin.int_('" + e.n.v.toString() + "')");
            } else if (e.n instanceof Sk.builtin.float_) {
              nStr = e.n.v === 0 && 1 / e.n.v === -Infinity ? "-0" : e.n.v;
              return this.makeConstant("new Sk.builtin.float_(" + nStr + ")");
            } else if (e.n instanceof Sk.builtin.complex) {
              var real_val = e.n.real === 0 && 1 / e.n.real === -Infinity ? "-0" : e.n.real;
              var imag_val = e.n.imag === 0 && 1 / e.n.imag === -Infinity ? "-0" : e.n.imag;
              return this.makeConstant(
                "new Sk.builtin.complex(" + real_val + ", " + imag_val + ")"
              );
            }
            Sk.asserts.fail("unhandled Num type");
          case Sk.astnodes.Bytes:
            if (Sk.__future__.python3) {
              const source = [];
              const str = e.s.$jsstr();
              for (let i = 0; i < str.length; i++) {
                source.push(str.charCodeAt(i));
              }
              return this.makeConstant("new Sk.builtin.bytes([", source.join(", "), "])");
            }
          // else fall through and make a string instead
          case Sk.astnodes.Str:
            return this.makeConstant(
              "new Sk.builtin.str(",
              getJsLiteralForString(e.s.$jsstr()),
              ")"
            );
          case Sk.astnodes.Attribute:
            if (e.ctx !== Sk.astnodes.AugLoad && e.ctx !== Sk.astnodes.AugStore) {
              val = this.vexpr(e.value);
            }
            mangled = e.attr["$r"]().v;
            mangled = mangled.substring(1, mangled.length - 1);
            mangled = mangleName(this.u.private_, new Sk.builtin.str(mangled)).v;
            mname = this.makeConstant("new Sk.builtin.str('" + mangled + "')");
            switch (e.ctx) {
              case Sk.astnodes.AugLoad:
                out("$ret = ", augvar, ".tp$getattr(", mname, ", true);");
                this._checkSuspension(e);
                out("\nif ($ret === undefined) {");
                out(
                  "\nthrow new Sk.builtin.AttributeError(",
                  augvar,
                  `.sk$attrError() + " has no attribute '" + `,
                  mname,
                  `.$jsstr() + "'");`
                );
                out("\n};");
                return this._gr("lattr", "$ret");
              case Sk.astnodes.Load:
                out("$ret = ", val, ".tp$getattr(", mname, ", true);");
                this._checkSuspension(e);
                out("\nif ($ret === undefined) {");
                out(
                  "\nthrow new Sk.builtin.AttributeError(",
                  val,
                  `.sk$attrError() + " has no attribute '" + `,
                  mname,
                  `.$jsstr() + "'");`
                );
                out("\n};");
                return this._gr("lattr", "$ret");
              case Sk.astnodes.AugStore:
                out("$ret = undefined;");
                out("if(", data, "!==undefined){");
                out("$ret = ", augvar, ".tp$setattr(", mname, ",", data, ", true);");
                out("}");
                this._checkSuspension(e);
                break;
              case Sk.astnodes.Store:
                out("$ret = ", val, ".tp$setattr(", mname, ",", data, ", true);");
                this._checkSuspension(e);
                break;
              case Sk.astnodes.Del:
                out("$ret = ", val, ".tp$setattr(", mname, ", undefined, true);");
                this._checkSuspension(e);
                break;
              case Sk.astnodes.Param:
              default:
                Sk.asserts.fail("invalid attribute expression");
            }
            break;
          case Sk.astnodes.Subscript:
            switch (e.ctx) {
              case Sk.astnodes.AugLoad:
                out("$ret = Sk.abstr.objectGetItem(", augvar, ",", augsubs, ", true);");
                this._checkSuspension(e);
                return this._gr("gitem", "$ret");
              case Sk.astnodes.Load:
              case Sk.astnodes.Store:
              case Sk.astnodes.Del:
                return this.vslice(e.slice, e.ctx, this.vexpr(e.value), data);
              case Sk.astnodes.AugStore:
                out("$ret=undefined;");
                out("if(", data, "!==undefined){");
                out("$ret=Sk.abstr.objectSetItem(", augvar, ",", augsubs, ",", data, ", true)");
                out("}");
                this._checkSuspension(e);
                break;
              case Sk.astnodes.Param:
              default:
                Sk.asserts.fail("invalid subscript expression");
            }
            break;
          case Sk.astnodes.Name:
            return this.nameop(e.id, e.ctx, data);
          case Sk.astnodes.NameConstant:
            if (e.ctx === Sk.astnodes.Store || e.ctx === Sk.astnodes.AugStore || e.ctx === Sk.astnodes.Del) {
              throw new Sk.builtin.SyntaxError(
                "can not assign to a constant name",
                this.filename,
                e.lineno,
                ...get_context(e)
              );
            }
            switch (e.value) {
              case Sk.builtin.none.none$:
                return "Sk.builtin.none.none$";
              case Sk.builtin.bool.true$:
                return "Sk.builtin.bool.true$";
              case Sk.builtin.bool.false$:
                return "Sk.builtin.bool.false$";
              default:
                Sk.asserts.fail("invalid named constant");
            }
            break;
          case Sk.astnodes.List:
            return this.ctuplelistorset(e, data, "list");
          case Sk.astnodes.Tuple:
            return this.ctuplelistorset(e, data, "tuple");
          case Sk.astnodes.Set:
            return this.ctuplelistorset(e, data, "set");
          case Sk.astnodes.Starred:
            switch (e.ctx) {
              case Sk.astnodes.Store:
                throw new Sk.builtin.SyntaxError(
                  "starred assignment target must be in a list or tuple",
                  this.filename,
                  e.lineno,
                  ...get_context(e)
                );
              default:
                throw new Sk.builtin.SyntaxError(
                  "can't use starred expression here",
                  this.filename,
                  e.lineno,
                  ...get_context(e)
                );
            }
          case Sk.astnodes.JoinedStr:
            return this.cjoinedstr(e);
          case Sk.astnodes.FormattedValue:
            return this.cformattedvalue(e);
          case Sk.astnodes.Ellipsis:
            return this.makeConstant("Sk.builtin.Ellipsis");
          default:
            Sk.asserts.fail("unhandled case " + e.constructor.name + " vexpr");
        }
      };
      Compiler.prototype.vseqexpr = function(exprs, data) {
        var i;
        var ret;
        Sk.asserts.assert(data === void 0 || exprs.length === data.length);
        ret = [];
        for (i = 0; i < exprs.length; ++i) {
          ret.push(this.vexpr(exprs[i], data === void 0 ? void 0 : data[i]));
        }
        return ret;
      };
      Compiler.prototype.cannassign = function(s) {
        const target = s.target;
        let val = s.value;
        if (val) {
          val = this.vexpr(s.value);
          this.vexpr(target, val);
        }
        switch (target.constructor) {
          case Sk.astnodes.Name:
            if (s.simple && (this.u.ste.blockType === Sk.SYMTAB_CONSTS.ClassBlock || this.u.ste.blockType == Sk.SYMTAB_CONSTS.ModuleBlock)) {
              this.u.hasAnnotations = true;
              const val2 = this.vexpr(s.annotation);
              let mangled = mangleName(this.u.private_, target.id).v;
              const key = this.makeConstant("new Sk.builtin.str('" + mangled + "')");
              this.chandlesubscr(Sk.astnodes.Store, "$loc.__annotations__", key, val2);
            }
        }
      };
      Compiler.prototype.caugassign = function(s) {
        var to;
        var augsub;
        var res;
        var val;
        var aug;
        var auge;
        var e;
        Sk.asserts.assert(s instanceof Sk.astnodes.AugAssign);
        e = s.target;
        switch (e.constructor) {
          case Sk.astnodes.Attribute:
            to = this.vexpr(e.value);
            auge = new Sk.astnodes.Attribute(
              e.value,
              e.attr,
              Sk.astnodes.AugLoad,
              e.lineno,
              e.col_offset,
              e.end_lineno,
              e.end_col_offset
            );
            aug = this.vexpr(auge, void 0, to);
            val = this.vexpr(s.value);
            res = this._gr(
              "inplbinopattr",
              "Sk.abstr.numberInplaceBinOp(",
              aug,
              ",",
              val,
              ",'",
              s.op.prototype._astname,
              "')"
            );
            auge.ctx = Sk.astnodes.AugStore;
            return this.vexpr(auge, res, to);
          case Sk.astnodes.Subscript:
            to = this.vexpr(e.value);
            augsub = this.vslicesub(e.slice);
            auge = new Sk.astnodes.Subscript(
              e.value,
              augsub,
              Sk.astnodes.AugLoad,
              e.lineno,
              e.col_offset,
              e.end_lineno,
              e.end_col_offset
            );
            aug = this.vexpr(auge, void 0, to, augsub);
            val = this.vexpr(s.value);
            res = this._gr(
              "inplbinopsubscr",
              "Sk.abstr.numberInplaceBinOp(",
              aug,
              ",",
              val,
              ",'",
              s.op.prototype._astname,
              "')"
            );
            auge.ctx = Sk.astnodes.AugStore;
            return this.vexpr(auge, res, to, augsub);
          case Sk.astnodes.Name:
            to = this.nameop(e.id, Sk.astnodes.Load);
            val = this.vexpr(s.value);
            res = this._gr(
              "inplbinop",
              "Sk.abstr.numberInplaceBinOp(",
              to,
              ",",
              val,
              ",'",
              s.op.prototype._astname,
              "')"
            );
            return this.nameop(e.id, Sk.astnodes.Store, res);
          default:
            Sk.asserts.fail("unhandled case in augassign");
        }
      };
      Compiler.prototype.exprConstant = function(e) {
        switch (e.constructor) {
          case Sk.astnodes.Num:
            return Sk.misceval.isTrue(e.n) ? 1 : 0;
          case Sk.astnodes.Str:
            return Sk.misceval.isTrue(e.s) ? 1 : 0;
          case Sk.astnodes.Name:
          // todo; do __debug__ test here if opt
          default:
            return -1;
        }
      };
      Compiler.prototype.newBlock = function(name) {
        var ret = this.u.blocknum++;
        this.u.blocks[ret] = [];
        this.u.blocks[ret]._name = name || "<unnamed>";
        this.u.blocks[ret]._next = null;
        return ret;
      };
      Compiler.prototype.setBlock = function(n) {
        Sk.asserts.assert(n >= 0 && n < this.u.blocknum);
        this.u.curblock = n;
      };
      Compiler.prototype.pushBreakBlock = function(n) {
        Sk.asserts.assert(n >= 0 && n < this.u.blocknum);
        this.u.breakBlocks.push(n);
      };
      Compiler.prototype.popBreakBlock = function() {
        this.u.breakBlocks.pop();
      };
      Compiler.prototype.pushContinueBlock = function(n) {
        Sk.asserts.assert(n >= 0 && n < this.u.blocknum);
        this.u.continueBlocks.push(n);
      };
      Compiler.prototype.popContinueBlock = function() {
        this.u.continueBlocks.pop();
      };
      Compiler.prototype.pushExceptBlock = function(n) {
        Sk.asserts.assert(n >= 0 && n < this.u.blocknum);
        this.u.exceptBlocks.push(n);
      };
      Compiler.prototype.popExceptBlock = function() {
        this.u.exceptBlocks.pop();
      };
      Compiler.prototype.pushFinallyBlock = function(n) {
        Sk.asserts.assert(n >= 0 && n < this.u.blocknum);
        Sk.asserts.assert(this.u.breakBlocks.length === this.u.continueBlocks.length);
        this.u.finallyBlocks.push({ blk: n, breakDepth: this.u.breakBlocks.length });
      };
      Compiler.prototype.popFinallyBlock = function() {
        this.u.finallyBlocks.pop();
      };
      Compiler.prototype.peekFinallyBlock = function() {
        return this.u.finallyBlocks.length > 0 ? this.u.finallyBlocks[this.u.finallyBlocks.length - 1] : void 0;
      };
      Compiler.prototype.setupExcept = function(eb) {
        out("$exc.push(", eb, ");");
      };
      Compiler.prototype.endExcept = function() {
        out("$exc.pop();");
      };
      Compiler.prototype.getLocals = function(unit) {
        var name;
        var output;
        var i;
        var have = {};
        for (i = 0; unit.argnames && i < unit.argnames.length; ++i) {
          have[unit.argnames[i]] = true;
        }
        output = [];
        for (i = 0; i < unit.localnames.length; ++i) {
          name = unit.localnames[i];
          if (have[name] === void 0) {
            output.push(name);
            have[name] = true;
          }
        }
        return output;
      };
      Compiler.prototype.outputLocals = function(unit, localNames) {
        const varnames = localNames.join(",");
        if (localNames.length > 0) {
          return "var " + varnames + "; /* locals */";
        }
        return "";
      };
      Compiler.prototype.outputSuspensionHelpers = function(unit) {
        var i, t;
        var localSaveCode = [];
        var localsToSave = unit.localnames.concat(unit.tempsToSave);
        var seenTemps = {};
        var localsToSaveWithoutDuplicates = [];
        for (i = 0; i < localsToSave.length; i++) {
          t = localsToSave[i];
          if (seenTemps[t] === void 0) {
            localsToSaveWithoutDuplicates.push(t);
            seenTemps[t] = true;
          }
        }
        localsToSave = localsToSaveWithoutDuplicates;
        var hasCell = unit.ste.blockType === Sk.SYMTAB_CONSTS.FunctionBlock && unit.ste.childHasFree;
        var output = localsToSave.length > 0 ? "var " + localsToSave.join(",") + ";" : "";
        output += "var $wakeFromSuspension = function() {var susp = " + unit.scopename + ".$wakingSuspension; " + unit.scopename + ".$wakingSuspension = undefined;$blk=susp.$blk; $loc=susp.$loc; $gbl=susp.$gbl; $exc=susp.$exc; $err=susp.$err; $postfinally=susp.$postfinally;$currLineNo=susp.$lineno;$currColNo=susp.$colno;$currSource=susp.$source;Sk.lastYield=Date.now();" + //"console.log('WAKEY', $fname, $loc, $gbl, $exc, $exc.length, $currColNo, $currLineNo, $err, $currSource,$blk);" +
        (hasCell ? "$cell=susp.$cell;" : "");
        for (i = 0; i < localsToSave.length; i++) {
          t = localsToSave[i];
          output += t + "=susp.$tmps." + t + ";";
        }
        output += "try {$ret=susp.child.resume();" + this.handleTraceback(false, unit.scopename) + // Close out function
        ";";
        for (i = 0; i < localsToSave.length; i++) {
          t = localsToSave[i];
          localSaveCode.push('"' + t + '":' + t);
        }
        output += "var $mys = function(){return {data: {type: 'Sk.yield'}, resume: function(){} } };";
        output += "var $saveSuspension = function($child, $filename, $lineno, $colno, $source) {var susp = Sk.misceval.injectSusp($child,$blk,$loc,$gbl,$exc,$err,$postfinally,$filename,$lineno,$colno,$source,{" + localSaveCode.join(",") + "});susp.resume=function(){" + unit.scopename + ".$wakingSuspension=susp; return " + unit.scopename + "(" + (unit.ste.generator ? "$gen" : "") + "); };" + /*"susp.data=susp.child.data;susp.$blk=$blk;susp.$loc=$loc;susp.$gbl=$gbl;susp.$exc=$exc;susp.$err=$err;susp.$postfinally=$postfinally;" +
        "susp.$filename=$filename;susp.$lineno=$lineno;susp.$colno=$colno;susp.source=$source;" +
        "susp.optional=susp.child.optional;" +*/
        (hasCell ? "susp.$cell=$cell;" : "") + //"susp.$tmps={" + localSaveCode.join(",") + "};" +
        "return susp;};";
        return output;
      };
      Compiler.prototype.getLocalGetter = function(unit, localNames) {
        return `var $getLocals=()=>({$cell,${localNames.join(",")}});`;
      };
      Compiler.prototype.outputAllUnits = function() {
        var i;
        var blocks;
        var unit;
        var j;
        var ret = "";
        var block;
        var generatedBlocks;
        for (j = 0; j < this.allUnits.length; ++j) {
          unit = this.allUnits[j];
          ret += unit.prefixCode;
          var localNames = this.getLocals(unit);
          ret += this.outputLocals(unit, localNames);
          if (unit.doesSuspend) {
            ret += this.outputSuspensionHelpers(unit);
          }
          ret += this.getLocalGetter(unit, unit.localnames);
          ret += unit.varDeclsCode;
          ret += unit.switchCode;
          blocks = unit.blocks;
          generatedBlocks = /* @__PURE__ */ Object.create(null);
          for (i = 0; i < blocks.length; ++i) {
            block = i;
            if (block in generatedBlocks) {
              continue;
            }
            while (true) {
              generatedBlocks[block] = true;
              ret += "case " + block + ": /* --- " + blocks[block]._name + " --- */";
              ret += blocks[block].join("");
              if (blocks[block]._next !== null) {
                if (!(blocks[block]._next in generatedBlocks)) {
                  ret += "/* allowing case fallthrough */";
                  block = blocks[block]._next;
                } else {
                  ret += "/* jump */ continue;";
                  break;
                }
              } else {
                break;
              }
            }
          }
          ret += unit.suffixCode;
        }
        return ret;
      };
      Compiler.prototype.cif = function(s) {
        var test;
        var next;
        var end;
        var constant;
        Sk.asserts.assert(s instanceof Sk.astnodes.If);
        constant = this.exprConstant(s.test);
        if (constant === 0) {
          if (s.orelse && s.orelse.length > 0) {
            this.vseqstmt(s.orelse);
          }
        } else if (constant === 1) {
          this.vseqstmt(s.body);
        } else {
          end = this.newBlock("end of if");
          if (s.orelse && s.orelse.length > 0) {
            next = this.newBlock("next branch of if");
          }
          test = this.vexpr(s.test);
          if (s.orelse && s.orelse.length > 0) {
            this._jumpfalse(test, next);
            this.vseqstmt(s.body);
            this._jump(end);
            this.setBlock(next);
            this.vseqstmt(s.orelse);
          } else {
            this._jumpfalse(test, end);
            this.vseqstmt(s.body);
          }
          this._jump(end);
          this.setBlock(end);
        }
      };
      Compiler.prototype.cwhile = function(s) {
        var body;
        var orelse;
        var next;
        var top;
        var constant = this.exprConstant(s.test);
        if (constant === 0) {
          if (s.orelse) {
            this.vseqstmt(s.orelse);
          }
        } else {
          top = this.newBlock("while test");
          this._jump(top);
          this.setBlock(top);
          next = this.newBlock("after while");
          orelse = s.orelse.length > 0 ? this.newBlock("while orelse") : null;
          body = this.newBlock("while body");
          this.annotateSource(s, true);
          this._jumpfalse(this.vexpr(s.test), orelse ? orelse : next);
          this._jump(body);
          this.pushBreakBlock(next);
          this.pushContinueBlock(top);
          this.setBlock(body);
          if ((Sk.debugging || Sk.killableWhile) && this.u.canSuspend) {
            var suspType = "Sk.delay";
            var debugBlock = this.newBlock("debug breakpoint for line " + s.lineno);
            out(
              "if (Sk.breakpoints('" + this.filename + "'," + s.lineno + "," + s.col_offset + ")) {",
              "var $susp = $saveSuspension({data: {type: '" + suspType + "'}, resume: function() {}}, '" + this.filename + "'," + s.lineno + "," + s.col_offset + "," + s.source + ");",
              "$susp.$blk = " + debugBlock + ";",
              "$susp.optional = true;",
              "return $susp;",
              "}"
            );
            this._jump(debugBlock);
            this.setBlock(debugBlock);
            this.u.doesSuspend = true;
          }
          this.vseqstmt(s.body);
          this._jump(top);
          this.popContinueBlock();
          this.popBreakBlock();
          if (s.orelse.length > 0) {
            this.setBlock(orelse);
            this.vseqstmt(s.orelse);
            this._jump(next);
          }
          this.setBlock(next);
        }
      };
      Compiler.prototype.cfor = function(s) {
        var target;
        var nexti;
        var iter;
        var toiter;
        var start = this.newBlock("for start");
        var cleanup = this.newBlock("for cleanup");
        var end = this.newBlock("for end");
        this.pushBreakBlock(end);
        this.pushContinueBlock(start);
        toiter = this.vexpr(s.iter);
        if (this.u.ste.generator) {
          iter = "$loc." + this.gensym("iter");
          out(iter, "=Sk.abstr.iter(", toiter, ");");
        } else {
          iter = this._gr("iter", "Sk.abstr.iter(", toiter, ")");
          this.u.tempsToSave.push(iter);
        }
        this._jump(start);
        this.setBlock(start);
        out("$ret = Sk.abstr.iternext(", iter, this.u.canSuspend ? ", true" : ", false", ");");
        this._checkSuspension(s);
        nexti = this._gr("next", "$ret");
        this._jumpundef(nexti, cleanup);
        target = this.vexpr(s.target, nexti);
        if ((Sk.debugging || Sk.killableFor) && this.u.canSuspend) {
          var suspType = "Sk.delay";
          var debugBlock = this.newBlock("debug breakpoint for line " + s.lineno);
          out(
            "if (Sk.breakpoints('" + this.filename + "'," + s.lineno + "," + s.col_offset + ")) {",
            "var $susp = $saveSuspension({data: {type: '" + suspType + "'}, resume: function() {}}, '" + this.filename + "'," + s.lineno + "," + s.col_offset + "," + s.source + ");",
            "$susp.$blk = " + debugBlock + ";",
            "$susp.optional = true;",
            "return $susp;",
            "}"
          );
          this._jump(debugBlock);
          this.setBlock(debugBlock);
          this.u.doesSuspend = true;
        }
        this.vseqstmt(s.body);
        this._jump(start);
        this.setBlock(cleanup);
        this.popContinueBlock();
        this.popBreakBlock();
        this.vseqstmt(s.orelse);
        this._jump(end);
        this.setBlock(end);
      };
      Compiler.prototype.craise = function(s) {
        if (s.exc) {
          var exc = this._gr("exc", this.vexpr(s.exc));
          var instantiatedException = this.newBlock("exception now instantiated");
          var isClass = this._gr("isclass", exc + ".prototype instanceof Sk.builtin.BaseException");
          this._jumpfalse(isClass, instantiatedException);
          if (s.inst) {
            var inst = this._gr("inst", this.vexpr(s.inst));
            out(
              "if(!(",
              inst,
              " instanceof Sk.builtin.tuple)) {",
              inst,
              "= new Sk.builtin.tuple([",
              inst,
              "]);",
              "}"
            );
            out("$ret = Sk.misceval.callsimOrSuspendArray(", exc, ",", inst, ".v);");
          } else {
            out("$ret = Sk.misceval.callsimOrSuspend(", exc, ");");
          }
          this._checkSuspension(s);
          out(exc, "=$ret;");
          this._jump(instantiatedException);
          this.setBlock(instantiatedException);
          out(
            "if (",
            exc,
            " instanceof Sk.builtin.BaseException) {throw ",
            exc,
            ";} else {throw new Sk.builtin.TypeError('exceptions must derive from BaseException');};"
          );
        } else {
          out("throw $err;");
        }
      };
      Compiler.prototype.outputFinallyCascade = function(thisFinally) {
        var nextFinally;
        if (this.u.finallyBlocks.length == 0) {
          out(
            "if($postfinally!==undefined) { if ($postfinally.returning) { return $postfinally.returning; } else { $blk=$postfinally.gotoBlock; $postfinally=undefined; continue; } }"
          );
        } else {
          nextFinally = this.peekFinallyBlock();
          out(
            "if($postfinally!==undefined) {",
            "if ($postfinally.returning",
            nextFinally.breakDepth == thisFinally.breakDepth ? "|| $postfinally.isBreak" : "",
            ") {",
            "$blk=",
            nextFinally.blk,
            ";continue;",
            "} else {",
            "$blk=$postfinally.gotoBlock;$postfinally=undefined;continue;",
            "}",
            "}"
          );
        }
      };
      Compiler.prototype.ctry = function(s) {
        var check;
        var next;
        var handlertype;
        var handler;
        var end;
        var orelse;
        var unhandled;
        var i;
        var n = s.handlers.length;
        var finalBody, finalExceptionHandler, finalExceptionToReRaise;
        var thisFinally;
        if (s.finalbody) {
          finalBody = this.newBlock("finalbody");
          finalExceptionHandler = this.newBlock("finalexh");
          finalExceptionToReRaise = this._gr("finally_reraise", "undefined");
          this.u.tempsToSave.push(finalExceptionToReRaise);
          this.pushFinallyBlock(finalBody);
          thisFinally = this.peekFinallyBlock();
          this.setupExcept(finalExceptionHandler);
        }
        var handlers = [];
        for (i = 0; i < n; ++i) {
          handlers.push(this.newBlock("except_" + i + "_"));
        }
        unhandled = this.newBlock("unhandled");
        orelse = this.newBlock("orelse");
        end = this.newBlock("end");
        if (handlers.length != 0) {
          this.setupExcept(handlers[0]);
        }
        this.vseqstmt(s.body);
        if (handlers.length != 0) {
          this.endExcept();
        }
        this._jump(orelse);
        for (i = 0; i < n; ++i) {
          this.setBlock(handlers[i]);
          handler = s.handlers[i];
          if (!handler.type && i < n - 1) {
            throw new Sk.builtin.SyntaxError(
              "default 'except:' must be last",
              this.filename,
              handler.lineno,
              ...get_context(handler)
            );
          }
          if (handler.type) {
            handlertype = this.vexpr(handler.type);
            next = i == n - 1 ? unhandled : handlers[i + 1];
            check = this._gr(
              "instance",
              "Sk.misceval.isTrue(Sk.builtin.isinstance($err, ",
              handlertype,
              "))"
            );
            this._jumpfalse(check, next);
          }
          if (handler.name) {
            this.vexpr(handler.name, "$err");
          }
          this.vseqstmt(handler.body);
          this._jump(end);
        }
        this.setBlock(unhandled);
        out("throw $err;");
        this.setBlock(orelse);
        this.vseqstmt(s.orelse);
        this._jump(end);
        this.setBlock(end);
        if (s.finalbody) {
          this.endExcept();
          this._jump(finalBody);
          this.setBlock(finalExceptionHandler);
          out(finalExceptionToReRaise, "=$err;");
          this._jump(finalBody);
          this.setBlock(finalBody);
          this.popFinallyBlock();
          this.vseqstmt(s.finalbody);
          out(
            "if(",
            finalExceptionToReRaise,
            "!==undefined) { throw ",
            finalExceptionToReRaise,
            ";}"
          );
          this.outputFinallyCascade(thisFinally);
        }
      };
      Compiler.prototype.cwith = function(s, itemIdx) {
        var mgr, exit, value, exception;
        var exceptionHandler = this.newBlock("withexh"), tidyUp = this.newBlock("withtidyup");
        var carryOn = this.newBlock("withcarryon");
        var thisFinallyBlock;
        mgr = this._gr("mgr", this.vexpr(s.items[itemIdx].context_expr));
        out("$ret = Sk.abstr.lookupSpecial(", mgr, ",Sk.builtin.str.$exit);");
        this._checkSuspension(s);
        exit = this._gr("exit", "$ret");
        this.u.tempsToSave.push(exit);
        out("$ret = Sk.abstr.lookupSpecial(", mgr, ",Sk.builtin.str.$enter);");
        this._checkSuspension(s);
        out("$ret = $ret != null && Sk.misceval.callsimOrSuspendArray($ret);");
        this._checkSuspension(s);
        value = this._gr("value", "$ret");
        this.pushFinallyBlock(tidyUp);
        thisFinallyBlock = this.u.finallyBlocks[this.u.finallyBlocks.length - 1];
        this.setupExcept(exceptionHandler);
        if (s.items[itemIdx].optional_vars) {
          this.nameop(s.items[itemIdx].optional_vars.id, Sk.astnodes.Store, value);
        }
        if (itemIdx + 1 < s.items.length) {
          this.cwith(s, itemIdx + 1);
        } else {
          this.vseqstmt(s.body);
        }
        this.endExcept();
        this._jump(tidyUp);
        this.setBlock(exceptionHandler);
        out(
          "$ret = ",
          exit,
          "!=null && Sk.misceval.applyOrSuspend(",
          exit,
          ",undefined,Sk.builtin.getExcInfo($err),undefined,[]);"
        );
        this._checkSuspension(s);
        this._jumptrue("$ret", carryOn);
        out("throw $err;");
        this.setBlock(tidyUp);
        this.popFinallyBlock();
        out(
          "$ret = ",
          exit,
          "!=null && Sk.misceval.callsimOrSuspendArray(",
          exit,
          ",[Sk.builtin.none.none$,Sk.builtin.none.none$,Sk.builtin.none.none$]);"
        );
        this._checkSuspension(s);
        this.outputFinallyCascade(thisFinallyBlock);
        this._jump(carryOn);
        this.setBlock(carryOn);
      };
      Compiler.prototype.cassert = function(s) {
        var test = this.vexpr(s.test);
        var end = this.newBlock("end");
        this._jumptrue(test, end);
        out("throw new Sk.builtin.AssertionError(", s.msg ? this.vexpr(s.msg) : "", ");");
        this.setBlock(end);
      };
      Compiler.prototype.cimportas = function(name, asname, mod) {
        var attr;
        var src = name.v;
        var dotLoc = src.indexOf(".");
        var cur = mod;
        if (dotLoc !== -1) {
          src = src.substr(dotLoc + 1);
          while (dotLoc !== -1) {
            dotLoc = src.indexOf(".");
            attr = dotLoc !== -1 ? src.substr(0, dotLoc) : src;
            cur = this._gr("lattr", "Sk.abstr.gattr(", cur, ", new Sk.builtin.str('", attr, "'))");
            src = src.substr(dotLoc + 1);
          }
        }
        return this.nameop(asname, Sk.astnodes.Store, cur);
      };
      Compiler.prototype.cimport = function(s) {
        var lastDot;
        var tmp;
        var mod;
        var alias;
        var i;
        var n = s.names.length;
        for (i = 0; i < n; ++i) {
          alias = s.names[i];
          out(
            "$ret = Sk.builtin.__import__(",
            alias.name["$r"]().v,
            ",$gbl,$loc,[],",
            Sk.__future__.absolute_import ? 0 : -1,
            ",true);"
          );
          this._checkSuspension(s);
          mod = this._gr("module", "$ret");
          if (alias.asname) {
            this.cimportas(alias.name, alias.asname, mod);
          } else {
            tmp = alias.name;
            lastDot = tmp.v.indexOf(".");
            if (lastDot !== -1) {
              tmp = new Sk.builtin.str(tmp.v.substr(0, lastDot));
            }
            this.nameop(tmp, Sk.astnodes.Store, mod);
          }
        }
      };
      Compiler.prototype.cfromimport = function(s) {
        var storeName;
        var got;
        var alias;
        var aliasOut;
        var mod;
        var i;
        var n = s.names.length;
        var names = [];
        var level = s.level;
        if (level == 0 && !Sk.__future__.absolute_import) {
          level = -1;
        }
        for (i = 0; i < n; ++i) {
          names[i] = "'" + fixReserved(s.names[i].name.v) + "'";
        }
        out(
          "$ret = Sk.builtin.__import__(",
          s.module["$r"]().v,
          ",$gbl,$loc,[",
          names,
          "],",
          level,
          ",true);"
        );
        this._checkSuspension(s);
        mod = this._gr("module", "$ret");
        for (i = 0; i < n; ++i) {
          alias = s.names[i];
          aliasOut = "'" + alias.name.v + "'";
          if (i === 0 && alias.name.v === "*") {
            Sk.asserts.assert(n === 1);
            out("Sk.importStar(", mod, ",$loc, $gbl);");
            return;
          }
          got = this._gr(
            "item",
            "Sk.abstr.gattr(",
            mod,
            ", new Sk.builtin.str(",
            aliasOut,
            "), undefined)"
          );
          storeName = alias.name;
          if (alias.asname) {
            storeName = alias.asname;
          }
          this.nameop(storeName, Sk.astnodes.Store, got);
        }
      };
      Compiler.prototype.buildcodeobj = function(n, coname, decorator_list, args, callback, class_for_super) {
        var containingHasFree;
        var frees;
        var argnamesarr = [];
        var start;
        var kw;
        var maxargs;
        var minargs;
        var id;
        var argname;
        var offset;
        var cells;
        var locals;
        var i;
        var funcArgs;
        var entryBlock;
        var hasCell;
        var hasFree;
        var isGenerator;
        var scopename;
        var decos = [];
        var defaults = [];
        var kw_defaults = [];
        var vararg = null;
        var kwarg = null;
        if (decorator_list) {
          decos = this.vseqexpr(decorator_list);
        }
        if (args && args.defaults) {
          defaults = this.vseqexpr(args.defaults);
        }
        const func_annotations = this.cannotations(args, n.returns);
        if (args && args.kw_defaults) {
          kw_defaults = args.kw_defaults.map((e) => e ? this.vexpr(e) : "undefined");
        }
        if (args && args.vararg) {
          vararg = args.vararg;
        }
        if (args && args.kwarg) {
          kwarg = args.kwarg;
        }
        if (!Sk.__future__.python3 && args && args.kwonlyargs && args.kwonlyargs.length != 0) {
          throw new Sk.builtin.SyntaxError("Keyword-only arguments are not supported in Python 2");
        }
        scopename = this.enterScope(coname, n, n.lineno, this.canSuspend, coname.v);
        isGenerator = this.u.ste.generator;
        hasFree = this.u.ste.hasFree;
        hasCell = this.u.ste.childHasFree;
        entryBlock = this.newBlock("codeobj entry");
        this.u.prefixCode = "var " + scopename + "=(function " + this.niceName(coname.v) + "$(";
        funcArgs = [];
        if (isGenerator) {
          if (kwarg) {
            throw new Sk.builtin.SyntaxError(
              coname.v + "(): keyword arguments in generators not supported",
              this.filename,
              n.lineno,
              ...get_context(n)
            );
          }
          if (vararg) {
            throw new Sk.builtin.SyntaxError(
              coname.v + "(): variable number of arguments in generators not supported",
              this.filename,
              n.lineno,
              ...get_context(n)
            );
          }
          funcArgs.push("$gen");
        } else {
          if (kwarg) {
            funcArgs.push("$kwa");
            this.u.tempsToSave.push("$kwa");
          }
          for (i = 0; args && i < args.args.length; ++i) {
            funcArgs.push(this.nameop(args.args[i].arg, Sk.astnodes.Param));
          }
          for (i = 0; args && args.kwonlyargs && i < args.kwonlyargs.length; ++i) {
            funcArgs.push(this.nameop(args.kwonlyargs[i].arg, Sk.astnodes.Param));
          }
          if (vararg) {
            funcArgs.push(this.nameop(args.vararg.arg, Sk.astnodes.Param));
          }
        }
        let fastCall = !isGenerator;
        if (hasFree) {
          if (!fastCall) {
            funcArgs.push("$free");
          }
          this.u.tempsToSave.push("$free");
        }
        let argString;
        if (fastCall) {
          argString = "$posargs,$kwargs";
        } else {
          argString = funcArgs.join(",");
        }
        this.u.prefixCode += argString;
        this.u.prefixCode += "){";
        if (isGenerator) {
          this.u.prefixCode += "\n// generator\n";
        }
        if (hasFree) {
          this.u.prefixCode += "\n// has free\n";
        }
        if (hasCell) {
          this.u.prefixCode += "\n// has cell\n";
        }
        if (fastCall) {
          this.u.prefixCode += "\n// fast call\n";
        }
        locals = "{}";
        if (isGenerator) {
          entryBlock = "$gen.gi$resumeat";
          locals = "$gen.gi$locals";
        }
        cells = ",$cell={}";
        if (hasCell) {
          if (isGenerator) {
            cells = ",$cell=$gen.gi$cells";
          }
        }
        this.u.varDeclsCode += "var $blk=" + entryBlock + ",$exc=[],$loc=" + locals + cells + ",$gbl=" + (fastCall ? "this.func_globals" : "this") + (fastCall && hasFree ? ",$free=this.func_closure" : "") + ",$err=undefined,$ret=undefined,$postfinally=undefined,$currLineNo=undefined,$currColNo=undefined,$currSource=undefined;";
        if (Sk.execLimit !== null) {
          this.u.varDeclsCode += "Sk.misceval.startTimer();";
        }
        if (Sk.yieldLimit !== null && this.u.canSuspend) {
          this.u.varDeclsCode += "Sk.misceval.resetYield();";
        }
        this.u.varDeclsCode += "var $waking=false; if (" + scopename + ".$wakingSuspension!==undefined) { $wakeFromSuspension(); $waking=true; } else {";
        if (fastCall) {
          if (!kwarg && !vararg && (!args || !args.kwonlyargs || args.kwonlyargs.length === 0)) {
            this.u.varDeclsCode += "var $args = ((!$kwargs || $kwargs.length===0) && $posargs.length===" + funcArgs.length + ") ? $posargs : this.$resolveArgs($posargs,$kwargs)";
          } else {
            this.u.varDeclsCode += "\nvar $args = this.$resolveArgs($posargs,$kwargs)\n";
          }
          for (let i2 = 0; i2 < funcArgs.length; i2++) {
            this.u.varDeclsCode += "," + funcArgs[i2] + "=$args[" + i2 + "]";
          }
          this.u.varDeclsCode += ";\n";
        }
        if (isGenerator && defaults.length > 0) {
          offset = args.args.length - defaults.length;
          for (i = 0; i < defaults.length; ++i) {
            argname = this.nameop(args.args[i + offset].arg, Sk.astnodes.Param);
            this.u.varDeclsCode += "if(" + argname + "===undefined)" + argname + "=" + scopename + ".$defaults[" + i + "];";
          }
        }
        for (i = 0; args && i < args.args.length; ++i) {
          id = args.args[i].arg;
          if (this.isCell(id)) {
            let mangled = fixReserved(mangleName(this.u.private_, id).v);
            this.u.varDeclsCode += "$cell." + mangled + "=" + mangled + ";";
          }
        }
        for (i = 0; args && args.kwonlyargs && i < args.kwonlyargs.length; ++i) {
          id = args.kwonlyargs[i].arg;
          if (this.isCell(id)) {
            let mangled = fixReserved(mangleName(this.u.private_, id).v);
            this.u.varDeclsCode += "$cell." + mangled + "=" + mangled + ";";
          }
        }
        if (vararg && this.isCell(vararg.arg)) {
          let mangled = fixReserved(mangleName(this.u.private_, vararg.arg).v);
          this.u.varDeclsCode += "$cell." + mangled + "=" + mangled + ";";
        }
        if (kwarg) {
          this.u.localnames.push(kwarg.arg.v);
          this.u.varDeclsCode += kwarg.arg.v + "=new Sk.builtins['dict']($kwa);";
          if (this.isCell(kwarg.arg)) {
            let mangled = fixReserved(mangleName(this.u.private_, kwarg.arg).v);
            this.u.varDeclsCode += "$cell." + mangled + "=" + mangled + ";";
          }
        }
        this.u.varDeclsCode += "}";
        if (Sk.__future__.python3 && class_for_super) {
          this.u.varDeclsCode += "let __class__=$gbl." + class_for_super.v + ";";
        }
        this.u.switchCode = "while(true){try{";
        this.u.switchCode += this.outputInterruptTest();
        this.u.switchCode += "switch($blk){";
        this.u.suffixCode = "}" + this.handleTraceback(true, coname.v);
        this.u.suffixCode += "});";
        if (this.filename && !this.filename.startsWith("src/lib/")) {
          out("Sk.beforeCall && Sk.beforeCall('" + coname.$jsstr() + "'," + argString + ");");
        }
        callback.call(this, scopename);
        if (args) {
          for (let arg of args.args) {
            argnamesarr.push(arg.arg.v);
          }
          for (let arg of args.kwonlyargs || []) {
            argnamesarr.push(arg.arg.v);
          }
          this.u.argnames = argnamesarr;
        }
        this.exitScope();
        if (defaults.length > 0) {
          out(scopename, ".$defaults=[", defaults.join(","), "];");
        }
        if (args && args.kwonlyargs && args.kwonlyargs.length > 0) {
          out(scopename, ".co_argcount=", args.args.length, ";");
          out(scopename, ".co_kwonlyargcount=", args.kwonlyargs.length, ";");
          out(scopename, ".$kwdefs=[", kw_defaults.join(","), "];");
        }
        if (decos.length > 0) {
          out(scopename, ".$decorators=[", decos.join(","), "];");
        }
        if (argnamesarr.length > 0) {
          out(scopename, ".co_varnames=['", argnamesarr.join("','"), "'];");
        } else {
          out(scopename, ".co_varnames=[];");
        }
        out(scopename, ".co_docstring=", this.cDocstringOfCode(n), ";");
        if (kwarg) {
          out(scopename, ".co_kwargs=1;");
        }
        if (vararg) {
          out(scopename, ".co_varargs=1;");
        }
        if (!isGenerator) {
          out(scopename, ".co_fastcall=1;");
        }
        frees = "";
        if (hasFree) {
          frees = ",$cell";
          containingHasFree = this.u.ste.hasFree;
          if (containingHasFree) {
            frees += ",$free";
          }
        }
        if (isGenerator) {
          if (args && args.args.length > 0) {
            return this._gr(
              "gener",
              `new Sk.builtins['function']((function(){var $origargs=Array.prototype.slice.call(arguments);Sk.builtin.pyCheckArgsLen("`,
              coname.v,
              '",arguments.length,',
              args.args.length - defaults.length,
              ",",
              args.args.length,
              ");return new Sk.builtins['generator'](",
              scopename,
              ",$gbl,$origargs",
              frees,
              ");}))"
            );
          } else {
            return this._gr(
              "gener",
              `new Sk.builtins['function']((function(){Sk.builtin.pyCheckArgsLen("`,
              coname.v,
              `",arguments.length,0,0);return new Sk.builtins['generator'](`,
              scopename,
              ",$gbl,[]",
              frees,
              ");}))"
            );
          }
        } else {
          let funcobj;
          if (decos.length > 0) {
            out("$ret = new Sk.builtins['function'](", scopename, ",$gbl", frees, ");");
            for (let decorator of decos.reverse()) {
              out("$ret = Sk.misceval.callsimOrSuspendArray(", decorator, ",[$ret]);");
              this._checkSuspension();
            }
            funcobj = this._gr("funcobj", "$ret");
          } else {
            funcobj = this._gr(
              "funcobj",
              "new Sk.builtins['function'](",
              scopename,
              ",$gbl",
              frees,
              ")"
            );
          }
          if (func_annotations) {
            out(funcobj, ".func_annotations=", func_annotations, ";");
          }
          return funcobj;
        }
      };
      Compiler.prototype.cargannotation = function(id, annotation, ann_dict) {
        if (annotation) {
          const mangled = mangleName(this.u.private_, id).v;
          ann_dict.push(`'${mangled}'`);
          ann_dict.push(this.vexpr(annotation));
        }
      };
      Compiler.prototype.cargannotations = function(args, ann_dict) {
        if (!args) {
          return;
        }
        for (let i = 0; i < args.length; i++) {
          const arg = args[i];
          this.cargannotation(arg.arg, arg.annotation, ann_dict);
        }
      };
      var return_str = new Sk.builtin.str("return");
      Compiler.prototype.cannotations = function(args, returns) {
        const ann_dict = [];
        if (args) {
          this.cargannotations(args.posonlyargs, ann_dict);
          this.cargannotations(args.args, ann_dict);
          if (args.vararg && args.vararg.annotation) {
            this.cargannotation(args.vararg.arg, args.vararg.annotation, ann_dict);
          }
          this.cargannotations(args.kwonlyargs, ann_dict);
          if (args.kwarg && args.kwarg.annotation) {
            this.cargannotation(args.kwarg.arg, args.kwarg.annotation, ann_dict);
          }
        }
        if (returns) {
          this.cargannotation(return_str, returns, ann_dict);
        }
        if (ann_dict.length === 0) {
          return;
        }
        return "[" + ann_dict.join(",") + "]";
      };
      Compiler.prototype.maybeCDocstringOfBody = function(body) {
        if (body.length === 0) {
          return null;
        }
        const stmt_0 = body[0];
        if (stmt_0.constructor !== Sk.astnodes.Expr) {
          return null;
        }
        const expr = stmt_0.value;
        if (expr.constructor !== Sk.astnodes.Str) {
          return null;
        }
        return this.vexpr(expr);
      };
      Compiler.prototype.cDocstringOfCode = function(node) {
        switch (node.constructor) {
          case Sk.astnodes.AsyncFunctionDef:
          // For when it's supported
          case Sk.astnodes.FunctionDef:
            return this.maybeCDocstringOfBody(node.body) || "Sk.builtin.none.none$";
          case Sk.astnodes.Lambda:
          case Sk.astnodes.GeneratorExp:
            return "Sk.builtin.none.none$";
          default:
            Sk.asserts.fail(`unexpected node kind ${node.constructor.name}`);
        }
      };
      Compiler.prototype.cfunction = function(s, class_for_super) {
        var funcorgen;
        Sk.asserts.assert(s instanceof Sk.astnodes.FunctionDef);
        funcorgen = this.buildcodeobj(
          s,
          s.name,
          s.decorator_list,
          s.args,
          function(scopename) {
            this.vseqstmt(s.body);
            out("return Sk.builtin.none.none$;");
          },
          class_for_super
        );
        this.nameop(s.name, Sk.astnodes.Store, funcorgen);
      };
      Compiler.prototype.clambda = function(e) {
        var func;
        Sk.asserts.assert(e instanceof Sk.astnodes.Lambda);
        func = this.buildcodeobj(e, new Sk.builtin.str("<lambda>"), null, e.args, function(scopename) {
          var val = this.vexpr(e.body);
          out("return ", val, ";");
        });
        return func;
      };
      Compiler.prototype.cifexp = function(e) {
        var next = this.newBlock("next of ifexp");
        var end = this.newBlock("end of ifexp");
        var ret = this._gr("res", "null");
        var test = this.vexpr(e.test);
        this._jumpfalse(test, next);
        out(ret, "=", this.vexpr(e.body), ";");
        this._jump(end);
        this.setBlock(next);
        out(ret, "=", this.vexpr(e.orelse), ";");
        this._jump(end);
        this.setBlock(end);
        return ret;
      };
      Compiler.prototype.cgenexpgen = function(generators, genIndex, elt) {
        var velt;
        var ifres;
        var i;
        var n;
        var target;
        var nexti;
        var toiter;
        var start = this.newBlock("start for " + genIndex);
        var skip = this.newBlock("skip for " + genIndex);
        var ifCleanup = this.newBlock("if cleanup for " + genIndex);
        var end = this.newBlock("end for " + genIndex);
        var ge = generators[genIndex];
        var iter;
        if (genIndex === 0) {
          iter = "$loc.$iter0";
        } else {
          toiter = this.vexpr(ge.iter);
          iter = "$loc." + this.gensym("iter");
          out(iter, "=", "Sk.abstr.iter(", toiter, ");");
        }
        this._jump(start);
        this.setBlock(start);
        this.annotateSource(elt, true);
        out("$ret = Sk.abstr.iternext(", iter, this.u.canSuspend ? ", true" : ", false", ");");
        this._checkSuspension(elt);
        nexti = this._gr("next", "$ret");
        this._jumpundef(nexti, end);
        target = this.vexpr(ge.target, nexti);
        n = ge.ifs ? ge.ifs.length : 0;
        for (i = 0; i < n; ++i) {
          this.annotateSource(ge.ifs[i], true);
          ifres = this.vexpr(ge.ifs[i]);
          this._jumpfalse(ifres, start);
        }
        if (++genIndex < generators.length) {
          this.cgenexpgen(generators, genIndex, elt);
        }
        if (genIndex >= generators.length) {
          this.annotateSource(elt, true);
          velt = this.vexpr(elt);
          out("return [", skip, "/*resume*/,", velt, "/*ret*/];");
          this.setBlock(skip);
        }
        this._jump(start);
        this.setBlock(end);
        if (genIndex === 1) {
          out("return Sk.builtin.none.none$;");
        }
      };
      Compiler.prototype.cgenexp = function(e) {
        var gen = this.buildcodeobj(
          e,
          new Sk.builtin.str("<genexpr>"),
          null,
          null,
          function(scopename) {
            this.cgenexpgen(e.generators, 0, e.elt);
          }
        );
        var gener = this._gr("gener", "Sk.misceval.callsimArray(", gen, ");");
        out(gener, ".gi$locals.$iter0=Sk.abstr.iter(", this.vexpr(e.generators[0].iter), ");");
        return gener;
      };
      Compiler.prototype.cclass = function(s) {
        var wrapped;
        var entryBlock;
        var scopename;
        var bases;
        var decos;
        Sk.asserts.assert(s instanceof Sk.astnodes.ClassDef);
        decos = this.vseqexpr(s.decorator_list);
        bases = this.vseqexpr(s.bases);
        scopename = this.enterScope(s.name, s, s.lineno, s.name.v);
        entryBlock = this.newBlock("class entry");
        this.u.prefixCode = "var " + scopename + "=(function $" + s.name.v + "$class_outer($globals,$locals,$cell){var $gbl=$globals,$loc=$locals,$free=$globals;";
        this.u.switchCode += "(function $" + s.name.v + "$_closure($cell){";
        this.u.switchCode += "var $blk=" + entryBlock + ",$exc=[],$ret=undefined,$postfinally=undefined,$currLineNo=undefined,$currColNo=undefined;$currSource=undefined;";
        if (Sk.execLimit !== null) {
          this.u.switchCode += "Sk.misceval.startTimer();";
        }
        if (Sk.yieldLimit !== null && this.u.canSuspend) {
          this.u.switchCode += "Sk.misceval.resetYield();";
        }
        this.u.switchCode += "while(true){try{";
        this.u.switchCode += this.outputInterruptTest();
        this.u.switchCode += "switch($blk){";
        this.u.suffixCode = "}" + this.handleTraceback(true, s.name.v);
        this.u.suffixCode += "}).call(null, $cell);});";
        this.u.private_ = s.name;
        this.cbody(s.body, s.name);
        out("return;");
        this.exitScope();
        out(
          "$ret = Sk.misceval.buildClass($gbl,",
          scopename,
          ",",
          s.name["$r"]().v,
          ",[",
          bases,
          "], $cell);"
        );
        for (let decorator of decos) {
          out("$ret = Sk.misceval.callsimOrSuspendArray(", decorator, ", [$ret]);");
          this._checkSuspension();
        }
        this.nameop(s.name, Sk.astnodes.Store, "$ret");
      };
      Compiler.prototype.ccontinue = function(s) {
        var nextFinally = this.peekFinallyBlock(), gotoBlock;
        if (this.u.continueBlocks.length == 0) {
          throw new Sk.builtin.SyntaxError(
            "'continue' outside loop",
            this.filename,
            s.lineno,
            ...get_context(s)
          );
        }
        gotoBlock = this.u.continueBlocks[this.u.continueBlocks.length - 1];
        Sk.asserts.assert(this.u.breakBlocks.length === this.u.continueBlocks.length);
        if (nextFinally && nextFinally.breakDepth == this.u.continueBlocks.length) {
          out("$postfinally={isBreak:true,gotoBlock:", gotoBlock, "};");
        } else {
          this._jump(gotoBlock);
        }
      };
      Compiler.prototype.cbreak = function(s) {
        var nextFinally = this.peekFinallyBlock(), gotoBlock;
        if (this.u.breakBlocks.length === 0) {
          throw new Sk.builtin.SyntaxError(
            "'break' outside loop",
            this.filename,
            s.lineno,
            ...get_context(s)
          );
        }
        gotoBlock = this.u.breakBlocks[this.u.breakBlocks.length - 1];
        if (nextFinally && nextFinally.breakDepth == this.u.breakBlocks.length) {
          out("$postfinally={isBreak:true,gotoBlock:", gotoBlock, "};");
        } else {
          this._jump(gotoBlock);
        }
      };
      Compiler.prototype.vstmt = function(s, class_for_super) {
        var i;
        var val;
        var n;
        var debugBlock;
        this.u.lineno = s.lineno;
        this.u.linenoSet = false;
        this.u.localtemps = [];
        if (Sk.debugging && this.u.canSuspend) {
          debugBlock = this.newBlock("debug breakpoint for line " + s.lineno);
          out(
            "if (Sk.breakpoints('" + this.filename + "'," + s.lineno + "," + s.col_offset + ")) {",
            "var $susp = $saveSuspension({data: {type: 'Sk.debug'}, resume: function() {}}, '" + this.filename + "'," + s.lineno + "," + s.col_offset + "," + s.source + ");",
            "$susp.$blk = " + debugBlock + ";",
            "$susp.optional = true;",
            "return $susp;",
            "}"
          );
          this._jump(debugBlock);
          this.setBlock(debugBlock);
          this.u.doesSuspend = true;
        }
        this.annotateSource(s, true);
        switch (s.constructor) {
          case Sk.astnodes.FunctionDef:
            this.cfunction(s, class_for_super);
            break;
          case Sk.astnodes.ClassDef:
            this.cclass(s);
            break;
          case Sk.astnodes.Return:
            if (this.u.ste.blockType !== Sk.SYMTAB_CONSTS.FunctionBlock) {
              throw new Sk.builtin.SyntaxError(
                "'return' outside function",
                this.filename,
                s.lineno,
                ...get_context(s)
              );
            }
            val = s.value ? this.vexpr(s.value) : "Sk.builtin.none.none$";
            if (this.filename && !this.filename.startsWith("src/lib/")) {
              out("Sk.beforeReturn && Sk.beforeReturn(" + val + ");");
            }
            if (this.u.finallyBlocks.length == 0) {
              out("return ", val, ";");
            } else {
              out("$postfinally={returning:", val, "};");
              this._jump(this.peekFinallyBlock().blk);
            }
            break;
          case Sk.astnodes.Delete:
            this.vseqexpr(s.targets);
            break;
          case Sk.astnodes.Assign:
            n = s.targets.length;
            val = this.vexpr(s.value);
            for (i = 0; i < n; ++i) {
              this.vexpr(s.targets[i], val);
            }
            break;
          case Sk.astnodes.AnnAssign:
            return this.cannassign(s);
          case Sk.astnodes.AugAssign:
            return this.caugassign(s);
          case Sk.astnodes.Print:
            this.cprint(s);
            break;
          case Sk.astnodes.For:
            return this.cfor(s);
          case Sk.astnodes.While:
            return this.cwhile(s);
          case Sk.astnodes.If:
            return this.cif(s);
          case Sk.astnodes.Raise:
            return this.craise(s);
          case Sk.astnodes.Try:
            return this.ctry(s);
          case Sk.astnodes.With:
            return this.cwith(s, 0);
          case Sk.astnodes.Assert:
            return this.cassert(s);
          case Sk.astnodes.Import:
            return this.cimport(s);
          case Sk.astnodes.ImportFrom:
            return this.cfromimport(s);
          case Sk.astnodes.Global:
            break;
          case Sk.astnodes.Expr:
            if (this.retainComments || s.value.constructor !== Sk.astnodes.Str) {
              this.vexpr(s.value);
            }
            break;
          case Sk.astnodes.Pass:
            break;
          case Sk.astnodes.Break:
            this.cbreak(s);
            break;
          case Sk.astnodes.Continue:
            this.ccontinue(s);
            break;
          case Sk.astnodes.Debugger:
            out("debugger;");
            break;
          default:
            Sk.asserts.fail("unhandled case in vstmt: " + JSON.stringify(s));
        }
      };
      Compiler.prototype.vseqstmt = function(stmts) {
        var i;
        for (i = 0; i < stmts.length; ++i) {
          this.vstmt(stmts[i]);
        }
      };
      var OP_FAST = 0;
      var OP_GLOBAL = 1;
      var OP_DEREF = 2;
      var OP_NAME = 3;
      Compiler.prototype.isCell = function(name) {
        var mangled = fixReserved(mangleName(this.u.private_, name).v);
        var scope = this.u.ste.getScope(mangled);
        var dict = null;
        return scope === Sk.SYMTAB_CONSTS.CELL;
      };
      Compiler.prototype.nameop = function(name, ctx, dataToStore) {
        var v;
        var mangledNoPre;
        var dict;
        var scope;
        var optype;
        var op;
        var mangled;
        if ((ctx === Sk.astnodes.Store || ctx === Sk.astnodes.AugStore || ctx === Sk.astnodes.Del) && name.v === "__debug__") {
          throw new Sk.builtin.SyntaxError(
            "can not assign to __debug__",
            this.filename,
            this.u.lineno,
            ...get_context(this.u)
          );
        }
        Sk.asserts.assert(name.v !== "None");
        if (name.v === "NotImplemented") {
          return "Sk.builtin.NotImplemented.NotImplemented$";
        }
        mangled = mangleName(this.u.private_, name).v;
        mangled = fixReserved(mangled);
        op = 0;
        optype = OP_NAME;
        scope = this.u.ste.getScope(mangled);
        dict = null;
        switch (scope) {
          case Sk.SYMTAB_CONSTS.FREE:
            dict = "$free";
            optype = OP_DEREF;
            break;
          case Sk.SYMTAB_CONSTS.CELL:
            dict = "$cell";
            optype = OP_DEREF;
            break;
          case Sk.SYMTAB_CONSTS.LOCAL:
            if (this.u.ste.blockType === Sk.SYMTAB_CONSTS.FunctionBlock && !this.u.ste.generator) {
              optype = OP_FAST;
            }
            break;
          case Sk.SYMTAB_CONSTS.GLOBAL_IMPLICIT:
            if (this.u.ste.blockType === Sk.SYMTAB_CONSTS.FunctionBlock) {
              optype = OP_GLOBAL;
            }
            break;
          case Sk.SYMTAB_CONSTS.GLOBAL_EXPLICIT:
            optype = OP_GLOBAL;
          default:
            break;
        }
        Sk.asserts.assert(scope || name.v.charAt(1) === "_");
        mangledNoPre = mangled;
        if (this.u.ste.generator || this.u.ste.blockType !== Sk.SYMTAB_CONSTS.FunctionBlock) {
          mangled = "$loc." + mangled;
        } else if (optype === OP_FAST || optype === OP_NAME) {
          this.u.localnames.push(mangled);
        }
        switch (optype) {
          case OP_FAST:
            switch (ctx) {
              case Sk.astnodes.Load:
              case Sk.astnodes.Param:
                out("if (", mangled, " === undefined) { $ule('", mangled, "') }\n");
                return mangled;
              case Sk.astnodes.Store:
                out(mangled, "=", dataToStore, ";");
                break;
              case Sk.astnodes.Del:
                out("delete ", mangled, ";");
                break;
              default:
                Sk.asserts.fail("unhandled");
            }
            break;
          case OP_NAME:
            switch (ctx) {
              case Sk.astnodes.Load:
                return this._gr(
                  "loadname",
                  mangled,
                  "!==undefined?",
                  mangled,
                  ":Sk.misceval.loadname('",
                  mangledNoPre,
                  "',$gbl);"
                );
              case Sk.astnodes.Store:
                out(mangled, "=", dataToStore, ";");
                break;
              case Sk.astnodes.Del:
                out("delete ", mangled, ";");
                break;
              case Sk.astnodes.Param:
                return mangled;
              default:
                Sk.asserts.fail("unhandled");
            }
            break;
          case OP_GLOBAL:
            switch (ctx) {
              case Sk.astnodes.Load:
                return this._gr("loadgbl", "Sk.misceval.loadname('", mangledNoPre, "',$gbl)");
              case Sk.astnodes.Store:
                out("$gbl.", mangledNoPre, "=", dataToStore, ";");
                break;
              case Sk.astnodes.Del:
                out("delete $gbl.", mangledNoPre);
                break;
              default:
                Sk.asserts.fail("unhandled case in name op_global");
            }
            break;
          case OP_DEREF:
            switch (ctx) {
              case Sk.astnodes.Load:
                return dict + "." + mangledNoPre;
              case Sk.astnodes.Store:
                out(dict, ".", mangledNoPre, "=", dataToStore, ";");
                break;
              case Sk.astnodes.Param:
                return mangledNoPre;
              default:
                Sk.asserts.fail("unhandled case in name op_deref");
            }
            break;
          default:
            Sk.asserts.fail("unhandled case");
        }
      };
      Compiler.prototype.enterScope = function(name, key, lineno, canSuspend, hint) {
        var scopeName;
        var u = new CompilerUnit();
        u.ste = this.st.getStsForAst(key);
        u.name = name;
        u.firstlineno = lineno;
        u.canSuspend = canSuspend || false;
        if (this.u && this.u.private_) {
          u.private_ = this.u.private_;
        }
        this.stack.push(this.u);
        this.allUnits.push(u);
        hint = hint || "";
        hint = hint.replace(/[\<\>\/\.]/g, "_");
        scopeName = this.gensym("scope" + hint);
        u.scopename = scopeName;
        this.u = u;
        this.u.activateScope();
        this.nestlevel++;
        return scopeName;
      };
      Compiler.prototype.exitScope = function() {
        var mangled;
        var prev = this.u;
        this.nestlevel--;
        if (this.stack.length - 1 >= 0) {
          this.u = this.stack.pop();
        } else {
          this.u = null;
        }
        if (this.u) {
          this.u.activateScope();
        }
        if (prev.name.v !== "<module>") {
          mangled = prev.name["$r"]().v;
          mangled = mangled.substring(1, mangled.length - 1);
          let mname = this.makeConstant("new Sk.builtin.str('" + mangled + "')");
          out(prev.scopename, ".co_name=" + mname + ";");
          if (this.stack.length && this.u.ste.blockType == "class") {
            const classname = this.u.name.v;
            out(
              prev.scopename,
              ".co_qualname=new Sk.builtins.str('" + classname + "." + mangled + "');"
            );
          }
        }
        for (var constant in prev.consts) {
          if (prev.consts.hasOwnProperty(constant)) {
            prev.suffixCode += constant + " = " + prev.consts[constant] + ";";
          }
        }
      };
      Compiler.prototype.cbody = function(stmts, class_for_super) {
        var i = 0;
        const maybeDocstring = this.maybeCDocstringOfBody(stmts);
        if (maybeDocstring !== null) {
          out("$loc.__doc__ = ", maybeDocstring, ";");
          i = 1;
        }
        for (; i < stmts.length; ++i) {
          this.vstmt(stmts[i], class_for_super);
        }
        if (this.u.hasAnnotations) {
          this.u.varDeclsCode += "$loc.__annotations__ || ($loc.__annotations__ = new Sk.builtin.dict());";
        }
      };
      Compiler.prototype.cprint = function(s) {
        var i;
        var n;
        var dest;
        Sk.asserts.assert(s instanceof Sk.astnodes.Print);
        dest = "null";
        if (s.dest) {
          dest = this.vexpr(s.dest);
        }
        n = s.values.length;
        for (i = 0; i < n; ++i) {
          out(
            "$ret = Sk.misceval.print_(",
            /*dest, ',',*/
            "new Sk.builtins['str'](",
            this.vexpr(s.values[i]),
            ").v);"
          );
          this._checkSuspension(s);
        }
        if (s.nl) {
          out(
            "$ret = Sk.misceval.print_(",
            /*dest, ',*/
            '"\\n");'
          );
          this._checkSuspension(s);
        }
      };
      Compiler.prototype.cmod = function(mod) {
        var modf = this.enterScope(
          new Sk.builtin.str("<module>"),
          mod,
          0,
          this.canSuspend,
          this.filename
        );
        var entryBlock = this.newBlock("module entry");
        this.u.prefixCode = "var " + modf + "=(function($forcegbl, $forceloc){";
        this.u.varDeclsCode = "var $gbl = $forcegbl || {}, $blk=" + entryBlock + ",$exc=[],$loc=$forceloc || $gbl,$cell={},$err=undefined;$loc.__file__=new Sk.builtins.str($fname);var $ret=undefined,$postfinally=undefined,$currLineNo=undefined,$currColNo=undefined;$currSource=undefined;";
        if (Sk.execLimit !== null) {
          this.u.varDeclsCode += "Sk.misceval.startTimer();";
        }
        if (Sk.yieldLimit !== null && this.u.canSuspend) {
          this.u.varDeclsCode += "Sk.misceval.resetYield();";
        }
        this.u.varDeclsCode += "var $waking=false; if (" + modf + ".$wakingSuspension!==undefined) { $wakeFromSuspension(); $waking=true; }if (Sk.retainGlobals) {    if (Sk.globals) { $gbl = Sk.globals; Sk.globals = $gbl; $loc = $gbl; $loc.__file__=new Sk.builtins.str($fname);}    else { Sk.globals = $gbl; }} else { Sk.globals = $gbl; }";
        this.u.switchCode = "while(true){try{";
        this.u.switchCode += this.outputInterruptTest();
        this.u.switchCode += "switch($blk){";
        this.u.suffixCode = "}" + this.handleTraceback(true, "<module>");
        this.u.suffixCode += "});";
        switch (mod.constructor) {
          case Sk.astnodes.Module:
            this.cbody(mod.body);
            out("return $loc;");
            break;
          default:
            Sk.asserts.fail("todo; unhandled case in compilerMod");
        }
        this.exitScope();
        this.result.push(this.outputAllUnits());
        return modf;
      };
      Compiler.prototype.handleTraceback = function(doContinue, scopeName) {
        doContinue = doContinue ? "continue" : "";
        return "}catch(err){err=Sk.misceval.handleTraceback(err,$currLineNo,$currColNo,$currSource,$fname,'" + scopeName + "');if($exc.length>0){$err=err;$blk=$exc.pop();" + doContinue + "}else{throw err;}}}";
      };
      Sk.compile = function(source, filename, mode, canSuspend, annotate) {
        var savedFlags = Sk.__future__;
        Sk.__future__ = Object.create(Sk.__future__);
        var parse = Sk.parse(filename, source);
        var ast = Sk.astFromParse(parse.cst, filename, parse.flags);
        var flags = {};
        flags.cf_flags = parse.flags;
        var st = Sk.symboltable(ast, filename);
        var c = new Compiler(filename, st, flags.cf_flags, canSuspend, annotate ? source : false);
        var funcname = c.cmod(ast);
        Sk.__future__ = savedFlags;
        var shortCutConstants = "const $fname='" + filename + "',$moduleConstants={},$ule=Sk.misceval.errorUL;";
        var constantDefinitions = [];
        for (var constant in c.consts) {
          if (c.consts.hasOwnProperty(constant)) {
            constantDefinitions.push(constant + " = " + c.consts[constant] + ";");
          }
        }
        var ret = "$compiledmod = function() {" + shortCutConstants + c.result.join("") + constantDefinitions.join("") + "\nreturn " + funcname + ";}();";
        return {
          funcname: "$compiledmod",
          code: ret,
          filename
        };
      };
      Sk.exportSymbol("Sk.compile", Sk.compile);
      Sk.resetCompiler = function() {
        Sk.gensymcount = 0;
      };
      Sk.exportSymbol("Sk.resetCompiler", Sk.resetCompiler);
      Sk.fixReserved = fixReserved;
      Sk.exportSymbol("Sk.fixReserved", Sk.fixReserved);
      Sk.unfixReserved = unfixReserved;
      Sk.exportSymbol("Sk.unfixReserved", Sk.unfixReserved);
      Sk.mangleName = mangleName;
      Sk.exportSymbol("Sk.mangleName", Sk.mangleName);
      Sk.reservedWords_ = reservedWords_;
      Sk.exportSymbol("Sk.reservedWords_", Sk.reservedWords_);
    }
  });

  // src/import.js
  var require_import = __commonJS({
    "src/import.js"() {
      Sk.sysmodules = new Sk.builtin.dict([]);
      Sk.realsyspath = void 0;
      Sk.getSysModulesPolitely = function() {
        let sysmodules = Sk.sysmodules;
        try {
          let sys = sysmodules.mp$subscript(new Sk.builtin.str("sys"));
          if (sys != void 0) {
            sysmodules = sys.tp$getattr(new Sk.builtin.str("modules"));
          }
        } catch (x) {
        }
        return sysmodules;
      };
      Sk.importSearchPathForName = function(name, ext, searchPath) {
        var fn;
        var j;
        var fns = [];
        var nameAsPath = name.replace(/\./g, "/");
        var it, i;
        var tryPathAndBreakOnSuccess = function(filename, packagePath) {
          return Sk.misceval.chain(
            Sk.misceval.tryCatch(
              function() {
                return Sk.read(filename);
              },
              function(e) {
              }
            ),
            function(code) {
              if (code !== void 0) {
                return new Sk.misceval.Break({
                  filename,
                  code,
                  packagePath
                });
              }
            }
          );
        };
        if (searchPath === void 0) {
          searchPath = Sk.realsyspath;
        }
        return Sk.misceval.iterFor(searchPath.tp$iter(), function(pathStr) {
          return Sk.misceval.chain(
            tryPathAndBreakOnSuccess(pathStr.v + "/" + nameAsPath + ext, false),
            // module
            function(r) {
              return r ? r : tryPathAndBreakOnSuccess(
                pathStr.v + "/" + nameAsPath + "/__init__" + ext,
                pathStr.v + "/" + nameAsPath
              );
            }
          );
        });
      };
      Sk.doOneTimeInitialization = function(canSuspend) {
        function setUpClass(klass) {
          const proto = klass.prototype;
          if (!proto.hasOwnProperty("sk$slots")) {
            Sk.abstr.setUpSlots(klass);
          }
          if (!proto.hasOwnProperty("tp$mro")) {
            Sk.abstr.setUpBuiltinMro(klass);
          }
          if (proto.hasOwnProperty("tp$getsets") && proto.tp$getsets != null) {
            Sk.abstr.setUpGetSets(klass);
          }
          if (proto.hasOwnProperty("tp$methods") && proto.tp$methods != null) {
            Sk.abstr.setUpMethods(klass);
          }
          if (!proto.hasOwnProperty("__doc__") && proto.hasOwnProperty("tp$doc")) {
            proto.__doc__ = new Sk.builtin.str(proto.tp$doc);
          }
        }
        for (let x in Sk.builtins) {
          const obj = Sk.builtins[x];
          if (obj instanceof Sk.builtin.type) {
            setUpClass(obj);
          }
        }
      };
      Sk.importSetUpPath = function(canSuspend) {
        var i;
        var paths;
        if (!Sk.realsyspath) {
          paths = [
            new Sk.builtin.str("src/builtin"),
            new Sk.builtin.str("src/lib"),
            new Sk.builtin.str(".")
          ];
          for (i = 0; i < Sk.syspath.length; ++i) {
            paths.push(new Sk.builtin.str(Sk.syspath[i]));
          }
          Sk.realsyspath = new Sk.builtin.list(paths);
          Sk.doOneTimeInitialization(canSuspend);
        }
      };
      Sk.importModuleInternal_ = function(name, dumpJS, modname, suppliedPyBody, relativeToPackage, returnUndefinedOnTopLevelNotFound, canSuspend) {
        if (name === "pedal.sandbox.timeout") {
          suppliedPyBody = "def timeout(delay, func, *args, **kwargs):\n    return func(*args, **kwargs)";
        }
        var filename;
        var prev;
        var parentModName;
        var parentModule;
        var modNameSplit;
        var ret;
        var module2;
        var topLevelModuleToReturn = null;
        var relativePackageName = relativeToPackage !== void 0 ? relativeToPackage.tp$getattr(Sk.builtin.str.$name) : void 0;
        var absolutePackagePrefix = relativePackageName !== void 0 ? relativePackageName.v + "." : "";
        var searchPath = relativeToPackage !== void 0 ? relativeToPackage.tp$getattr(Sk.builtin.str.$path) : void 0;
        Sk.importSetUpPath(canSuspend);
        if (relativeToPackage && !relativePackageName) {
          if (returnUndefinedOnTopLevelNotFound) {
            return void 0;
          } else {
            throw new Sk.builtin.ValueError(
              "Attempted to import relative to invalid package (no name)"
            );
          }
        }
        if (modname === void 0) {
          modname = absolutePackagePrefix + name;
        }
        modNameSplit = name.split(".");
        if (modNameSplit.length > 1) {
          parentModName = modNameSplit.slice(0, modNameSplit.length - 1).join(".");
          topLevelModuleToReturn = Sk.importModuleInternal_(
            parentModName,
            dumpJS,
            void 0,
            void 0,
            relativeToPackage,
            returnUndefinedOnTopLevelNotFound,
            canSuspend
          );
        }
        let sysmodules = Sk.getSysModulesPolitely();
        ret = Sk.misceval.chain(topLevelModuleToReturn, function(topLevelModuleToReturn_) {
          topLevelModuleToReturn = topLevelModuleToReturn_;
          try {
            prev = sysmodules.quick$lookup(new Sk.builtin.str(modname));
            if (prev !== void 0) {
              return topLevelModuleToReturn || prev;
            }
          } catch (x) {
            console.error("WAIT", x);
          }
          return Sk.misceval.chain(
            void 0,
            function() {
              var codeAndPath, co, googClosure;
              var searchFileName = name;
              var result;
              if (modNameSplit.length > 1) {
                if (!topLevelModuleToReturn) {
                  return void 0;
                }
                parentModule = sysmodules.mp$subscript(
                  new Sk.builtin.str(absolutePackagePrefix + parentModName)
                );
                searchFileName = modNameSplit[modNameSplit.length - 1];
                searchPath = parentModule.tp$getattr(Sk.builtin.str.$path);
              }
              module2 = new Sk.builtin.module();
              if (typeof suppliedPyBody === "string") {
                filename = name + ".py";
                co = Sk.compile(suppliedPyBody, filename, "exec", canSuspend, true);
              } else {
                co = Sk.misceval.chain(
                  void 0,
                  function() {
                    if (Sk.onBeforeImport && typeof Sk.onBeforeImport === "function") {
                      return Sk.onBeforeImport(name);
                    }
                    return;
                  },
                  function(result2) {
                    if (result2 === false) {
                      throw new Sk.builtin.ImportError(
                        "Importing " + name + " is not allowed"
                      );
                    } else if (typeof result2 === "string") {
                      throw new Sk.builtin.ImportError(result2);
                    }
                    return Sk.importSearchPathForName(searchFileName, ".js", searchPath);
                  },
                  function(codeAndPath2) {
                    if (codeAndPath2) {
                      return {
                        funcname: "$builtinmodule",
                        code: codeAndPath2.code,
                        filename: codeAndPath2.filename,
                        packagePath: codeAndPath2.packagePath
                      };
                    } else {
                      return Sk.misceval.chain(
                        Sk.importSearchPathForName(searchFileName, ".py", searchPath),
                        function(codeAndPath_) {
                          codeAndPath2 = codeAndPath_;
                          if (codeAndPath2) {
                            return Sk.compile(
                              codeAndPath2.code,
                              codeAndPath2.filename,
                              "exec",
                              canSuspend,
                              true
                            );
                          }
                        },
                        function(co2) {
                          if (co2) {
                            co2.packagePath = codeAndPath2.packagePath;
                            return co2;
                          }
                        }
                      );
                    }
                  }
                );
              }
              return co;
            },
            function(co) {
              var finalcode;
              var withLineNumbers;
              var modscope;
              if (!co) {
                return void 0;
              }
              sysmodules.mp$ass_subscript(new Sk.builtin.str(modname), module2);
              module2.$js = co.code;
              finalcode = co.code;
              if (filename == null) {
                filename = co.filename;
              }
              if (Sk.dateSet == null || !Sk.dateSet) {
                finalcode = "Sk.execStart = Sk.lastYield = new Date();\n" + co.code;
                Sk.dateSet = true;
              }
              if (dumpJS) {
                withLineNumbers = function(code) {
                  var j;
                  var pad;
                  var width;
                  var i;
                  var beaut = Sk.js_beautify(code);
                  var lines = beaut.split("\n");
                  for (i = 1; i <= lines.length; ++i) {
                    width = ("" + i).length;
                    pad = "";
                    for (j = width; j < 5; ++j) {
                      pad += " ";
                    }
                    lines[i - 1] = "/* " + pad + i + " */ " + lines[i - 1];
                  }
                  return lines.join("\n");
                };
                finalcode = withLineNumbers(finalcode);
                Sk.debugout(finalcode);
              }
              finalcode += "\n" + co.funcname + ";";
              modscope = Sk.global["eval"](finalcode);
              module2["$d"] = {
                __name__: new Sk.builtin.str(modname),
                __doc__: Sk.builtin.none.none$,
                __package__: co.packagePath ? new Sk.builtin.str(modname) : parentModName ? new Sk.builtin.str(absolutePackagePrefix + parentModName) : relativePackageName ? relativePackageName : Sk.builtin.none.none$
              };
              if (co.packagePath) {
                module2["$d"]["__path__"] = new Sk.builtin.tuple([
                  new Sk.builtin.str(co.packagePath)
                ]);
              }
              let r = modscope(module2["$d"]);
              return r;
            },
            function(modlocs) {
              var i;
              if (modlocs === void 0) {
                if (returnUndefinedOnTopLevelNotFound && !topLevelModuleToReturn) {
                  return void 0;
                } else {
                  throw new Sk.builtin.ImportError("No module named " + name);
                }
              }
              if (modlocs !== module2["$d"]) {
                for (i in module2["$d"]) {
                  if (!modlocs[i]) {
                    modlocs[i] = module2["$d"][i];
                  }
                }
                module2["$d"] = modlocs;
              }
              if (Sk.onAfterImport && typeof Sk.onAfterImport === "function") {
                try {
                  Sk.onAfterImport(name);
                } catch (e) {
                }
              }
              if (topLevelModuleToReturn) {
                parentModule.tp$setattr(
                  new Sk.builtin.str(modNameSplit[modNameSplit.length - 1]),
                  module2
                );
                return topLevelModuleToReturn;
              }
              if (relativeToPackage) {
                relativeToPackage.tp$setattr(new Sk.builtin.str(name), module2);
              }
              return module2;
            }
          );
        });
        return canSuspend ? ret : Sk.misceval.retryOptionalSuspensionOrThrow(ret);
      };
      Sk.importModule = function(name, dumpJS, canSuspend) {
        return Sk.importModuleInternal_(
          name,
          dumpJS,
          void 0,
          void 0,
          void 0,
          false,
          canSuspend
        );
      };
      Sk.importMain = function(name, dumpJS, canSuspend) {
        Sk.dateSet = false;
        Sk.filesLoaded = false;
        Sk.sysmodules = new Sk.builtin.dict([]);
        Sk.realsyspath = void 0;
        Sk.execStack = [];
        Sk.resetCompiler();
        return Sk.importModuleInternal_(
          name,
          dumpJS,
          "__main__",
          void 0,
          void 0,
          false,
          canSuspend
        );
      };
      Sk.importMainWithBody = function(name, dumpJS, body, canSuspend, sysmodules) {
        Sk.dateSet = false;
        Sk.filesLoaded = false;
        if (sysmodules === void 0) {
          Sk.sysmodules = new Sk.builtin.dict([]);
        } else {
          Sk.sysmodules = sysmodules;
        }
        Sk.realsyspath = void 0;
        Sk.execPausedAmount = 0;
        Sk.execPaused = 0;
        Sk.execStack = [];
        Sk.resetCompiler();
        return Sk.importModuleInternal_(name, dumpJS, "__main__", body, void 0, false, canSuspend);
      };
      Sk.importBuiltinWithBody = function(name, dumpJS, body, canSuspend) {
        return Sk.importModuleInternal_(
          name,
          dumpJS,
          "__builtin__." + name,
          body,
          void 0,
          false,
          canSuspend
        );
      };
      Sk.builtin.__import__ = function(name, globals, locals, fromlist, level, askeyword = false) {
        var builtinModuleVersion;
        if (askeyword && Sk.globals["__builtins__"] !== void 0) {
          builtinModuleVersion = Sk.globals["__builtins__"].mp$lookup(Sk.builtin.str.$import);
          if (builtinModuleVersion !== void 0) {
            if (globals && !Sk.builtin.checkNone(globals) && !(globals instanceof Sk.builtin.dict)) {
              globals = new Sk.builtin.dict(
                Object.entries(globals).flatMap(([key, value]) => [
                  Sk.ffi.remapToPy(key),
                  value
                ])
              );
            }
            return Sk.misceval.callsimOrSuspend(
              builtinModuleVersion,
              new Sk.builtin.str(name),
              globals,
              locals,
              Sk.ffi.remapToPy(fromlist),
              Sk.ffi.remapToPy(level)
            );
          }
        }
        var saveSk = Sk.globals;
        if (Sk.builtin.checkString(name)) {
          name = name.v;
        }
        if (globals === void 0) {
          globals = Sk.globals;
        }
        var relativeToPackage;
        var relativeToPackageName;
        var relativeToPackageNames;
        if (level === void 0) {
          level = Sk.__future__.absolute_import ? 0 : -1;
        }
        if (level !== 0 && globals["__package__"] && globals["__package__"] !== Sk.builtin.none.none$) {
          relativeToPackageName = globals["__package__"].v;
          if (relativeToPackageName && level > 0) {
            relativeToPackageNames = relativeToPackageName.split(".");
            if (level - 1 >= relativeToPackageNames.length) {
              throw new Sk.builtin.ValueError(
                "Attempted relative import beyond toplevel package"
              );
            }
            relativeToPackageNames.length -= level - 1;
            relativeToPackageName = relativeToPackageNames.join(".");
          }
          try {
            relativeToPackage = Sk.sysmodules.mp$subscript(
              new Sk.builtin.str(relativeToPackageName)
            );
          } catch (e) {
            relativeToPackageName = void 0;
          }
        }
        if (level > 0 && relativeToPackage === void 0) {
          throw new Sk.builtin.ValueError("Attempted relative import in non-package");
        }
        var dottedName = name.split(".");
        var firstDottedName = dottedName[0];
        return Sk.misceval.chain(
          void 0,
          function() {
            if (level !== 0 && relativeToPackage !== void 0) {
              if (name === "") {
                return relativeToPackage;
              } else {
                return Sk.importModuleInternal_(
                  name,
                  void 0,
                  relativeToPackageName + "." + name,
                  void 0,
                  relativeToPackage,
                  level == -1,
                  true
                );
              }
            }
          },
          function(ret) {
            if (ret === void 0) {
              relativeToPackage = void 0;
              relativeToPackageName = void 0;
              return Sk.importModuleInternal_(
                name,
                void 0,
                void 0,
                void 0,
                void 0,
                false,
                true
              );
            } else {
              return ret;
            }
          },
          function(ret) {
            if (!fromlist || fromlist.length === 0) {
              return ret;
            } else {
              var i;
              var fromName;
              var leafModule, rootModule;
              var importChain;
              let sysmodules = Sk.getSysModulesPolitely();
              leafModule = sysmodules.mp$subscript(
                new Sk.builtin.str(
                  (relativeToPackageName || "") + (relativeToPackageName && name ? "." : "") + name
                )
              );
              rootModule = sysmodules.mp$subscript(new Sk.builtin.str(firstDottedName));
              for (i = 0; i < fromlist.length; i++) {
                fromName = fromlist[i];
                if (fromName != "*" && leafModule.tp$getattr(new Sk.builtin.str(fromName)) === void 0) {
                  importChain = Sk.misceval.chain(
                    importChain,
                    Sk.importModuleInternal_.bind(
                      null,
                      fromName,
                      void 0,
                      void 0,
                      void 0,
                      leafModule,
                      true,
                      true
                    )
                  );
                }
              }
              return Sk.misceval.chain(importChain, function() {
                Sk.asserts.assert(leafModule);
                return leafModule;
              });
            }
          },
          function(ret) {
            if (saveSk !== Sk.globals) {
              Sk.globals = saveSk;
            }
            return ret;
          }
        );
      };
      Sk.importStar = function(module2, loc, global2) {
        var __all__ = module2.tp$getattr(new Sk.builtin.str("__all__"));
        if (__all__) {
          for (let it = Sk.abstr.iter(__all__), i = it.tp$iternext(); i !== void 0; i = it.tp$iternext()) {
            loc[i.v] = Sk.abstr.gattr(module2, i);
          }
        } else {
          let props = Object["getOwnPropertyNames"](module2["$d"]);
          for (let i in props) {
            if (props[i].charAt(0) != "_") {
              loc[props[i]] = module2["$d"][props[i]];
            }
          }
        }
      };
      Sk.exportSymbol("Sk.importMain", Sk.importMain);
      Sk.exportSymbol("Sk.importMainWithBody", Sk.importMainWithBody);
      Sk.exportSymbol("Sk.importBuiltinWithBody", Sk.importBuiltinWithBody);
      Sk.exportSymbol("Sk.builtin.__import__", Sk.builtin.__import__);
      Sk.exportSymbol("Sk.importStar", Sk.importStar);
    }
  });

  // src/timsort.js
  var require_timsort = __commonJS({
    "src/timsort.js"() {
      Sk.builtin.timSort = function(list, length) {
        this.list = new Sk.builtin.list(list.v);
        this.MIN_GALLOP = 7;
        if (length) {
          this.listlength = length;
        } else {
          this.listlength = list.sq$length();
        }
      };
      Sk.builtin.timSort.prototype.lt = function(a, b) {
        return Sk.misceval.richCompareBool(a, b, "Lt");
      };
      Sk.builtin.timSort.prototype.le = function(a, b) {
        return !this.lt(b, a);
      };
      Sk.builtin.timSort.prototype.setitem = function(item, value) {
        this.list.v[item] = value;
      };
      Sk.builtin.timSort.prototype.binary_sort = function(a, sorted) {
        var pivot;
        var p;
        var r;
        var l;
        var start;
        for (start = a.base + sorted; start < a.base + a.len; start++) {
          l = a.base;
          r = start;
          pivot = a.getitem(r);
          while (l < r) {
            p = l + (r - l >> 1);
            if (this.lt(pivot, a.getitem(p))) {
              r = p;
            } else {
              l = p + 1;
            }
          }
          Sk.asserts.assert(l === r);
          for (p = start; p > l; p--) {
            a.setitem(p, a.getitem(p - 1));
          }
          a.setitem(l, pivot);
        }
      };
      Sk.builtin.timSort.prototype.count_run = function(a) {
        var n;
        var p;
        var descending;
        if (a.len <= 1) {
          n = a.len;
          descending = false;
        } else {
          n = 2;
          if (this.lt(a.getitem(a.base + 1), a.getitem(a.base))) {
            descending = true;
            for (p = a.base + 2; p < a.base + a.len; p++) {
              if (this.lt(a.getitem(p), a.getitem(p - 1))) {
                n++;
              } else {
                break;
              }
            }
          } else {
            descending = false;
            for (p = a.base + 2; p < a.base + a.len; p++) {
              if (this.lt(a.getitem(p), a.getitem(p - 1))) {
                break;
              } else {
                n++;
              }
            }
          }
        }
        return { run: new Sk.builtin.listSlice(a.list, a.base, n), descending };
      };
      Sk.builtin.timSort.prototype.sort = function() {
        var minrun;
        var cr;
        var sorted;
        var remaining = new Sk.builtin.listSlice(this.list, 0, this.listlength);
        if (remaining.len < 2) {
          return;
        }
        this.merge_init();
        minrun = this.merge_compute_minrun(remaining.len);
        while (remaining.len > 0) {
          cr = this.count_run(remaining);
          if (cr.descending) {
            cr.run.reverse();
          }
          if (cr.run.len < minrun) {
            sorted = cr.run.len;
            if (minrun < remaining.len) {
              cr.run.len = minrun;
            } else {
              cr.run.len = remaining.len;
            }
            this.binary_sort(cr.run, sorted);
          }
          remaining.advance(cr.run.len);
          this.pending.push(cr.run);
          this.merge_collapse();
        }
        Sk.asserts.assert(remaining.base == this.listlength);
        this.merge_force_collapse();
        Sk.asserts.assert(this.pending.length == 1);
        Sk.asserts.assert(this.pending[0].base === 0);
        Sk.asserts.assert(this.pending[0].len == this.listlength);
      };
      Sk.builtin.timSort.prototype.gallop = function(key, a, hint, rightmost) {
        var lower;
        var self2;
        var p;
        var lastofs;
        var ofs;
        var maxofs;
        var hintminofs;
        var hintminlastofs;
        var m;
        Sk.asserts.assert(0 <= hint && hint < a.len);
        self2 = this;
        if (rightmost) {
          lower = function(a2, b) {
            return self2.le(a2, b);
          };
        } else {
          lower = function(a2, b) {
            return self2.lt(a2, b);
          };
        }
        p = a.base + hint;
        lastofs = 0;
        ofs = 1;
        if (lower(a.getitem(p), key)) {
          maxofs = a.len - hint;
          while (ofs < maxofs) {
            if (lower(a.getitem(p + ofs), key)) {
              lastofs = ofs;
              try {
                ofs = (ofs << 1) + 1;
              } catch (err) {
                ofs = maxofs;
              }
            } else {
              break;
            }
          }
          if (ofs > maxofs) {
            ofs = maxofs;
          }
          lastofs += hint;
          ofs += hint;
        } else {
          maxofs = hint + 1;
          while (ofs < maxofs) {
            if (lower(a.getitem(p - ofs), key)) {
              break;
            } else {
              lastofs = ofs;
              try {
                ofs = (ofs << 1) + 1;
              } catch (err) {
                ofs = maxofs;
              }
            }
          }
          if (ofs > maxofs) {
            ofs = maxofs;
          }
          hintminofs = hint - ofs;
          hintminlastofs = hint - lastofs;
          lastofs = hintminofs;
          ofs = hintminlastofs;
        }
        Sk.asserts.assert(-1 <= lastofs < ofs <= a.len);
        lastofs += 1;
        while (lastofs < ofs) {
          m = lastofs + (ofs - lastofs >> 1);
          if (lower(a.getitem(a.base + m), key)) {
            lastofs = m + 1;
          } else {
            ofs = m;
          }
        }
        Sk.asserts.assert(lastofs == ofs);
        return ofs;
      };
      Sk.builtin.timSort.prototype.merge_init = function() {
        this.min_gallop = this.MIN_GALLOP;
        this.pending = [];
      };
      Sk.builtin.timSort.prototype.merge_lo = function(a, b) {
        var min_gallop;
        var dest;
        var acount, bcount;
        var p;
        Sk.asserts.assert(a.len > 0 && b.len > 0 && a.base + a.len == b.base);
        min_gallop = this.min_gallop;
        dest = a.base;
        a = a.copyitems();
        try {
          this.setitem(dest, b.popleft());
          dest++;
          if (a.len == 1 || b.len === 0) {
            return;
          }
          while (true) {
            acount = 0;
            bcount = 0;
            while (true) {
              if (this.lt(b.getitem(b.base), a.getitem(a.base))) {
                this.setitem(dest, b.popleft());
                dest++;
                if (b.len === 0) {
                  return;
                }
                bcount++;
                acount = 0;
                if (bcount >= min_gallop) {
                  break;
                }
              } else {
                this.setitem(dest, a.popleft());
                dest++;
                if (a.len == 1) {
                  return;
                }
                acount++;
                bcount = 0;
                if (acount >= min_gallop) {
                  break;
                }
              }
            }
            min_gallop += 1;
            while (true) {
              min_gallop -= min_gallop > 1;
              this.min_gallop = min_gallop;
              acount = this.gallop(b.getitem(b.base), a, 0, true);
              for (p = a.base; p < a.base + acount; p++) {
                this.setitem(dest, a.getitem(p));
                dest++;
              }
              a.advance(acount);
              if (a.len <= 1) {
                return;
              }
              this.setitem(dest, b.popleft());
              dest++;
              if (b.len === 0) {
                return;
              }
              bcount = this.gallop(a.getitem(a.base), b, 0, false);
              for (p = b.base; p < b.base + bcount; p++) {
                this.setitem(dest, b.getitem(p));
                dest++;
              }
              b.advance(bcount);
              if (b.len === 0) {
                return;
              }
              this.setitem(dest, a.popleft());
              dest++;
              if (a.len == 1) {
                return;
              }
              if (acount < this.MIN_GALLOP && bcount < this.MIN_GALLOP) {
                break;
              }
              min_gallop++;
              this.min_gallop = min_gallop;
            }
          }
        } finally {
          Sk.asserts.assert(a.len >= 0 && b.len >= 0);
          for (p = b.base; p < b.base + b.len; p++) {
            this.setitem(dest, b.getitem(p));
            dest++;
          }
          for (p = a.base; p < a.base + a.len; p++) {
            this.setitem(dest, a.getitem(p));
            dest++;
          }
        }
      };
      Sk.builtin.timSort.prototype.merge_hi = function(a, b) {
        var min_gallop;
        var dest;
        var acount, bcount, nexta, nextb;
        var k;
        var p;
        Sk.asserts.assert(a.len > 0 && b.len > 0 && a.base + a.len == b.base);
        min_gallop = this.min_gallop;
        dest = b.base + b.len;
        b = b.copyitems();
        try {
          dest--;
          this.setitem(dest, a.popright());
          if (a.len === 0 || b.len == 1) {
            return;
          }
          while (true) {
            acount = 0;
            bcount = 0;
            while (true) {
              nexta = a.getitem(a.base + a.len - 1);
              nextb = b.getitem(b.base + b.len - 1);
              if (this.lt(nextb, nexta)) {
                dest--;
                this.setitem(dest, nexta);
                a.len--;
                if (a.len === 0) {
                  return;
                }
                acount++;
                bcount = 0;
                if (acount >= min_gallop) {
                  break;
                }
              } else {
                dest--;
                this.setitem(dest, nextb);
                b.len--;
                if (b.len == 1) {
                  return;
                }
                bcount++;
                acount = 0;
                if (bcount >= min_gallop) {
                  break;
                }
              }
            }
            min_gallop += 1;
            while (true) {
              min_gallop -= min_gallop > 1;
              this.min_gallop = min_gallop;
              nextb = b.getitem(b.base + b.len - 1);
              k = this.gallop(nextb, a, a.len - 1, true);
              acount = a.len - k;
              for (p = a.base + a.len - 1; p > a.base + k - 1; p--) {
                dest--;
                this.setitem(dest, a.getitem(p));
              }
              a.len -= acount;
              if (a.len === 0) {
                return;
              }
              dest--;
              this.setitem(dest, b.popright());
              if (b.len == 1) {
                return;
              }
              nexta = a.getitem(a.base + a.len - 1);
              k = this.gallop(nexta, b, b.len - 1, false);
              bcount = b.len - k;
              for (p = b.base + b.len - 1; p > b.base + k - 1; p--) {
                dest--;
                this.setitem(dest, b.getitem(p));
              }
              b.len -= bcount;
              if (b.len <= 1) {
                return;
              }
              dest--;
              this.setitem(dest, a.popright());
              if (a.len === 0) {
                return;
              }
              if (acount < this.MIN_GALLOP && bcount < this.MIN_GALLOP) {
                break;
              }
              min_gallop++;
              this.min_gallop = min_gallop;
            }
          }
        } finally {
          Sk.asserts.assert(a.len >= 0 && b.len >= 0);
          for (p = a.base + a.len - 1; p > a.base - 1; p--) {
            dest--;
            this.setitem(dest, a.getitem(p));
          }
          for (p = b.base + b.len - 1; p > b.base - 1; p--) {
            dest--;
            this.setitem(dest, b.getitem(p));
          }
        }
      };
      Sk.builtin.timSort.prototype.merge_at = function(i) {
        var a;
        var b;
        var k;
        if (i < 0) {
          i = this.pending.length + i;
        }
        a = this.pending[i];
        b = this.pending[i + 1];
        Sk.asserts.assert(a.len > 0 && b.len > 0);
        Sk.asserts.assert(a.base + a.len == b.base);
        this.pending[i] = new Sk.builtin.listSlice(this.list, a.base, a.len + b.len);
        this.pending.splice(i + 1, 1);
        k = this.gallop(b.getitem(b.base), a, 0, true);
        a.advance(k);
        if (a.len === 0) {
          return;
        }
        b.len = this.gallop(a.getitem(a.base + a.len - 1), b, b.len - 1, false);
        if (b.len === 0) {
          return;
        }
        if (a.len <= b.len) {
          this.merge_lo(a, b);
        } else {
          this.merge_hi(a, b);
        }
      };
      Sk.builtin.timSort.prototype.merge_collapse = function() {
        var p = this.pending;
        while (p.length > 1) {
          if (p.length >= 3 && p[p.length - 3].len <= p[p.length - 2].len + p[p.length - 1].len) {
            if (p[p.length - 3].len < p[p.length - 1].len) {
              this.merge_at(-3);
            } else {
              this.merge_at(-2);
            }
          } else if (p[p.length - 2].len <= p[p.length - 1].len) {
            this.merge_at(-2);
          } else {
            break;
          }
        }
      };
      Sk.builtin.timSort.prototype.merge_force_collapse = function() {
        var p = this.pending;
        while (p.length > 1) {
          if (p.length >= 3 && p[p.length - 3].len < p[p.length - 1].len) {
            this.merge_at(-3);
          } else {
            this.merge_at(-2);
          }
        }
      };
      Sk.builtin.timSort.prototype.merge_compute_minrun = function(n) {
        var r = 0;
        while (n >= 64) {
          r = r | n & 1;
          n >>= 1;
        }
        return n + r;
      };
      Sk.builtin.listSlice = function(list, base, len) {
        this.list = list;
        this.base = base;
        this.len = len;
      };
      Sk.builtin.listSlice.prototype.copyitems = function() {
        var start = this.base;
        var stop = this.base + this.len;
        Sk.asserts.assert(0 <= start <= stop);
        return new Sk.builtin.listSlice(
          new Sk.builtin.list(this.list.v.slice(start, stop)),
          0,
          this.len
        );
      };
      Sk.builtin.listSlice.prototype.advance = function(n) {
        this.base += n;
        this.len -= n;
        Sk.asserts.assert(this.base <= this.list.sq$length());
      };
      Sk.builtin.listSlice.prototype.getitem = function(item) {
        return this.list.v[item];
      };
      Sk.builtin.listSlice.prototype.setitem = function(item, value) {
        this.list.v[item] = value;
      };
      Sk.builtin.listSlice.prototype.popleft = function() {
        var result = this.list.v[this.base];
        this.base++;
        this.len--;
        return result;
      };
      Sk.builtin.listSlice.prototype.popright = function() {
        this.len--;
        return this.list.v[this.base + this.len];
      };
      Sk.builtin.listSlice.prototype.reverse = function() {
        var list_hi;
        var list_lo;
        var list = this.list;
        var lo = this.base;
        var hi = lo + this.len - 1;
        while (lo < hi) {
          list_hi = list.v[hi];
          list_lo = list.v[lo];
          list.v[lo] = list_hi;
          list.v[hi] = list_lo;
          lo++;
          hi--;
        }
      };
      Sk.exportSymbol("Sk.builtin.listSlice", Sk.builtin.listSlice);
      Sk.exportSymbol("Sk.builtin.timSort", Sk.builtin.timSort);
    }
  });

  // src/super.js
  var require_super = __commonJS({
    "src/super.js"() {
      Sk.builtin.super_ = Sk.abstr.buildNativeClass("super", {
        constructor: function super_(a_type, other_self) {
          Sk.asserts.assert(this instanceof Sk.builtin.super_, "bad call to super, use 'new'");
          this.type = a_type;
          this.obj = other_self;
          if (a_type !== void 0) {
            if (!Sk.builtin.checkClass(a_type)) {
              throw new Sk.builtin.TypeError("must be type, not " + Sk.abstr.typeName(a_type));
            }
          }
          if (this.obj !== void 0) {
            this.obj_type = this.$supercheck(a_type, this.obj);
          } else {
            this.obj_type = null;
          }
        },
        slots: {
          tp$doc: "super() -> same as super(__class__, <first argument>)\nsuper(type) -> unbound super object\nsuper(type, obj) -> bound super object; requires isinstance(obj, type)\nsuper(type, type2) -> bound super object; requires issubclass(type2, type)\nTypical use to call a cooperative superclass method:\nclass C(B):\n    def meth(self, arg):\n        super().meth(arg)\nThis works for class methods too:\nclass C(B):\n    @classmethod\n    def cmeth(cls, arg):\n        super().cmeth(arg)\n",
          tp$new: Sk.generic.new,
          tp$init(args, kwargs) {
            Sk.abstr.checkNoKwargs("super", kwargs);
            Sk.abstr.checkArgsLen("super", args, 1, 2);
            const a_type = args[0];
            const other_self = args[1];
            if (!Sk.builtin.checkClass(a_type)) {
              throw new Sk.builtin.TypeError("must be type, not " + Sk.abstr.typeName(a_type));
            }
            this.obj = other_self;
            this.type = a_type;
            if (this.obj != null) {
              this.obj_type = this.$supercheck(a_type, this.obj);
            }
            return Sk.builtin.none.none$;
          },
          $r() {
            if (this.obj) {
              return new Sk.builtin.str(
                "<super: <class '" + this.type.prototype.tp$name + "'>, <" + Sk.abstr.typeName(this.obj) + " object>>"
              );
            }
            return new Sk.builtin.str(
              "<super: <class '" + this.type.prototype.tp$name + "'>, NULL>"
            );
          },
          tp$getattr(pyName, canSuspend) {
            let starttype = this.obj_type;
            if (starttype == null) {
              return Sk.generic.getAttr.call(this, pyName, canSuspend);
            }
            const mro = starttype.prototype.tp$mro;
            const n = mro.length;
            if (pyName === Sk.builtin.str.$class) {
              return Sk.generic.getAttr.call(this, pyName, canSuspend);
            }
            let i;
            for (i = 0; i + 1 < n; i++) {
              if (this.type === mro[i]) {
                break;
              }
            }
            i++;
            if (i >= n) {
              return Sk.generic.getAttr.call(this, pyName, canSuspend);
            }
            const jsName = pyName.$mangled;
            let tmp, res;
            while (i < n) {
              tmp = mro[i].prototype;
              if (tmp.hasOwnProperty(jsName)) {
                res = tmp[jsName];
              }
              if (res !== void 0) {
                const f = res.tp$descr_get;
                if (f !== void 0) {
                  res = f.call(res, this.obj === starttype ? null : this.obj, starttype);
                }
                return res;
              }
              i++;
            }
          },
          tp$descr_get(obj, obtype) {
            if (obj === null || this.obj != null) {
              return this;
            }
            if (this.ob$type !== Sk.builtin.super_) {
              return Sk.misceval.callsimOrSuspendArray(this.ob$type, [this.type, obj]);
            } else {
              const obj_type = this.$supercheck(this.type, obj);
              const newobj = new Sk.builtin.super_();
              newobj.type = this.type;
              newobj.obj = obj;
              newobj.obj_type = obj_type;
              return newobj;
            }
          }
        },
        getsets: {
          __thisclass__: {
            $get() {
              return this.type;
            },
            $doc: "the class invoking super()"
          },
          __self__: {
            $get() {
              return this.obj || Sk.builtin.none.none$;
            },
            $doc: "the instance invoking super(); may be None"
          },
          __self_class__: {
            $get() {
              return this.obj_type || Sk.builtin.none.none$;
            },
            $doc: "the type of the instance invoking super(); may be None"
          }
        },
        proto: {
          $supercheck(type, obj) {
            if (Sk.builtin.checkClass(obj) && obj.$isSubType(type)) {
              return obj;
            }
            if (obj.ob$type.$isSubType(type)) {
              return obj.ob$type;
            } else {
              const class_attr = obj.tp$getattr(Sk.builtin.str.$class);
              if (class_attr !== void 0 && class_attr !== obj.ob$type && Sk.builtin.checkClass(class_attr)) {
                if (class_attr.$isSubType(type)) {
                  return class_attr;
                }
              }
            }
            throw new Sk.builtin.TypeError(
              "super(type, obj): obj must be an instance or subtype of type"
            );
          }
        }
      });
    }
  });

  // src/generic_alias.js
  var require_generic_alias = __commonJS({
    "src/generic_alias.js"() {
      Sk.builtin.GenericAlias = Sk.abstr.buildNativeClass("types.GenericAlias", {
        constructor: function GenericAlias(origin, args) {
          this.$origin = origin;
          if (!(args instanceof Sk.builtin.tuple)) {
            args = new Sk.builtin.tuple([args]);
          }
          this.$args = args;
          this.$params = null;
        },
        slots: {
          tp$new(args, kwargs) {
            Sk.abstr.checkNoKwargs("GenericAlias", kwargs);
            Sk.abstr.checkArgsLen("GenericAlias", args, 2, 2);
            return new Sk.builtin.GenericAlias(args[0], args[1]);
          },
          tp$getattr(pyName, canSuspend) {
            if (Sk.builtin.checkString(pyName)) {
              if (!this.attr$exc.includes(pyName)) {
                return this.$origin.tp$getattr(pyName, canSuspend);
              }
            }
            return Sk.generic.getAttr.call(this, pyName, canSuspend);
          },
          $r() {
            const origin_repr = this.ga$repr(this.$origin);
            let arg_repr = "";
            this.$args.v.forEach((arg, i) => {
              arg_repr += i > 0 ? ", " : "";
              arg_repr += this.ga$repr(arg);
            });
            if (!arg_repr) {
              arg_repr = "()";
            }
            return new Sk.builtin.str(origin_repr + "[" + arg_repr + "]");
          },
          tp$doc: "Represent a PEP 585 generic type\n\nE.g. for t = list[int], t.origin is list and t.args is (int,).",
          tp$hash() {
            const h0 = Sk.abstr.objectHash(this.$origin);
            if (h0 == -1) {
              return -1;
            }
            const h1 = Sk.abstr.objectHash(this.$args);
            if (h1 == -1) {
              return -1;
            }
            return h0 ^ h1;
          },
          tp$call(args, kwargs) {
            const obj = Sk.misceval.callsimArray(this.$origin, args, kwargs);
            try {
              obj.tp$setattr(new Sk.builtin.str("__orig_class__"), this);
            } catch (e) {
              if (!(e instanceof Sk.builtin.AttributeError) && !(e instanceof Sk.builtin.TypeError)) {
                throw e;
              }
            }
            return obj;
          },
          tp$richcompare(other, op) {
            if (!(other instanceof Sk.builtin.GenericAlias) || op !== "Eq" && op !== "NotEq") {
              return Sk.builtin.NotImplemented.NotImplemented$;
            }
            const eq = Sk.misceval.richCompareBool(this.$origin, other.$origin, "Eq");
            if (!eq) {
              return op === "Eq" ? eq : !eq;
            }
            const res = Sk.misceval.richCompareBool(this.$args, other.$args, "Eq");
            return op === "Eq" ? res : !res;
          },
          tp$as_sequence_or_mapping: true,
          mp$subscript(item) {
            if (this.$params === null) {
              this.mk$params();
            }
            const nparams = this.$params.sq$length();
            if (nparams === 0) {
              throw new Sk.builtin.TypeError(
                "There are no type variables left in " + Sk.misceval.objectRepr(this)
              );
            }
          }
        },
        methods: {
          __mro_entries__: {
            $meth() {
              return new Sk.builtin.tuple([this.$origin]);
            },
            $flags: { NoArgs: true }
          },
          __instancecheck__: {
            $meth(_) {
              throw new Sk.builtin.TypeError(
                "isinstance() argument 2 cannot be a parameterized generic"
              );
            },
            $flags: { OneArg: true }
          },
          __subclasscheck__: {
            $meth(_) {
              throw new Sk.builtin.TypeError(
                "issubclass() argument 2 cannot be a parameterized generic"
              );
            },
            $flags: { OneArg: true }
          }
        },
        getsets: {
          __parameters__: {
            $get() {
              if (this.$params === null) {
                this.mk$params();
              }
              return this.$params;
            },
            $doc: "Type variables in the GenericAlias."
          },
          __origin__: {
            $get() {
              return this.$origin;
            }
          },
          __args__: {
            $get() {
              return this.$args;
            }
          }
        },
        proto: {
          // functions here match similar functions in Objects/genericaliasobject.c
          mk$params() {
            const arg_arr = this.$args.v;
            const params = [];
            arg_arr.forEach((t) => {
              if (this.is$typevar(t)) {
                if (this.tuple$index(params, t) < 0) {
                  params.push(t);
                }
              }
            });
            this.$params = new Sk.builtin.tuple(params);
          },
          tuple$index(tup_arr, item) {
            return tup_arr.indexOf(item);
          },
          is$typevar(type) {
            if (type.tp$name !== "TypeVar") {
              return false;
            }
            const module2 = Sk.abstr.lookupSpecial(type, Sk.builtin.str.$module);
            if (module2 === void 0) {
              throw Sk.builtin.RuntimeError("found object withought a __module__");
            }
            return module2.toString() === "typing";
          },
          ga$repr(item) {
            if (item === Sk.builtin.Ellipsis) {
              return "...";
            }
            if (Sk.abstr.lookupSpecial(item, this.str$orig)) {
              if (Sk.abstr.lookupSpecial(item, this.str$args)) {
                return Sk.misceval.objectRepr(item);
              }
            }
            const qualname = Sk.abstr.lookupSpecial(item, Sk.builtin.str.$qualname);
            if (qualname === void 0) {
              return Sk.misceval.objectRepr(item);
            }
            const mod = Sk.abstr.lookupSpecial(item, Sk.builtin.str.$module);
            if (mod === void 0 || Sk.builtin.checkNone(mod)) {
              return Sk.misceval.objectRepr(item);
            } else if (mod.toString() === "builtins") {
              return qualname.toString();
            }
            return mod.toString() + "." + qualname.toString();
          },
          str$orig: new Sk.builtin.str("__origin__"),
          str$args: new Sk.builtin.str("__args__"),
          attr$exc: [
            "__origin__",
            "__args__",
            "__parameters__",
            "__mro_entries__",
            "__reduce_ex__",
            // needed so we don't look up object.__reduce_ex__
            "__reduce__"
          ].map((x) => new Sk.builtin.str(x))
        }
      });
    }
  });

  // src/builtindict.js
  var require_builtindict = __commonJS({
    "src/builtindict.js"() {
      Sk.builtins = {
        round: null,
        len: null,
        min: null,
        max: null,
        sum: null,
        abs: null,
        fabs: null,
        ord: null,
        chr: null,
        hex: null,
        oct: null,
        bin: null,
        dir: null,
        repr: null,
        open: null,
        isinstance: null,
        hash: null,
        getattr: null,
        hasattr: null,
        id: null,
        //"reduce": new Sk.builtin.func(Sk.builtin.reduce),
        sorted: null,
        any: null,
        all: null,
        // iterator objects if py2 mode we replace these with sk_methods
        enumerate: Sk.builtin.enumerate,
        filter: Sk.builtin.filter_,
        map: Sk.builtin.map_,
        range: Sk.builtin.range_,
        reversed: Sk.builtin.reversed,
        zip: Sk.builtin.zip_,
        BaseException: Sk.builtin.BaseException,
        AttributeError: Sk.builtin.AttributeError,
        ValueError: Sk.builtin.ValueError,
        Exception: Sk.builtin.Exception,
        ZeroDivisionError: Sk.builtin.ZeroDivisionError,
        AssertionError: Sk.builtin.AssertionError,
        ImportError: Sk.builtin.ImportError,
        IndentationError: Sk.builtin.IndentationError,
        IndexError: Sk.builtin.IndexError,
        LookupError: Sk.builtin.LookupError,
        KeyError: Sk.builtin.KeyError,
        TypeError: Sk.builtin.TypeError,
        UnicodeDecodeError: Sk.builtin.UnicodeDecodeError,
        UnicodeEncodeError: Sk.builtin.UnicodeEncodeError,
        NameError: Sk.builtin.NameError,
        UnboundLocalError: Sk.builtin.UnboundLocalError,
        OSError: Sk.builtin.OSError,
        TimeoutError: Sk.builtin.TimeoutError,
        IOError: Sk.builtin.IOError,
        NotImplementedError: Sk.builtin.NotImplementedError,
        SystemExit: Sk.builtin.SystemExit,
        OverflowError: Sk.builtin.OverflowError,
        OperationError: Sk.builtin.OperationError,
        NegativePowerError: Sk.builtin.NegativePowerError,
        RuntimeError: Sk.builtin.RuntimeError,
        RecursionError: Sk.builtin.RecursionError,
        StopIteration: Sk.builtin.StopIteration,
        SyntaxError: Sk.builtin.SyntaxError,
        SystemError: Sk.builtin.SystemError,
        KeyboardInterrupt: Sk.builtin.KeyboardInterrupt,
        EOFError: Sk.builtin.EOFError,
        MemoryError: Sk.builtin.MemoryError,
        ReferenceError: Sk.builtin.ReferenceError,
        float_$rw$: Sk.builtin.float_,
        int_$rw$: Sk.builtin.int_,
        bool: Sk.builtin.bool,
        complex: Sk.builtin.complex,
        dict: Sk.builtin.dict,
        file: Sk.builtin.file,
        frozenset: Sk.builtin.frozenset,
        function: Sk.builtin.func,
        generator: Sk.builtin.generator,
        list: Sk.builtin.list,
        long_$rw$: Sk.builtin.lng,
        method: Sk.builtin.method,
        object: Sk.builtin.object,
        slice: Sk.builtin.slice,
        str: Sk.builtin.str,
        set: Sk.builtin.set,
        tuple: Sk.builtin.tuple,
        type: Sk.builtin.type,
        input: null,
        raw_input: new Sk.builtin.func(Sk.builtin.raw_input),
        setattr: null,
        /*'read': Sk.builtin.read,*/
        jseval: Sk.builtin.jseval,
        jsmillis: Sk.builtin.jsmillis,
        quit: new Sk.builtin.func(Sk.builtin.quit),
        exit: new Sk.builtin.func(Sk.builtin.quit),
        print: null,
        divmod: null,
        format: null,
        globals: null,
        issubclass: null,
        iter: null,
        // Functions below are not implemented
        bytearray: Sk.builtin.bytearray,
        // "callable"  : Sk.builtin.callable,
        // "delattr"   : Sk.builtin.delattr,
        // "eval_$rw$" : Sk.builtin.eval_,
        execfile: Sk.builtin.execfile,
        exec: Sk.builtin.exec,
        compile: Sk.builtin.compile,
        help: Sk.builtin.help,
        // "locals"    : Sk.builtin.locals,
        memoryview: Sk.builtin.memoryview,
        // "next"      : Sk.builtin.next_,
        // "pow"       : Sk.builtin.pow,
        reload: Sk.builtin.reload,
        super_$rw$: Sk.builtin.super_,
        unichr: new Sk.builtin.func(Sk.builtin.unichr),
        vars: Sk.builtin.vars,
        apply_$rw$: Sk.builtin.apply_,
        buffer: Sk.builtin.buffer,
        coerce: Sk.builtin.coerce,
        intern: Sk.builtin.intern,
        property: Sk.builtin.property,
        classmethod: Sk.builtin.classmethod,
        staticmethod: Sk.builtin.staticmethod,
        Ellipsis: Sk.builtin.Ellipsis
      };
      var pyNone = Sk.builtin.none.none$;
      var emptyTuple = new Sk.builtin.tuple();
      var pyZero = new Sk.builtin.int_(0);
      Sk.abstr.setUpModuleMethods("builtins", Sk.builtins, {
        // __build_class__: {
        //     $meth: Sk.builtin.__build_class__,
        //     $flags: {},
        //     $textsig: null,
        //     $doc: "__build_class__(func, name, *bases, metaclass=None, **kwds) -> class\n\nInternal helper function used by the class statement."
        // },
        __import__: {
          $meth(name, globals, _locals, formlist, level) {
            if (!Sk.builtin.checkString(name)) {
              throw new Sk.builtin.TypeError(
                "__import__() argument 1 must be str, not " + name.tp$name
              );
            } else if (name === Sk.builtin.str.$empty && level.v === 0) {
              throw new Sk.builtin.ValueError("Empty module name");
            }
            globals = globLocToJs(globals, "globals") || {};
            formlist = Sk.ffi.remapToJs(formlist);
            level = Sk.ffi.remapToJs(level);
            return Sk.builtin.__import__(name, globals, void 0, formlist, level);
          },
          $flags: {
            NamedArgs: ["name", "globals", "locals", "fromlist", "level"],
            Defaults: [pyNone, pyNone, emptyTuple, pyZero]
          },
          $textsig: null,
          $doc: "__import__(name, globals=None, locals=None, fromlist=(), level=0) -> module\n\nImport a module. Because this function is meant for use by the Python\ninterpreter and not for general use, it is better to use\nimportlib.import_module() to programmatically import a module.\n\nThe globals argument is only used to determine the context;\nthey are not modified.  The locals argument is unused.  The fromlist\nshould be a list of names to emulate ``from name import ...'', or an\nempty list to emulate ``import name''.\nWhen importing a module from a package, note that __import__('A.B', ...)\nreturns package A when fromlist is empty, but its submodule B when\nfromlist is not empty.  The level argument is used to determine whether to\nperform absolute or relative imports: 0 is absolute, while a positive number\nis the number of parent directories to search relative to the current module."
        },
        abs: {
          $meth: Sk.builtin.abs,
          $flags: { OneArg: true },
          $textsig: "($module, x, /)",
          $doc: "Return the absolute value of the argument."
        },
        all: {
          $meth: Sk.builtin.all,
          $flags: { OneArg: true },
          $textsig: "($module, iterable, /)",
          $doc: "Return True if bool(x) is True for all values x in the iterable.\n\nIf the iterable is empty, return True."
        },
        any: {
          $meth: Sk.builtin.any,
          $flags: { OneArg: true },
          $textsig: "($module, iterable, /)",
          $doc: "Return True if bool(x) is True for any x in the iterable.\n\nIf the iterable is empty, return False."
        },
        ascii: {
          $meth: Sk.builtin.ascii,
          $flags: { OneArg: true },
          $textsig: "($module, obj, /)",
          $doc: "Return an ASCII-only representation of an object.\n\nAs repr(), return a string containing a printable representation of an\nobject, but escape the non-ASCII characters in the string returned by\nrepr() using \\\\x, \\\\u or \\\\U escapes. This generates a string similar\nto that returned by repr() in Python 2."
        },
        bin: {
          $meth: Sk.builtin.bin,
          $flags: { OneArg: true },
          $textsig: "($module, number, /)",
          $doc: "Return the binary representation of an integer.\n\n   >>> bin(2796202)\n   '0b1010101010101010101010'"
        },
        // breakpoint: {
        //     $meth: Sk.builtin.breakpoint,
        //     $flags: {},
        //     $textsig: null,
        //     $doc: "breakpoint(*args, **kws)\n\nCall sys.breakpointhook(*args, **kws).  sys.breakpointhook() must accept\nwhatever arguments are passed.\n\nBy default, this drops you into the pdb debugger."
        // },
        callable: {
          $meth: Sk.builtin.callable,
          $flags: { OneArg: true },
          $textsig: "($module, obj, /)",
          $doc: "Return whether the object is callable (i.e., some kind of function).\n\nNote that classes are callable, as are instances of classes with a\n__call__() method."
        },
        chr: {
          $meth: Sk.builtin.chr,
          $flags: { OneArg: true },
          $textsig: "($module, i, /)",
          $doc: "Return a Unicode string of one character with ordinal i; 0 <= i <= 0x10ffff."
        },
        compile: {
          $meth: Sk.builtin.compile,
          $flags: { MinArgs: 3, MaxArgs: 6 },
          $textsig: "($module, /, source, filename, mode, flags=0,\n        dont_inherit=False, optimize=-1)",
          $doc: "Compile source into a code object that can be executed by exec() or eval().\n\nThe source code may represent a Python module, statement or expression.\nThe filename will be used for run-time error messages.\nThe mode must be 'exec' to compile a module, 'single' to compile a\nsingle (interactive) statement, or 'eval' to compile an expression.\nThe flags argument, if present, controls which future statements influence\nthe compilation of the code.\nThe dont_inherit argument, if true, stops the compilation inheriting\nthe effects of any future statements in effect in the code calling\ncompile; if absent or false these statements do influence the compilation,\nin addition to any features explicitly specified."
        },
        delattr: {
          $meth: Sk.builtin.delattr,
          $flags: { MinArgs: 2, MaxArgs: 2 },
          $textsig: "($module, obj, name, /)",
          $doc: "Deletes the named attribute from the given object.\n\ndelattr(x, 'y') is equivalent to ``del x.y''"
        },
        dir: {
          $meth: Sk.builtin.dir,
          $flags: { MinArgs: 0, MaxArgs: 1 },
          $textsig: null,
          $doc: "dir([object]) -> list of strings\n\nIf called without an argument, return the names in the current scope.\nElse, return an alphabetized list of names comprising (some of) the attributes\nof the given object, and of attributes reachable from it.\nIf the object supplies a method named __dir__, it will be used; otherwise\nthe default dir() logic is used and returns:\n  for a module object: the module's attributes.\n  for a class object:  its attributes, and recursively the attributes\n    of its bases.\n  for any other object: its attributes, its class's attributes, and\n    recursively the attributes of its class's base classes."
        },
        divmod: {
          $meth: Sk.builtin.divmod,
          $flags: { MinArgs: 2, MaxArgs: 2 },
          $textsig: "($module, x, y, /)",
          $doc: "Return the tuple (x//y, x%y).  Invariant: div*y + mod == x."
        },
        eval_$rw$: {
          $name: "eval",
          $meth: function(source, globals, locals) {
            const tmp_globals = globLocToJs(globals, "globals");
            const tmp_locals = globLocToJs(locals, "locals");
            return Sk.misceval.chain(Sk.builtin.eval(source, tmp_globals, tmp_locals), (res) => {
              reassignGlobLoc(globals, tmp_globals);
              reassignGlobLoc(locals, tmp_locals);
              return res;
            });
          },
          $flags: { MinArgs: 1, MaxArgs: 3 },
          $textsig: "($module, source, globals=None, locals=None, /)",
          $doc: "Evaluate the given source in the context of globals and locals.\n\nThe source may be a string representing a Python expression\nor a code object as returned by compile().\nThe globals must be a dictionary and locals can be any mapping,\ndefaulting to the current globals and locals.\nIf only globals is given, locals defaults to it."
        },
        exec: {
          $meth: function(source, globals, locals) {
            const tmp_globals = globLocToJs(globals, "globals");
            const tmp_locals = globLocToJs(locals, "locals");
            return Sk.misceval.chain(
              Sk.builtin.exec(source, tmp_globals, tmp_locals),
              (new_locals) => {
                reassignGlobLoc(globals, tmp_globals);
                reassignGlobLoc(locals, tmp_locals);
                return Sk.builtin.none.none$;
              }
            );
          },
          $flags: { MinArgs: 1, MaxArgs: 3 },
          $textsig: "($module, source, globals=None, locals=None, /)",
          $doc: "Execute the given source in the context of globals and locals.\n\nThe source may be a string representing one or more Python statements\nor a code object as returned by compile().\nThe globals must be a dictionary and locals can be any mapping,\ndefaulting to the current globals and locals.\nIf only globals is given, locals defaults to it."
        },
        format: {
          $meth: Sk.builtin.format,
          $flags: { MinArgs: 1, MaxArgs: 2 },
          $textsig: "($module, value, format_spec='', /)",
          $doc: "Return value.__format__(format_spec)\n\nformat_spec defaults to the empty string.\nSee the Format Specification Mini-Language section of help('FORMATTING') for\ndetails."
        },
        getattr: {
          $meth: Sk.builtin.getattr,
          $flags: { MinArgs: 2, MaxArgs: 3 },
          $textsig: null,
          $doc: "getattr(object, name[, default]) -> value\n\nGet a named attribute from an object; getattr(x, 'y') is equivalent to x.y.\nWhen a default argument is given, it is returned when the attribute doesn't\nexist; without it, an exception is raised in that case."
        },
        globals: {
          $meth: Sk.builtin.globals,
          $flags: { NoArgs: true },
          $textsig: "($module, /)",
          $doc: "Return the dictionary containing the current scope's global variables.\n\nNOTE: Updates to this dictionary *will* affect name lookups in the current\nglobal scope and vice-versa."
        },
        hasattr: {
          $meth: Sk.builtin.hasattr,
          $flags: { MinArgs: 2, MaxArgs: 2 },
          $textsig: "($module, obj, name, /)",
          $doc: "Return whether the object has an attribute with the given name.\n\nThis is done by calling getattr(obj, name) and catching AttributeError."
        },
        hash: {
          $meth: Sk.builtin.hash,
          $flags: { OneArg: true },
          $textsig: "($module, obj, /)",
          $doc: "Return the hash value for the given object.\n\nTwo objects that compare equal must also have the same hash value, but the\nreverse is not necessarily true."
        },
        hex: {
          $meth: Sk.builtin.hex,
          $flags: { OneArg: true },
          $textsig: "($module, number, /)",
          $doc: "Return the hexadecimal representation of an integer.\n\n   >>> hex(12648430)\n   '0xc0ffee'"
        },
        id: {
          $meth: Sk.builtin.id,
          $flags: { OneArg: true },
          $textsig: "($module, obj, /)",
          $doc: "Return the identity of an object.\n\nThis is guaranteed to be unique among simultaneously existing objects.\n(CPython uses the object's memory address.)"
        },
        input: {
          $meth: Sk.builtin.input,
          $flags: { MinArgs: 0, MaxArgs: 1 },
          $textsig: "($module, prompt=None, /)",
          $doc: "Read a string from standard input.  The trailing newline is stripped.\n\nThe prompt string, if given, is printed to standard output without a\ntrailing newline before reading input.\n\nIf the user hits EOF (*nix: Ctrl-D, Windows: Ctrl-Z+Return), raise EOFError.\nOn *nix systems, readline is used if available."
        },
        isinstance: {
          $meth: Sk.builtin.isinstance,
          $flags: { MinArgs: 2, MaxArgs: 2 },
          $textsig: "($module, obj, class_or_tuple, /)",
          $doc: "Return whether an object is an instance of a class or of a subclass thereof.\n\nA tuple, as in ``isinstance(x, (A, B, ...))``, may be given as the target to\ncheck against. This is equivalent to ``isinstance(x, A) or isinstance(x, B)\nor ...`` etc."
        },
        issubclass: {
          $meth: Sk.builtin.issubclass,
          $flags: { MinArgs: 2, MaxArgs: 2 },
          $textsig: "($module, cls, class_or_tuple, /)",
          $doc: "Return whether 'cls' is a derived from another class or is the same class.\n\nA tuple, as in ``issubclass(x, (A, B, ...))``, may be given as the target to\ncheck against. This is equivalent to ``issubclass(x, A) or issubclass(x, B)\nor ...`` etc."
        },
        iter: {
          $meth: Sk.builtin.iter,
          $flags: { MinArgs: 1, MaxArgs: 2 },
          $textsig: "($module, iterable /)",
          $doc: "iter(iterable) -> iterator\niter(callable, sentinel) -> iterator\n\nGet an iterator from an object.  In the first form, the argument must\nsupply its own iterator, or be a sequence.\nIn the second form, the callable is called until it returns the sentinel."
        },
        len: {
          $meth: Sk.builtin.len,
          $flags: { OneArg: true },
          $textsig: "($module, obj, /)",
          $doc: "Return the number of items in a container."
        },
        locals: {
          $meth: Sk.builtin.locals,
          $flags: { NoArgs: true },
          $textsig: "($module, /)",
          $doc: "Return a dictionary containing the current scope's local variables.\n\nNOTE: Whether or not updates to this dictionary will affect name lookups in\nthe local scope and vice-versa is *implementation dependent* and not\ncovered by any backwards compatibility guarantees."
        },
        max: {
          $meth: Sk.builtin.max,
          $flags: { FastCall: true },
          $textsig: null,
          $doc: "max(iterable, *[, default=obj, key=func]) -> value\nmax(arg1, arg2, *args, *[, key=func]) -> value\n\nWith a single iterable argument, return its biggest item. The\ndefault keyword-only argument specifies an object to return if\nthe provided iterable is empty.\nWith two or more arguments, return the largest argument."
        },
        min: {
          $meth: Sk.builtin.min,
          $flags: { FastCall: true },
          $textsig: null,
          $doc: "min(iterable, *[, default=obj, key=func]) -> value\nmin(arg1, arg2, *args, *[, key=func]) -> value\n\nWith a single iterable argument, return its smallest item. The\ndefault keyword-only argument specifies an object to return if\nthe provided iterable is empty.\nWith two or more arguments, return the smallest argument."
        },
        next: {
          $name: "next",
          $meth: Sk.builtin.next_,
          $flags: { MinArgs: 1, MaxArgs: 2 },
          $textsig: null,
          $doc: "next(iterator[, default])\n\nReturn the next item from the iterator. If default is given and the iterator\nis exhausted, it is returned instead of raising StopIteration."
        },
        oct: {
          $meth: Sk.builtin.oct,
          $flags: { OneArg: true },
          $textsig: "($module, number, /)",
          $doc: "Return the octal representation of an integer.\n\n   >>> oct(342391)\n   '0o1234567'"
        },
        open: {
          $meth: Sk.builtin.open,
          $flags: {
            MinArgs: 1,
            MaxArgs: 8,
            NamedArgs: [
              "file",
              "mode",
              "buffering",
              "encoding",
              "errors",
              "newline",
              "closefd",
              "opener"
            ],
            Defaults: [
              new Sk.builtin.str("r"),
              new Sk.builtin.int_(-1),
              pyNone,
              pyNone,
              pyNone,
              Sk.builtin.bool.true$,
              pyNone
            ]
          },
          // $textsig: null,
          $textsig: "($module, /, file, mode='r', buffering=-1, encoding=None,\n     errors=None, newline=None, closefd=True, opener=None)",
          // this is the python 2 documentation since we don't support the py3 version
          $doc: "open(name[, mode[, buffering]]) -> file object\n\nOpen a file using the file() type, returns a file object.  This is the\npreferred way to open a file.  See file.__doc__ for further information."
        },
        ord: {
          $meth: Sk.builtin.ord,
          $flags: { OneArg: true },
          $textsig: "($module, c, /)",
          $doc: "Return the Unicode code point for a one-character string."
        },
        pow: {
          $meth: Sk.builtin.pow,
          $flags: { MinArgs: 2, MaxArgs: 3 },
          $textsig: "($module, x, y, z=None, /)",
          $doc: "Equivalent to x**y (with two arguments) or x**y % z (with three arguments)\n\nSome types, such as ints, are able to use a more efficient algorithm when\ninvoked using the three argument form."
        },
        print: {
          $meth: Sk.builtin.print,
          $flags: { FastCall: true },
          $textsig: null,
          $doc: "print(value, ..., sep=' ', end='\\n', file=sys.stdout, flush=False)\n\nPrints the values to a stream, or to sys.stdout by default.\nOptional keyword arguments:\nfile:  a file-like object (stream); defaults to the current sys.stdout.\nsep:   string inserted between values, default a space.\nend:   string appended after the last value, default a newline.\nflush: whether to forcibly flush the stream."
        },
        repr: {
          $meth: Sk.builtin.repr,
          $flags: { OneArg: true },
          $textsig: "($module, obj, /)",
          $doc: "Return the canonical string representation of the object.\n\nFor many object types, including most builtins, eval(repr(obj)) == obj."
        },
        round: {
          $meth: Sk.builtin.round,
          $flags: {
            NamedArgs: ["number", "ndigits"]
          },
          $textsig: "($module, /, number, ndigits=None)",
          $doc: "Round a number to a given precision in decimal digits.\n\nThe return value is an integer if ndigits is omitted or None.  Otherwise\nthe return value has the same type as the number.  ndigits may be negative."
        },
        setattr: {
          $meth: Sk.builtin.setattr,
          $flags: { MinArgs: 3, MaxArgs: 3 },
          $textsig: "($module, obj, name, value, /)",
          $doc: "Sets the named attribute on the given object to the specified value.\n\nsetattr(x, 'y', v) is equivalent to ``x.y = v''"
        },
        sorted: {
          $meth: Sk.builtin.sorted,
          $flags: {
            NamedArgs: [null, "cmp", "key", "reverse"],
            Defaults: [pyNone, pyNone, Sk.builtin.bool.false$]
          },
          // should be fast call leave for now
          $textsig: "($module, iterable, /, *, key=None, reverse=False)",
          $doc: "Return a new list containing all items from the iterable in ascending order.\n\nA custom key function can be supplied to customize the sort order, and the\nreverse flag can be set to request the result in descending order."
        },
        sum: {
          $meth: Sk.builtin.sum,
          $flags: {
            NamedArgs: [null, "start"],
            Defaults: [new Sk.builtin.int_(0)]
          },
          $textsig: "($module, iterable, /, start=0)",
          //changed in python 3.8 start
          $doc: "Return the sum of a 'start' value (default: 0) plus an iterable of numbers\n\nWhen the iterable is empty, return the start value.\nThis function is intended specifically for use with numeric values and may\nreject non-numeric types."
        },
        vars: {
          $meth: Sk.builtin.vars,
          $flags: { MinArgs: 0, MaxArgs: 1 },
          $textsig: null,
          $doc: "vars([object]) -> dictionary\n\nWithout arguments, equivalent to locals().\nWith an argument, equivalent to object.__dict__."
        }
      });
      function globLocToJs(glob_loc, name) {
        let tmp = void 0;
        if (glob_loc === void 0 || Sk.builtin.checkNone(glob_loc)) {
          glob_loc = void 0;
        } else if (!(glob_loc instanceof Sk.builtin.dict)) {
          throw new Sk.builtin.TypeError(
            name + " must be a dict or None, not " + Sk.abstr.typeName(glob_loc)
          );
        } else {
          tmp = {};
          glob_loc.$items().forEach(([key, val]) => {
            if (Sk.builtin.checkString(key)) {
              tmp[key.$mangled] = val;
            }
          });
        }
        return tmp;
      }
      function reassignGlobLoc(dict, obj) {
        if (dict === void 0 || Sk.builtin.checkNone(dict)) {
          return;
        }
        for (let key in obj) {
          dict.mp$ass_subscript(new Sk.builtin.str(Sk.unfixReserved(key)), obj[key]);
        }
      }
      Sk.setupObjects = function(py3) {
        if (py3) {
          Sk.builtins["filter"] = Sk.builtin.filter_;
          Sk.builtins["map"] = Sk.builtin.map_;
          Sk.builtins["zip"] = Sk.builtin.zip_;
          Sk.builtins["range"] = Sk.builtin.range_;
          delete Sk.builtins["reduce"];
          delete Sk.builtins["xrange"];
          delete Sk.builtins["StandardError"];
          delete Sk.builtins["unicode"];
          delete Sk.builtins["basestring"];
          delete Sk.builtins["long_$rw$"];
          Sk.builtin.int_.prototype.$r = function() {
            return new Sk.builtin.str(this.v.toString());
          };
          delete Sk.builtin.int_.prototype.tp$str;
          delete Sk.builtin.bool.prototype.tp$str;
          delete Sk.builtins["raw_input"];
          delete Sk.builtins["unichr"];
          delete Sk.builtin.str.prototype.decode;
          Sk.builtins["bytes"] = Sk.builtin.bytes;
          Sk.builtins["ascii"] = new Sk.builtin.sk_method(
            {
              $meth: Sk.builtin.ascii,
              $flags: { OneArg: true },
              $textsig: "($module, obj, /)",
              $doc: "Return an ASCII-only representation of an object.\n\nAs repr(), return a string containing a printable representation of an\nobject, but escape the non-ASCII characters in the string returned by\nrepr() using \\\\x, \\\\u or \\\\U escapes. This generates a string similar\nto that returned by repr() in Python 2."
            },
            null,
            "builtins"
          );
        } else {
          Sk.builtins["range"] = new Sk.builtin.sk_method(
            {
              $meth: Sk.builtin.range,
              $name: "range",
              $flags: { MinArgs: 1, MaxArgs: 3 }
            },
            void 0,
            "builtins"
          );
          Sk.builtins["xrange"] = new Sk.builtin.sk_method(
            {
              $meth: Sk.builtin.xrange,
              $name: "xrange",
              $flags: { MinArgs: 1, MaxArgs: 3 }
            },
            null,
            "builtins"
          );
          Sk.builtins["reduce"] = new Sk.builtin.sk_method(
            {
              $meth: Sk.builtin.reduce,
              $name: "reduce",
              $flags: { MinArgs: 2, MaxArgs: 3 }
            },
            null,
            "builtins"
          );
          Sk.builtins["filter"] = new Sk.builtin.func(Sk.builtin.filter);
          Sk.builtins["map"] = new Sk.builtin.func(Sk.builtin.map);
          Sk.builtins["zip"] = new Sk.builtin.func(Sk.builtin.zip);
          Sk.builtins["StandardError"] = Sk.builtin.Exception;
          Sk.builtins["unicode"] = Sk.builtin.str;
          Sk.builtins["basestring"] = Sk.builtin.str;
          Sk.builtins["long_$rw$"] = Sk.builtin.lng;
          Sk.builtin.int_.prototype.$r = function() {
            const v = this.v;
            if (typeof v === "number") {
              return new Sk.builtin.str(v.toString());
            } else {
              return new Sk.builtin.str(v.toString() + "L");
            }
          };
          Sk.builtin.int_.prototype.tp$str = function() {
            return new Sk.builtin.str(this.v.toString());
          };
          Sk.builtin.bool.prototype.tp$str = function() {
            return this.$r();
          };
          Sk.builtins["raw_input"] = new Sk.builtin.func(Sk.builtin.raw_input);
          Sk.builtins["unichr"] = new Sk.builtin.func(Sk.builtin.unichr);
          Sk.builtin.str.prototype.decode = Sk.builtin.str.$py2decode;
          delete Sk.builtins["bytes"];
          delete Sk.builtins["ascii"];
        }
      };
      Sk.exportSymbol("Sk.setupObjects", Sk.setupObjects);
      Sk.exportSymbol("Sk.builtins", Sk.builtins);
    }
  });

  // src/constants.js
  var require_constants = __commonJS({
    "src/constants.js"() {
      Sk.builtin.str.$empty = new Sk.builtin.str("");
      Sk.builtin.str.$emptystr = Sk.builtin.str.$empty;
      Sk.builtin.str.$utf8 = new Sk.builtin.str("utf-8");
      Sk.builtin.str.$ascii = new Sk.builtin.str("ascii");
      Sk.builtin.str.$default_factory = new Sk.builtin.str("default_factory");
      Sk.builtin.str.$imag = new Sk.builtin.str("imag");
      Sk.builtin.str.$real = new Sk.builtin.str("real");
      Sk.builtin.str.$abs = new Sk.builtin.str("__abs__");
      Sk.builtin.str.$bytes = new Sk.builtin.str("__bytes__");
      Sk.builtin.str.$call = new Sk.builtin.str("__call__");
      Sk.builtin.str.$class = new Sk.builtin.str("__class__");
      Sk.builtin.str.$class_getitem = new Sk.builtin.str("__class_getitem__");
      Sk.builtin.str.$cmp = new Sk.builtin.str("__cmp__");
      Sk.builtin.str.$complex = new Sk.builtin.str("__complex__");
      Sk.builtin.str.$contains = new Sk.builtin.str("__contains__");
      Sk.builtin.str.$copy = new Sk.builtin.str("__copy__");
      Sk.builtin.str.$dict = new Sk.builtin.str("__dict__");
      Sk.builtin.str.$dir = new Sk.builtin.str("__dir__");
      Sk.builtin.str.$doc = new Sk.builtin.str("__doc__");
      Sk.builtin.str.$enter = new Sk.builtin.str("__enter__");
      Sk.builtin.str.$eq = new Sk.builtin.str("__eq__");
      Sk.builtin.str.$exit = new Sk.builtin.str("__exit__");
      Sk.builtin.str.$import = new Sk.builtin.str("__import__");
      Sk.builtin.str.$index = new Sk.builtin.str("__index__");
      Sk.builtin.str.$init = new Sk.builtin.str("__init__");
      Sk.builtin.str.$int_ = new Sk.builtin.str("__int__");
      Sk.builtin.str.$iter = new Sk.builtin.str("__iter__");
      Sk.builtin.str.$file = new Sk.builtin.str("__file__");
      Sk.builtin.str.$float_ = new Sk.builtin.str("__float__");
      Sk.builtin.str.$format = new Sk.builtin.str("__format__");
      Sk.builtin.str.$ge = new Sk.builtin.str("__ge__");
      Sk.builtin.str.$getattr = new Sk.builtin.str("__getattr__");
      Sk.builtin.str.$getattribute = new Sk.builtin.str("__getattribute__");
      Sk.builtin.str.$getitem = new Sk.builtin.str("__getitem__");
      Sk.builtin.str.$gt = new Sk.builtin.str("__gt__");
      Sk.builtin.str.$keys = new Sk.builtin.str("keys");
      Sk.builtin.str.$le = new Sk.builtin.str("__le__");
      Sk.builtin.str.$len = new Sk.builtin.str("__len__");
      Sk.builtin.str.$length_hint = new Sk.builtin.str("__length_hint__");
      Sk.builtin.str.$loader = new Sk.builtin.str("__loader__");
      Sk.builtin.str.$lt = new Sk.builtin.str("__lt__");
      Sk.builtin.str.$module = new Sk.builtin.str("__module__");
      Sk.builtin.str.$missing = new Sk.builtin.str("__missing__");
      Sk.builtin.str.$name = new Sk.builtin.str("__name__");
      Sk.builtin.str.$ne = new Sk.builtin.str("__ne__");
      Sk.builtin.str.$new = new Sk.builtin.str("__new__");
      Sk.builtin.str.$next = new Sk.builtin.str("__next__");
      Sk.builtin.str.$path = new Sk.builtin.str("__path__");
      Sk.builtin.str.$package = new Sk.builtin.str("__package__");
      Sk.builtin.str.$qualname = new Sk.builtin.str("__qualname__");
      Sk.builtin.str.$repr = new Sk.builtin.str("__repr__");
      Sk.builtin.str.$reversed = new Sk.builtin.str("__reversed__");
      Sk.builtin.str.$round = new Sk.builtin.str("__round__");
      Sk.builtin.str.$setattr = new Sk.builtin.str("__setattr__");
      Sk.builtin.str.$setitem = new Sk.builtin.str("__setitem__");
      Sk.builtin.str.$str = new Sk.builtin.str("__str__");
      Sk.builtin.str.$trunc = new Sk.builtin.str("__trunc__");
      Sk.builtin.str.$write = new Sk.builtin.str("write");
      Sk.builtin.str.$sys = new Sk.builtin.str("sys");
      Sk.misceval.op2method_ = {
        Eq: Sk.builtin.str.$eq,
        NotEq: Sk.builtin.str.$ne,
        Gt: Sk.builtin.str.$gt,
        GtE: Sk.builtin.str.$ge,
        Lt: Sk.builtin.str.$lt,
        LtE: Sk.builtin.str.$le
      };
    }
  });

  // src/internalpython.js
  var require_internalpython = __commonJS({
    "src/internalpython.js"() {
      Sk.internalPy = { "files": { "src/classmethod.py": 'class classmethod(object):\n    "Emulate PyClassMethod_Type() in Objects/funcobject.c"\n\n    def __init__(self, f):\n        self.f = f\n\n    def __get__(self, obj, klass=None):\n        if klass is None:\n            klass = type(obj)\n\n        def newfunc(*args):\n            return self.f(klass, *args)\n\n        return newfunc\n', "src/property.py": `class property(object):
    "Emulate PyProperty_Type() in Objects/descrobject.c"

    def __init__(self, fget=None, fset=None, fdel=None, doc=None):
        self.fget = fget
        self.fset = fset
        self.fdel = fdel
        if doc is None and fget is not None:
            if hasattr(fget, '__doc__'):
                doc = fget.__doc__
            else:
                doc = None
        self.__doc__ = doc

    def __get__(self, obj, objtype=None):
        if obj is None:
            return self
        if self.fget is None:
            raise AttributeError("unreadable attribute")
        return self.fget(obj)

    def __set__(self, obj, value):
        if self.fset is None:
            raise AttributeError("can't set attribute")
        self.fset(obj, value)

    def __delete__(self, obj):
        if self.fdel is None:
            raise AttributeError("can't delete attribute")
        self.fdel(obj)

    def getter(self, fget):
        return type(self)(fget, self.fset, self.fdel, self.__doc__)

    def setter(self, fset):
        return type(self)(self.fget, fset, self.fdel, self.__doc__)

    def deleter(self, fdel):
        return type(self)(self.fget, self.fset, fdel, self.__doc__)
`, "src/staticmethod.py": 'class staticmethod(object):\n    "Emulate PyStaticMethod_Type() in Objects/funcobject.c"\n\n    def __init__(self, f):\n        self.f = f\n\n    def __get__(self, obj, objtype=None):\n        return self.f\n' } };
    }
  });

  // src/main.js
  require_util();
  Sk.global["strftime"] = require_strftime();
  require_JSBI();
  require_es6();
  require_setImmediate();
  require_assert_dev();
  require_env();
  require_type();
  require_generic();
  require_check();
  require_abstract();
  require_object();
  require_slotdefs();
  require_descr();
  require_sk_method();
  [Sk.builtin.object, Sk.builtin.type].forEach((cls) => {
    Sk.abstr.setUpSlots(cls);
    Sk.abstr.setUpMethods(cls);
    Sk.abstr.setUpGetSets(cls);
  });
  require_nonetype();
  require_formatting();
  require_str();
  [Sk.builtin.str, Sk.builtin.none, Sk.builtin.NotImplemented, Sk.builtin.object].forEach((cls) => {
    const cls_proto = cls.prototype;
    cls_proto.__doc__ = cls_proto.hasOwnProperty("tp$doc") ? new Sk.builtin.str(cls_proto.tp$doc) : Sk.builtin.none.none$;
  });
  require_function();
  require_builtin();
  require_errors();
  require_method();
  require_misceval();
  require_simple_iterators();
  require_list();
  require_str();
  require_formatting();
  require_bytes();
  require_tuple();
  require_dict();
  require_dictviews();
  require_mappingproxy();
  require_property_class_static();
  require_int();
  require_bool();
  require_float();
  require_complex();
  require_slice();
  require_set();
  require_print();
  require_module();
  require_structseq();
  require_generator();
  require_file();
  require_ffi();
  require_range();
  require_enumerate();
  require_filter();
  require_map();
  require_reversed();
  require_zip();
  require_token();
  init_tokenize();
  require_parse_tables();
  require_parser();
  require_astnodes();
  require_ast();
  require_symtable();
  require_compile();
  require_import();
  require_timsort();
  require_super();
  require_generic_alias();
  require_builtindict();
  require_constants();
  require_internalpython();
})();
/*! unicode_hack.js
    Copyright (C) 2010-2012  Marcelo Gibson de Castro Gonalves. All rights reserved.

    Copying and distribution of this file, with or without modification,
    are permitted in any medium without royalty provided the copyright
    notice and this notice are preserved.  This file is offered as-is,
    without any warranty.
*/
//# sourceMappingURL=skulpt.js.map
